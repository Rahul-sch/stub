<!DOCTYPE html>
<html>
  <head>
    <title>Ithena Industrial IoT Dashboard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      /* ============================================
         HP-HMI DESIGN SYSTEM - CSS VARIABLES
         ISA-101 / ASM Consortium Compliant
         Deviation-only color philosophy
         ============================================ */
      :root {
        /* Base palette - calm, neutral (normal state is boring) */
        --bg-base: #0d0f12;
        --bg-primary: #14171c;
        --bg-secondary: #1a1e24;
        --bg-tertiary: #22272f;
        --bg-elevated: #2a303a;

        /* Text hierarchy */
        --text-primary: #e8eaed;
        --text-secondary: #9aa0a6;
        --text-muted: #5f6368;
        --text-disabled: #3c4043;

        /* Borders */
        --border-subtle: #2a303a;
        --border-default: #3c4043;
        --border-strong: #5f6368;

        /* Status - ONLY for deviations from normal */
        --status-normal: #5f6368;
        --status-running: #34a853;
        --status-warning: #f9ab00;
        --status-error: #ea4335;
        --status-critical: #d93025;
        --status-info: #4285f4;

        /* Interactive elements */
        --interactive-primary: #8ab4f8;
        --interactive-hover: #aecbfa;
        --interactive-active: #669df6;

        /* Spacing scale (consistent rhythm) */
        --space-xs: 4px;
        --space-sm: 8px;
        --space-md: 12px;
        --space-lg: 16px;
        --space-xl: 24px;
        --space-2xl: 32px;

        /* Typography */
        --font-mono: 'SF Mono', 'Consolas', 'Monaco', monospace;
        --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;

        /* Transitions */
        --transition-fast: 0.1s ease;
        --transition-normal: 0.15s ease;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: var(--font-sans);
        background: var(--bg-base);
        color: var(--text-primary);
        padding: var(--space-lg);
        min-height: 100vh;
        line-height: 1.5;
        font-size: 14px;
      }
      .container {
        max-width: 1600px;
        margin: 0 auto;
      }
      /* ============================================
         TYPOGRAPHY - Clean, Professional
         ============================================ */
      h1 {
        font-size: 18px;
        font-weight: 600;
        color: var(--text-primary);
        letter-spacing: -0.3px;
      }

      h2 {
        font-size: 13px;
        font-weight: 600;
        color: var(--text-secondary);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      h3 {
        font-size: 14px;
        font-weight: 600;
        color: var(--text-primary);
      }

      .subtitle {
        font-size: 12px;
        color: var(--text-muted);
        margin-top: var(--space-xs);
      }

      /* Dashboard header bar */
      .dashboard-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: var(--space-md) var(--space-lg);
        background: var(--bg-secondary);
        border: 1px solid var(--border-subtle);
        border-radius: 6px;
        margin-bottom: var(--space-lg);
      }

      .dashboard-header-left {
        display: flex;
        align-items: center;
        gap: var(--space-lg);
      }

      .dashboard-branding {
        display: flex;
        flex-direction: column;
      }

      .dashboard-title {
        font-size: 16px;
        font-weight: 600;
        color: var(--text-primary);
      }

      .dashboard-subtitle {
        font-size: 11px;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      /* ============================================
         GRID LAYOUT
         ============================================ */
      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
        gap: var(--space-lg);
        margin-bottom: var(--space-lg);
      }

      .grid-2 {
        grid-template-columns: repeat(2, 1fr);
      }

      .grid-3 {
        grid-template-columns: repeat(3, 1fr);
      }

      /* ============================================
         CARDS - Flat, No Glassmorphism
         HP-HMI: Reduce visual noise
         ============================================ */
      .card {
        background: var(--bg-secondary);
        border-radius: 6px;
        padding: var(--space-xl);
        border: 1px solid var(--border-subtle);
        transition: border-color var(--transition-normal);
      }

      .card:hover {
        border-color: var(--border-default);
      }

      .card h2 {
        font-size: 12px;
        font-weight: 600;
        margin-bottom: var(--space-lg);
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        display: flex;
        align-items: center;
        gap: var(--space-sm);
      }

      .card-intro {
        font-size: 13px;
        color: var(--text-muted);
        margin-bottom: var(--space-lg);
        line-height: 1.5;
      }
      /* ============================================
         STATS - Monospace Values, Neutral Colors
         HP-HMI: Values are neutral unless abnormal
         ============================================ */
      .stat {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: var(--space-md) 0;
        border-bottom: 1px solid var(--border-subtle);
      }

      .stat:last-child {
        border-bottom: none;
      }

      .stat-label {
        color: var(--text-secondary);
        font-size: 13px;
        display: flex;
        align-items: center;
        gap: var(--space-sm);
      }

      .stat-value {
        font-family: var(--font-mono);
        color: var(--text-primary);
        font-weight: 500;
        font-size: 15px;
      }

      /* Stat value states - color only for deviation */
      .stat-value.normal {
        color: var(--text-primary);
      }

      .stat-value.warning {
        color: var(--status-warning);
      }

      .stat-value.error {
        color: var(--status-error);
      }

      /* Big stat - Primary KPI display */
      .big-stat {
        text-align: center;
        padding: var(--space-xl) var(--space-lg);
        background: var(--bg-tertiary);
        border-radius: 6px;
        margin-bottom: var(--space-lg);
        border: 1px solid var(--border-subtle);
      }

      .big-stat-value {
        font-family: var(--font-mono);
        font-size: 36px;
        font-weight: 600;
        color: var(--text-primary);
        margin-bottom: var(--space-xs);
        letter-spacing: -1px;
      }

      .big-stat-label {
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 1px;
        font-size: 10px;
        font-weight: 600;
      }
      /* ============================================
         BUTTONS - Minimal, Functional
         HP-HMI: Reduce visual weight
         ============================================ */
      button {
        padding: var(--space-sm) var(--space-lg);
        border: none;
        border-radius: 4px;
        font-size: 13px;
        font-weight: 500;
        cursor: pointer;
        transition: background-color var(--transition-normal), opacity var(--transition-normal);
        font-family: inherit;
      }

      button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      .btn-primary {
        background: var(--interactive-primary);
        color: var(--bg-base);
      }

      .btn-primary:hover:not(:disabled) {
        background: var(--interactive-hover);
      }

      .btn-success {
        background: var(--status-running);
        color: white;
      }

      .btn-success:hover:not(:disabled) {
        opacity: 0.9;
      }

      .btn-danger {
        background: var(--status-error);
        color: white;
      }

      .btn-danger:hover:not(:disabled) {
        opacity: 0.9;
      }

      .btn-warning {
        background: var(--status-warning);
        color: var(--bg-base);
      }

      .btn-warning:hover:not(:disabled) {
        opacity: 0.9;
      }

      .btn-secondary {
        background: var(--bg-elevated);
        color: var(--text-primary);
        border: 1px solid var(--border-default);
      }

      .btn-secondary:hover:not(:disabled) {
        background: var(--bg-tertiary);
        border-color: var(--border-strong);
      }

      .btn-toggle {
        background: var(--bg-tertiary);
        color: var(--text-secondary);
        padding: var(--space-sm) var(--space-lg);
        font-size: 12px;
        border: 1px solid var(--border-subtle);
      }

      .btn-toggle:hover {
        background: var(--bg-elevated);
      }

      .btn-toggle.active {
        background: var(--interactive-primary);
        color: var(--bg-base);
        border-color: var(--interactive-primary);
      }

      .controls {
        display: flex;
        gap: var(--space-sm);
        flex-wrap: wrap;
        margin-top: var(--space-lg);
      }
      input[type="number"] {
        padding: 14px 16px;
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 12px;
        background: rgba(15, 23, 42, 0.6);
        color: #e2e8f0;
        font-size: 15px;
        font-weight: 600;
        width: 100%;
        transition: all 0.3s;
      }
      input[type="number"]:focus {
        outline: none;
        border-color: #60a5fa;
        box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.1);
      }
      .input-group {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        margin-bottom: 16px;
      }
      .input-wrapper {
        position: relative;
      }
      .input-label {
        position: absolute;
        top: -8px;
        left: 12px;
        background: rgba(30, 41, 59, 0.9);
        padding: 0 8px;
        color: #60a5fa;
        font-size: 11px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 1px;
      }
      label {
        display: block;
        margin-bottom: 12px;
        color: #60a5fa;
        font-weight: 700;
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 1px;
      }
      /* ============================================
         STATUS INDICATORS - Deviation-Only Color
         HP-HMI: Normal state is intentionally muted
         Color appears ONLY when attention needed
         ============================================ */
      .status-indicator {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-right: var(--space-sm);
        flex-shrink: 0;
      }

      .status-running {
        background: var(--status-running);
        box-shadow: 0 0 0 2px rgba(52, 168, 83, 0.2);
      }

      .status-stopped {
        background: var(--status-error);
        box-shadow: 0 0 0 2px rgba(234, 67, 53, 0.2);
      }

      .status-pending {
        background: var(--status-warning);
        box-shadow: 0 0 0 2px rgba(249, 171, 0, 0.2);
        animation: status-pulse 1.5s ease-in-out infinite;
      }

      .status-unknown {
        background: var(--status-normal);
      }

      @keyframes status-pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
      }

      /* Status text labels */
      .status-text {
        font-size: 11px;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .status-text.running {
        color: var(--status-running);
      }

      .status-text.stopped {
        color: var(--status-error);
      }

      .status-text.warning {
        color: var(--status-warning);
      }
      .history-container {
        max-height: 600px;
        overflow-y: auto;
        background: rgba(15, 23, 42, 0.6);
        border-radius: 16px;
        padding: 16px;
      }
      .history-container::-webkit-scrollbar {
        width: 8px;
      }
      .history-container::-webkit-scrollbar-track {
        background: rgba(15, 23, 42, 0.4);
        border-radius: 4px;
      }
      .history-container::-webkit-scrollbar-thumb {
        background: rgba(96, 165, 250, 0.5);
        border-radius: 4px;
      }
      .history-container::-webkit-scrollbar-thumb:hover {
        background: rgba(96, 165, 250, 0.7);
      }
      .history-item {
        background: rgba(30, 41, 59, 0.8);
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 16px;
        border-left: 4px solid #60a5fa;
        transition: all 0.3s;
      }
      .history-item:hover {
        transform: translateX(4px);
        box-shadow: 0 4px 20px rgba(96, 165, 250, 0.2);
      }
      .history-timestamp {
        color: #94a3b8;
        font-size: 11px;
        margin-bottom: 14px;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-weight: 600;
      }
      .history-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
        gap: 14px;
      }
      .history-metric {
        text-align: center;
        padding: 12px;
        background: rgba(15, 23, 42, 0.6);
        border-radius: 10px;
        border: 1px solid rgba(96, 165, 250, 0.1);
      }
      .history-metric.hidden {
        display: none;
      }
      /* ============================================
         ALERTS - Severity-Based Visual Weight
         HP-HMI: Border color indicates severity
         ============================================ */
      .alert-list {
        display: flex;
        flex-direction: column;
        gap: var(--space-sm);
        max-height: 360px;
        overflow-y: auto;
      }

      .alert-item {
        background: var(--bg-tertiary);
        border-radius: 4px;
        padding: var(--space-md);
        border-left: 3px solid var(--border-default);
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: var(--space-md);
      }

      .alert-item.severity-critical {
        border-left-color: var(--status-critical);
        background: rgba(217, 48, 37, 0.08);
      }

      .alert-item.severity-error {
        border-left-color: var(--status-error);
      }

      .alert-item.severity-warning {
        border-left-color: var(--status-warning);
      }

      .alert-item.severity-info {
        border-left-color: var(--status-info);
      }

      .alert-type {
        font-weight: 500;
        color: var(--text-primary);
        font-size: 13px;
      }

      .alert-message {
        color: var(--text-secondary);
        font-size: 12px;
        margin-top: var(--space-xs);
        line-height: 1.4;
      }

      .alert-meta {
        text-align: right;
        font-size: 11px;
        color: var(--text-muted);
        flex-shrink: 0;
      }

      .alert-time {
        margin-top: var(--space-xs);
      }

      /* Alert badges - compact pills */
      .alert-badge {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 3px;
        font-size: 10px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.3px;
      }

      .alert-badge.critical {
        background: var(--status-critical);
        color: white;
      }

      .alert-badge.error {
        background: rgba(234, 67, 53, 0.15);
        color: var(--status-error);
      }

      .alert-badge.warning {
        background: rgba(249, 171, 0, 0.15);
        color: var(--status-warning);
      }

      .alert-badge.info {
        background: rgba(66, 133, 244, 0.15);
        color: var(--status-info);
      }
      .config-meta {
        margin-top: 12px;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: #94a3b8;
        min-height: 16px;
      }
      .metric-value {
        font-size: 20px;
        font-weight: 900;
        background: linear-gradient(135deg, #60a5fa 0%, #a78bfa 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }
      .metric-label {
        font-size: 10px;
        color: #94a3b8;
        margin-top: 6px;
        text-transform: uppercase;
        letter-spacing: 1px;
        font-weight: 600;
      }
      .toggles {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        margin-bottom: 20px;
      }
      .preset-container {
        margin-top: 20px;
        padding: 20px;
        background: rgba(15, 23, 42, 0.6);
        border-radius: 16px;
        border: 1px solid rgba(96, 165, 250, 0.2);
      }
      .preset-title {
        color: #94a3b8;
        font-size: 12px;
        font-weight: 700;
        margin-bottom: 12px;
        text-transform: uppercase;
        letter-spacing: 1px;
      }
      .preset-buttons {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
      }
      .tabs {
        display: flex;
        gap: 8px;
        margin-bottom: 20px;
        flex-wrap: wrap;
      }
      .tab {
        padding: 10px 20px;
        background: rgba(71, 85, 105, 0.3);
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 10px;
        cursor: pointer;
        font-size: 13px;
        font-weight: 600;
        color: #94a3b8;
        transition: all 0.3s;
        text-transform: uppercase;
        letter-spacing: 1px;
      }
      .tab:hover {
        background: rgba(71, 85, 105, 0.5);
        border-color: rgba(96, 165, 250, 0.3);
      }
      .tab.active {
        background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
        border-color: #3b82f6;
        color: white;
        box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
      }
      .tab-content {
        display: none;
      }
      .tab-content.active {
        display: block;
      }
      .sensor-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 16px;
      }
      .sensor-item {
        background: rgba(15, 23, 42, 0.6);
        border-radius: 12px;
        padding: 16px;
        border: 1px solid rgba(96, 165, 250, 0.1);
        transition: all 0.3s;
      }
      .sensor-item:hover {
        border-color: rgba(96, 165, 250, 0.3);
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(96, 165, 250, 0.1);
      }
      .sensor-name {
        color: #94a3b8;
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 8px;
        font-weight: 600;
      }
      .sensor-value {
        font-size: 24px;
        font-weight: 900;
        background: linear-gradient(135deg, #60a5fa 0%, #a78bfa 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }
      .sensor-unit {
        color: #94a3b8;
        font-size: 12px;
        margin-left: 4px;
      }
      .sensor-toggle {
        position: absolute;
        top: 8px;
        right: 8px;
        width: 16px;
        height: 16px;
        cursor: pointer;
        opacity: 0.5;
        transition: opacity 0.3s;
      }
      .sensor-toggle:hover {
        opacity: 1;
      }
      .sensor-item.hidden-sensor {
        opacity: 0.3;
        filter: grayscale(100%);
      }
      .sensor-item {
        position: relative;
      }
      /* Threshold Controls */
      .threshold-toggle {
        color: #60a5fa;
        font-size: 12px;
        cursor: pointer;
        margin-top: 10px;
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 6px 10px;
        background: rgba(96, 165, 250, 0.1);
        border-radius: 6px;
        transition: all 0.2s;
      }
      .threshold-toggle:hover {
        color: #93c5fd;
        background: rgba(96, 165, 250, 0.2);
      }
      .threshold-controls {
        display: none;
        margin-top: 14px;
        padding: 16px;
        background: rgba(15, 23, 42, 0.6);
        border-radius: 10px;
        border: 1px solid rgba(148, 163, 184, 0.2);
      }
      .threshold-controls.expanded {
        display: block;
        animation: slideDown 0.2s ease-out;
      }
      @keyframes slideDown {
        from {
          opacity: 0;
          transform: translateY(-8px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      .threshold-row {
        display: flex;
        gap: 12px;
        align-items: center;
        margin-bottom: 12px;
        flex-wrap: wrap;
      }
      .threshold-field {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .threshold-input {
        width: 100px;
        padding: 10px 12px;
        background: rgba(30, 41, 59, 0.8);
        border: 1px solid rgba(148, 163, 184, 0.3);
        border-radius: 8px;
        color: #e2e8f0;
        font-size: 14px;
        text-align: center;
        transition: border-color 0.2s, box-shadow 0.2s;
      }
      .threshold-input:focus {
        outline: none;
        border-color: #60a5fa;
        box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.2);
      }
      .threshold-input:hover {
        border-color: rgba(148, 163, 184, 0.5);
      }
      .threshold-label {
        font-size: 11px;
        color: #94a3b8;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      .threshold-buttons {
        display: flex;
        gap: 8px;
        margin-top: 4px;
      }
      .threshold-save-btn {
        background: #10b981;
        color: white;
        border: none;
        padding: 10px 18px;
        border-radius: 8px;
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
      }
      .threshold-save-btn:hover {
        background: #059669;
        transform: translateY(-1px);
      }
      .threshold-reset-btn {
        background: #475569;
        color: white;
        border: none;
        padding: 10px 18px;
        border-radius: 8px;
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
      }
      .threshold-reset-btn:hover {
        background: #64748b;
      }
      .threshold-default {
        font-size: 11px;
        color: #64748b;
        margin-top: 8px;
        padding: 8px 12px;
        background: rgba(100, 116, 139, 0.1);
        border-radius: 6px;
        display: inline-block;
      }
      .threshold-active {
        background: rgba(16, 185, 129, 0.1);
        border-color: rgba(16, 185, 129, 0.3);
      }
      .threshold-active .threshold-toggle {
        color: #10b981;
        background: rgba(16, 185, 129, 0.15);
      }
      .card-intro {
        font-size: 14px;
        color: #cbd5f5;
        margin-bottom: 16px;
        line-height: 1.5;
      }
      .hero-info {
        margin-bottom: 24px;
        border-radius: 18px;
        border: 1px solid rgba(96, 165, 250, 0.3);
        background: rgba(15, 23, 42, 0.4);
        overflow: hidden;
      }
      .hero-info summary {
        list-style: none;
        cursor: pointer;
        padding: 18px 24px;
        font-size: 16px;
        font-weight: 700;
        text-align: center;
        color: #e2e8f0;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        background: rgba(30, 41, 59, 0.7);
      }
      .hero-info summary::-webkit-details-marker {
        display: none;
      }
      .hero-info .chevron {
        transition: transform 0.3s;
        font-size: 18px;
      }
      .hero-info[open] .chevron {
        transform: rotate(180deg);
      }
      .hero-wrapper {
        padding: 20px;
      }
      .hero {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 20px;
        background: rgba(15, 23, 42, 0.7);
        border: 1px solid rgba(96, 165, 250, 0.2);
        border-radius: 20px;
        padding: 28px;
        margin-bottom: 32px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      }
      .hero h3 {
        font-size: 18px;
        margin-bottom: 10px;
        color: #f8fafc;
      }
      .hero p {
        color: #cbd5f5;
        line-height: 1.6;
        margin-bottom: 16px;
      }
      .step-list {
        list-style: none;
        display: grid;
        gap: 10px;
      }
      .step-list li {
        display: flex;
        gap: 12px;
        padding: 12px;
        border-radius: 12px;
        background: rgba(30, 41, 59, 0.7);
        border: 1px solid rgba(96, 165, 250, 0.1);
        align-items: center;
      }
      .step-number {
        width: 32px;
        height: 32px;
        border-radius: 999px;
        background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 800;
        font-size: 14px;
      }
      .pipeline-flow {
        display: flex;
        gap: 12px;
        align-items: stretch;
        flex-wrap: wrap;
      }
      .flow-node {
        flex: 1;
        min-width: 140px;
        padding: 12px;
        border-radius: 14px;
        background: rgba(30, 41, 59, 0.7);
        border: 1px solid rgba(96, 165, 250, 0.1);
      }
      .flow-title {
        font-weight: 700;
        color: #f8fafc;
        margin-bottom: 6px;
      }
      .flow-text {
        font-size: 13px;
        color: #cbd5f5;
        line-height: 1.4;
      }
      .flow-arrow {
        display: flex;
        align-items: center;
        justify-content: center;
        color: #94a3b8;
        font-weight: 700;
        font-size: 18px;
        min-width: 24px;
      }
      .legend {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 12px;
      }
      .legend-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 12px;
        border-radius: 12px;
        background: rgba(30, 41, 59, 0.7);
        border: 1px solid rgba(96, 165, 250, 0.1);
        font-size: 13px;
        color: #cbd5f5;
      }
      .info-pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 10px 16px;
        border-radius: 999px;
        border: 1px solid rgba(96, 165, 250, 0.2);
        font-size: 13px;
        background: rgba(96, 165, 250, 0.08);
        color: #cbd5f5;
        margin-top: 12px;
      }
      .hero-note {
        font-size: 13px;
        color: #94a3b8;
        line-height: 1.6;
      }

      /* ============================================
         ML ANOMALY DETECTION - Clear, Scannable
         HP-HMI: Anomalies get attention via border
         ============================================ */
      .anomaly-item {
        background: var(--bg-tertiary);
        border-radius: 4px;
        padding: var(--space-lg);
        margin-bottom: var(--space-sm);
        border-left: 3px solid var(--status-error);
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: var(--space-lg);
      }

      .anomaly-info {
        flex: 1;
        min-width: 0;
      }

      .anomaly-header {
        display: flex;
        align-items: center;
        gap: var(--space-sm);
        margin-bottom: var(--space-sm);
        flex-wrap: wrap;
      }

      .anomaly-score {
        background: var(--status-error);
        color: white;
        padding: 2px 8px;
        border-radius: 3px;
        font-size: 11px;
        font-weight: 600;
        font-family: var(--font-mono);
      }

      .anomaly-method {
        color: var(--text-muted);
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .anomaly-timestamp {
        color: var(--text-secondary);
        font-size: 12px;
        font-family: var(--font-mono);
      }

      .anomaly-sensors {
        color: var(--text-muted);
        font-size: 12px;
        margin-top: var(--space-sm);
        line-height: 1.6;
      }

      .anomaly-sensors span {
        display: inline-block;
        background: var(--bg-elevated);
        color: var(--text-secondary);
        padding: 2px 6px;
        border-radius: 3px;
        margin-right: var(--space-xs);
        margin-top: var(--space-xs);
        font-size: 10px;
        font-family: var(--font-mono);
      }

      .anomaly-actions {
        display: flex;
        flex-direction: column;
        gap: var(--space-sm);
        flex-shrink: 0;
      }

      .btn-report {
        background: var(--bg-elevated);
        color: var(--text-primary);
        padding: var(--space-sm) var(--space-md);
        border: 1px solid var(--border-default);
        border-radius: 4px;
        font-size: 11px;
        font-weight: 500;
        cursor: pointer;
        transition: all var(--transition-normal);
        white-space: nowrap;
      }

      .btn-report:hover:not(:disabled) {
        background: var(--interactive-primary);
        color: var(--bg-base);
        border-color: var(--interactive-primary);
      }

      .btn-report:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }

      .btn-view-report {
        background: var(--status-running);
        color: white;
        border-color: var(--status-running);
      }

      .btn-view-report:hover:not(:disabled) {
        opacity: 0.9;
        background: var(--status-running);
      }

      .report-status {
        font-size: 10px;
        color: var(--text-muted);
        text-align: center;
      }

      /* Modal Styles */
      .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(5px);
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 20px;
      }
      .modal-content {
        background: #1e293b;
        border-radius: 20px;
        width: 100%;
        max-width: 900px;
        max-height: 90vh;
        overflow: hidden;
        border: 1px solid rgba(96, 165, 250, 0.2);
        box-shadow: 0 25px 80px rgba(0, 0, 0, 0.5);
      }
      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px 24px;
        border-bottom: 1px solid rgba(148, 163, 184, 0.1);
        background: rgba(15, 23, 42, 0.6);
      }
      .modal-header h2 {
        margin: 0;
        font-size: 20px;
        color: #f8fafc;
      }
      .modal-close {
        background: none;
        border: none;
        color: #94a3b8;
        font-size: 28px;
        cursor: pointer;
        padding: 0;
        line-height: 1;
        transition: color 0.3s;
      }
      .modal-close:hover {
        color: #ef4444;
      }
      .modal-body {
        padding: 24px;
        overflow-y: auto;
        max-height: calc(90vh - 80px);
        color: #e2e8f0;
        line-height: 1.7;
      }
      .modal-body h3 {
        color: #60a5fa;
        margin-top: 24px;
        margin-bottom: 12px;
        font-size: 16px;
        text-transform: uppercase;
        letter-spacing: 1px;
      }
      .modal-body h3:first-child {
        margin-top: 0;
      }
      .modal-body ul {
        margin-left: 20px;
        margin-bottom: 16px;
      }
      .modal-body li {
        margin-bottom: 8px;
      }
      .modal-body p {
        margin-bottom: 12px;
      }
      .report-meta {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 16px;
        margin-bottom: 24px;
        padding: 16px;
        background: rgba(15, 23, 42, 0.6);
        border-radius: 12px;
      }
      .report-meta-item {
        text-align: center;
      }
      .report-meta-label {
        color: #94a3b8;
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-bottom: 4px;
      }
      .report-meta-value {
        color: #60a5fa;
        font-size: 18px;
        font-weight: 700;
      }
      .report-analysis {
        background: rgba(15, 23, 42, 0.4);
        padding: 24px;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.2);
        line-height: 1.8;
        color: #e2e8f0;
      }
      .report-analysis h3 {
        color: #10b981;
        border-bottom: 2px solid rgba(16, 185, 129, 0.3);
        padding-bottom: 12px;
        margin-top: 32px;
        margin-bottom: 16px;
        font-size: 18px;
        font-weight: 700;
      }
      .report-analysis h3:first-child {
        margin-top: 0;
      }
      .report-analysis p {
        margin-bottom: 16px;
        line-height: 1.8;
      }
      .report-analysis ul {
        margin-left: 24px;
        margin-bottom: 16px;
      }
      .report-analysis li {
        margin-bottom: 10px;
        line-height: 1.7;
      }
      .report-analysis strong {
        color: #60a5fa;
        font-weight: 700;
      }
      .report-analysis em {
        color: #fbbf24;
        font-style: italic;
      }
      .report-analysis code {
        background: rgba(30, 41, 59, 0.8);
        color: #10b981;
        padding: 2px 8px;
        border-radius: 4px;
        font-family: 'Courier New', monospace;
        font-size: 13px;
      }
      .report-analysis pre {
        background: rgba(15, 23, 42, 0.8);
        border: 1px solid rgba(100, 116, 139, 0.3);
        border-radius: 8px;
        padding: 16px;
        overflow-x: auto;
        margin: 16px 0;
      }
      .report-analysis pre code {
        background: none;
        padding: 0;
      }
      .btn-download-report {
        background: linear-gradient(135deg, #3b82f6, #2563eb);
        color: white;
        padding: 10px 20px;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        transition: all 0.3s;
      }
      .btn-download-report:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
      }
      .loading-spinner {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: white;
        animation: spin 1s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      /* ============================================
         MACHINE & MODE CONTROLS
         HP-HMI: Clear context indication
         ============================================ */
      .machine-mode-controls {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: var(--space-lg);
        padding: var(--space-md) var(--space-lg);
        background: var(--bg-secondary);
        border-radius: 6px;
        border: 1px solid var(--border-subtle);
        flex-wrap: wrap;
        gap: var(--space-lg);
      }

      .machine-selector {
        display: flex;
        align-items: center;
        gap: var(--space-md);
      }

      .machine-selector label {
        color: var(--text-muted);
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .machine-buttons {
        display: flex;
        gap: var(--space-xs);
      }

      .machine-btn {
        padding: var(--space-sm) var(--space-md);
        border: 1px solid var(--border-default);
        background: var(--bg-tertiary);
        color: var(--text-secondary);
        border-radius: 4px;
        cursor: pointer;
        font-weight: 500;
        font-size: 13px;
        transition: all var(--transition-normal);
        display: flex;
        align-items: center;
        gap: var(--space-sm);
      }

      .machine-btn:hover {
        border-color: var(--border-strong);
        background: var(--bg-elevated);
      }

      .machine-btn.active {
        background: var(--interactive-primary);
        border-color: var(--interactive-primary);
        color: var(--bg-base);
      }

      /* Machine status dot inside button */
      .machine-btn .machine-status {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: var(--status-normal);
      }

      .machine-btn .machine-status.running {
        background: var(--status-running);
      }

      .machine-btn.active .machine-status {
        background: var(--bg-base);
      }

      .mode-toggle {
        display: flex;
        align-items: center;
        gap: var(--space-md);
      }

      .mode-toggle label {
        color: var(--text-muted);
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .mode-buttons {
        display: flex;
        gap: 2px;
        background: var(--bg-tertiary);
        padding: 3px;
        border-radius: 4px;
        border: 1px solid var(--border-subtle);
      }

      .mode-btn {
        padding: var(--space-sm) var(--space-lg);
        border: none;
        background: transparent;
        color: var(--text-muted);
        border-radius: 3px;
        cursor: pointer;
        font-weight: 500;
        font-size: 12px;
        transition: all var(--transition-normal);
      }

      .mode-btn:hover {
        color: var(--text-primary);
      }

      .mode-btn.active {
        background: var(--bg-elevated);
        color: var(--text-primary);
      }
      /* ============================================
         ADMIN PANEL
         HP-HMI: Isolated configuration area
         ============================================ */
      .admin-panel {
        display: none;
        margin-bottom: var(--space-lg);
      }

      .admin-panel.active {
        display: block;
      }

      .admin-section {
        background: var(--bg-secondary);
        border-radius: 6px;
        padding: var(--space-xl);
        margin-bottom: var(--space-lg);
        border: 1px solid var(--border-subtle);
      }

      .admin-section h3 {
        color: var(--text-primary);
        font-size: 14px;
        font-weight: 600;
        margin-bottom: var(--space-lg);
        display: flex;
        align-items: center;
        gap: var(--space-sm);
      }

      .sensor-control-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: var(--space-sm);
        margin-top: var(--space-lg);
      }

      .sensor-control-item {
        background: var(--bg-tertiary);
        padding: var(--space-md);
        border-radius: 4px;
        border: 1px solid var(--border-subtle);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .sensor-control-item.disabled {
        opacity: 0.5;
      }

      .sensor-control-name {
        color: var(--text-primary);
        font-size: 13px;
        font-weight: 500;
      }

      .sensor-control-actions {
        display: flex;
        gap: var(--space-sm);
        align-items: center;
      }

      .baseline-input {
        width: 80px;
        padding: var(--space-xs) var(--space-sm);
        border: 1px solid var(--border-default);
        border-radius: 3px;
        background: var(--bg-primary);
        color: var(--text-primary);
        font-size: 12px;
        font-family: var(--font-mono);
      }

      .baseline-input:focus {
        outline: none;
        border-color: var(--interactive-primary);
      }

      /* Toggle switch */
      .toggle-switch {
        position: relative;
        width: 36px;
        height: 20px;
      }

      .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      .toggle-slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: var(--bg-elevated);
        transition: var(--transition-normal);
        border-radius: 10px;
        border: 1px solid var(--border-default);
      }

      .toggle-slider:before {
        position: absolute;
        content: "";
        height: 14px;
        width: 14px;
        left: 2px;
        bottom: 2px;
        background-color: var(--text-muted);
        transition: var(--transition-normal);
        border-radius: 50%;
      }

      input:checked + .toggle-slider {
        background-color: var(--status-running);
        border-color: var(--status-running);
      }

      input:checked + .toggle-slider:before {
        transform: translateX(16px);
        background-color: white;
      }
      /* Refresh Rate Buttons */
      .refresh-rate-btn {
        transition: all 0.3s;
      }
      .refresh-rate-btn.active {
        background: linear-gradient(135deg, #10b981 0%, #059669 100%) !important;
        box-shadow: 0 2px 10px rgba(16, 185, 129, 0.3);
      }

      /* ============================================
         ADMIN 3-PANE LAYOUT
         HP-HMI: Clear separation of categories
         ============================================ */
      .admin-3pane {
        display: grid;
        grid-template-columns: 160px 1fr 1fr;
        gap: var(--space-md);
        min-height: 400px;
      }

      .admin-pane {
        background: var(--bg-tertiary);
        border-radius: 4px;
        border: 1px solid var(--border-subtle);
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .admin-pane-header {
        padding: var(--space-sm) var(--space-md);
        background: var(--bg-elevated);
        border-bottom: 1px solid var(--border-subtle);
        font-weight: 600;
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        color: var(--text-muted);
      }

      .admin-pane-header.active-header {
        color: var(--status-running);
      }

      .admin-pane-header.disabled-header {
        color: var(--status-error);
      }

      .admin-pane-content {
        flex: 1;
        overflow-y: auto;
        padding: var(--space-sm);
      }

      .admin-pane-content.drop-zone-active {
        background: rgba(138, 180, 248, 0.08);
        border: 2px dashed var(--interactive-primary);
        border-radius: 4px;
        margin: var(--space-xs);
      }

      /* Category Selector */
      .category-list {
        padding: var(--space-xs);
      }

      .category-item {
        padding: var(--space-sm) var(--space-md);
        margin-bottom: 2px;
        border-radius: 3px;
        cursor: pointer;
        transition: all var(--transition-fast);
        color: var(--text-secondary);
        font-size: 12px;
        display: flex;
        align-items: center;
        gap: var(--space-sm);
      }

      .category-item:hover {
        background: var(--bg-elevated);
        color: var(--text-primary);
      }

      .category-item.active {
        background: var(--interactive-primary);
        color: var(--bg-base);
        font-weight: 500;
      }

      .category-icon {
        font-size: 14px;
      }

      .category-count {
        margin-left: auto;
        background: var(--bg-elevated);
        padding: 1px 6px;
        border-radius: 3px;
        font-size: 10px;
        font-family: var(--font-mono);
      }

      .category-item.active .category-count {
        background: rgba(0, 0, 0, 0.2);
      }

      /* ========== Admin Sensor List - Sortable ========== */
      .admin-sensor-list {
        max-height: 500px;
        overflow-y: auto;
        padding: 8px;
      }

      .admin-sensor-list.empty-list {
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 100px;
        color: #64748b;
        font-size: 13px;
        text-align: center;
        padding: 20px;
      }

      .admin-sensor-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 10px 12px;
        margin-bottom: 6px;
        background: rgba(255, 255, 255, 0.08);
        border-radius: 8px;
        border: 1px solid transparent;
        transition: all 0.15s ease;
      }

      .admin-sensor-item:hover {
        background: rgba(255, 255, 255, 0.12);
      }

      .admin-sensor-item.dragging {
        opacity: 0.9;
        background: rgba(59, 130, 246, 0.3);
        border-color: rgba(59, 130, 246, 0.5);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        z-index: 1000;
      }

      .admin-sensor-item.disabled {
        opacity: 0.5;
      }

      .admin-sensor-item.drop-target-above {
        border-top: 2px solid #3b82f6;
      }

      .admin-sensor-item.drop-target-below {
        border-bottom: 2px solid #3b82f6;
      }

      .drag-handle {
        cursor: grab;
        padding: 4px;
        color: rgba(255, 255, 255, 0.4);
        font-size: 16px;
      }

      .drag-handle:active {
        cursor: grabbing;
      }

      .sensor-info {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 2px;
      }

      .sensor-info .sensor-name {
        font-weight: 500;
        color: #e2e8f0;
      }

      .sensor-info .sensor-category {
        font-size: 11px;
        color: rgba(255, 255, 255, 0.5);
        text-transform: uppercase;
      }

      .sensor-controls {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .move-btn {
        background: rgba(255, 255, 255, 0.1);
        border: none;
        border-radius: 4px;
        padding: 4px 8px;
        color: rgba(255, 255, 255, 0.7);
        cursor: pointer;
        font-size: 12px;
        transition: background 0.15s;
      }

      .move-btn:hover {
        background: rgba(255, 255, 255, 0.2);
      }

      .move-btn:disabled {
        opacity: 0.3;
        cursor: not-allowed;
      }

      .toggle-btn {
        padding: 6px 14px;
        border: none;
        border-radius: 6px;
        font-size: 12px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.15s;
      }

      .toggle-btn.enabled {
        background: rgba(34, 197, 94, 0.25);
        color: #4ade80;
      }

      .toggle-btn.disabled-state {
        background: rgba(239, 68, 68, 0.25);
        color: #f87171;
      }

      .reset-config-btn {
        margin-top: 16px;
        padding: 10px 20px;
        background: rgba(251, 146, 60, 0.2);
        border: 1px solid rgba(251, 146, 60, 0.4);
        color: #fb923c;
        border-radius: 6px;
        cursor: pointer;
        transition: background 0.15s;
      }

      .reset-config-btn:hover {
        background: rgba(251, 146, 60, 0.3);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>ðŸš€ Sensor Data Pipeline</h1>
      <div class="subtitle">Real-Time IoT Monitoring Dashboard</div>

      <!-- Login/Signup Form (shown when not authenticated) -->
      <div id="loginForm" style="display: none; max-width: 400px; margin: 100px auto; padding: 40px; background: rgba(30, 41, 59, 0.8); border-radius: 20px; border: 1px solid rgba(148, 163, 184, 0.2);">
        <div style="display: flex; gap: 10px; margin-bottom: 30px; border-bottom: 1px solid rgba(148, 163, 184, 0.2);">
          <button id="showLoginBtn" onclick="showLoginForm()" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #60a5fa 0%, #a78bfa 100%); border: none; border-radius: 8px 8px 0 0; color: white; font-weight: 600; font-size: 14px; cursor: pointer;">Login</button>
          <button id="showSignupBtnAuth" onclick="showSignupFormAuth()" style="flex: 1; padding: 12px; background: rgba(15, 23, 42, 0.6); border: none; border-radius: 8px 8px 0 0; color: #94a3b8; font-weight: 600; font-size: 14px; cursor: pointer;">Sign Up</button>
        </div>
        
        <!-- Login Form -->
        <div id="loginFormContent">
          <form id="loginFormElement" onsubmit="handleLogin(event)">
            <div style="margin-bottom: 20px;">
              <label style="display: block; margin-bottom: 8px; color: #94a3b8; font-size: 14px;">Username</label>
              <input type="text" id="loginUsername" required style="width: 100%; padding: 12px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 8px; color: #e2e8f0; font-size: 14px; box-sizing: border-box;">
            </div>
            <div style="margin-bottom: 20px;">
              <label style="display: block; margin-bottom: 8px; color: #94a3b8; font-size: 14px;">Password</label>
              <input type="password" id="loginPassword" required style="width: 100%; padding: 12px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 8px; color: #e2e8f0; font-size: 14px; box-sizing: border-box;">
            </div>
            <button type="submit" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #60a5fa 0%, #a78bfa 100%); border: none; border-radius: 8px; color: white; font-weight: 600; font-size: 14px; cursor: pointer;">Login</button>
            <div id="loginError" style="margin-top: 16px; color: #f87171; font-size: 14px; text-align: center; display: none;"></div>
          </form>
        </div>

        <!-- Signup Form (hidden by default) -->
        <div id="signupFormContent" style="display: none;">
          <form id="signupFormElementAuth" onsubmit="handleSignupAuth(event)">
            <div style="margin-bottom: 16px;">
              <label style="display: block; margin-bottom: 6px; color: #94a3b8; font-size: 13px;">Username</label>
              <input type="text" id="signupUsernameAuth" required style="width: 100%; padding: 10px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 8px; color: #e2e8f0; font-size: 14px; box-sizing: border-box;">
            </div>
            <div style="margin-bottom: 16px;">
              <label style="display: block; margin-bottom: 6px; color: #94a3b8; font-size: 13px;">Password</label>
              <input type="password" id="signupPasswordAuth" required style="width: 100%; padding: 10px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 8px; color: #e2e8f0; font-size: 14px; box-sizing: border-box;">
            </div>
            <div style="margin-bottom: 16px;">
              <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="signupAdminToggle" onchange="toggleMachineSelectionAuth()" style="cursor: pointer; width: 18px; height: 18px;">
                <span style="color: #e2e8f0; font-size: 14px;">Create as Admin</span>
              </label>
            </div>
            <div id="machineSelectionAuth" style="margin-bottom: 16px; display: none;">
              <label style="display: block; margin-bottom: 8px; color: #94a3b8; font-size: 13px;">Machine Access (select at least one)</label>
              <div style="display: flex; gap: 12px;">
                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                  <input type="checkbox" value="A" class="machine-checkbox-auth" style="cursor: pointer;">
                  <span style="color: #e2e8f0;">Machine A</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                  <input type="checkbox" value="B" class="machine-checkbox-auth" style="cursor: pointer;">
                  <span style="color: #e2e8f0;">Machine B</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                  <input type="checkbox" value="C" class="machine-checkbox-auth" style="cursor: pointer;">
                  <span style="color: #e2e8f0;">Machine C</span>
                </label>
              </div>
            </div>
            <button type="submit" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #10b981 0%, #059669 100%); border: none; border-radius: 8px; color: white; font-weight: 600; font-size: 14px; cursor: pointer;">Sign Up</button>
            <div id="signupErrorAuth" style="margin-top: 12px; color: #f87171; font-size: 13px; text-align: center; display: none;"></div>
            <div id="signupSuccessAuth" style="margin-top: 12px; color: #10b981; font-size: 13px; text-align: center; display: none;"></div>
          </form>
        </div>
      </div>

      <!-- Main Dashboard (hidden when not authenticated) -->
      <div id="mainDashboard" style="display: none;">
        <!-- User Info Bar -->
        <div style="text-align: right; margin-bottom: 20px; padding: 12px; background: rgba(30, 41, 59, 0.6); border-radius: 12px; border: 1px solid rgba(148, 163, 184, 0.1);">
          <span id="userInfo" style="color: #94a3b8; margin-right: 16px;"></span>
          <button id="showSignupBtn" onclick="toggleSignupForm()" style="display: none; padding: 6px 16px; background: rgba(96, 165, 250, 0.2); border: 1px solid rgba(96, 165, 250, 0.3); border-radius: 6px; color: #60a5fa; font-size: 12px; cursor: pointer; margin-right: 8px;">âž• Create User</button>
          <button onclick="handleLogout()" style="padding: 6px 16px; background: rgba(248, 113, 113, 0.2); border: 1px solid rgba(248, 113, 113, 0.3); border-radius: 6px; color: #f87171; font-size: 12px; cursor: pointer;">Logout</button>
        </div>

        <!-- Sign Up Form (admin only, hidden by default) -->
        <div id="signupForm" style="display: none; max-width: 500px; margin: 0 auto 30px; padding: 30px; background: rgba(30, 41, 59, 0.8); border-radius: 16px; border: 1px solid rgba(148, 163, 184, 0.2);">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="color: #60a5fa; margin: 0;">Create New User</h3>
            <button onclick="toggleSignupForm()" style="background: none; border: none; color: #94a3b8; font-size: 20px; cursor: pointer; padding: 0; width: 24px; height: 24px;">âœ•</button>
          </div>
          <form id="signupFormElement" onsubmit="handleSignup(event)">
            <div style="margin-bottom: 16px;">
              <label style="display: block; margin-bottom: 6px; color: #94a3b8; font-size: 13px;">Username</label>
              <input type="text" id="signupUsername" required style="width: 100%; padding: 10px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 8px; color: #e2e8f0; font-size: 14px; box-sizing: border-box;">
            </div>
            <div style="margin-bottom: 16px;">
              <label style="display: block; margin-bottom: 6px; color: #94a3b8; font-size: 13px;">Password</label>
              <input type="password" id="signupPassword" required style="width: 100%; padding: 10px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 8px; color: #e2e8f0; font-size: 14px; box-sizing: border-box;">
            </div>
            <div style="margin-bottom: 16px;">
              <label style="display: block; margin-bottom: 6px; color: #94a3b8; font-size: 13px;">Role</label>
              <select id="signupRole" required onchange="toggleMachineSelection()" style="width: 100%; padding: 10px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 8px; color: #e2e8f0; font-size: 14px; box-sizing: border-box; cursor: pointer;">
                <option value="operator">Operator</option>
                <option value="admin">Admin</option>
              </select>
            </div>
            <div id="machineSelection" style="margin-bottom: 16px;">
              <label style="display: block; margin-bottom: 8px; color: #94a3b8; font-size: 13px;">Machine Access (select at least one)</label>
              <div style="display: flex; gap: 12px;">
                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                  <input type="checkbox" value="A" class="machine-checkbox" style="cursor: pointer;">
                  <span style="color: #e2e8f0;">Machine A</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                  <input type="checkbox" value="B" class="machine-checkbox" style="cursor: pointer;">
                  <span style="color: #e2e8f0;">Machine B</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                  <input type="checkbox" value="C" class="machine-checkbox" style="cursor: pointer;">
                  <span style="color: #e2e8f0;">Machine C</span>
                </label>
              </div>
            </div>
            <button type="submit" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #10b981 0%, #059669 100%); border: none; border-radius: 8px; color: white; font-weight: 600; font-size: 14px; cursor: pointer;">Create User</button>
            <div id="signupError" style="margin-top: 12px; color: #f87171; font-size: 13px; text-align: center; display: none;"></div>
            <div id="signupSuccess" style="margin-top: 12px; color: #10b981; font-size: 13px; text-align: center; display: none;"></div>
          </form>
        </div>

      <!-- Machine and Mode Controls -->
      <div class="machine-mode-controls">
        <div class="machine-selector">
          <label>Machine:</label>
          <div class="machine-buttons">
            <button class="machine-btn active" data-machine="A" onclick="selectMachine('A')">Machine A</button>
            <button class="machine-btn" data-machine="B" onclick="selectMachine('B')">Machine B</button>
            <button class="machine-btn" data-machine="C" onclick="selectMachine('C')">Machine C</button>
          </div>
        </div>
        <div class="mode-toggle">
          <label>Mode:</label>
          <div class="mode-buttons">
            <button class="mode-btn active" data-mode="operator" onclick="switchMode('operator')">Operator</button>
            <button class="mode-btn" data-mode="admin" onclick="switchMode('admin')">Admin</button>
          </div>
        </div>
      </div>

      <!-- Admin Panel (hidden by default) -->
      <div class="admin-panel" id="adminPanel">
        <div class="admin-section">
          <h3>âš™ï¸ Sensor Management - Machine <span id="adminMachineLabel">A</span></h3>
          <p class="card-intro" style="margin-bottom: 16px;">
            Enable/disable sensors and set baseline values for the selected machine. Changes apply immediately to Operator Mode.
          </p>
          <div id="adminSensorControls"></div>
        </div>
        
        <div class="admin-section">
          <h3>âž• Custom Sensor Management</h3>
          <p class="card-intro" style="margin-bottom: 16px;">
            Add and manage custom sensor parameters. New sensors will appear in producer messages and dashboard stats.
          </p>
          
          <!-- Add New Sensor Form -->
          <div style="margin-bottom: 24px; padding: 20px; background: rgba(15, 23, 42, 0.6); border-radius: 12px; border: 1px solid rgba(96, 165, 250, 0.2);">
            <h4 style="color: #60a5fa; margin-bottom: 16px; font-size: 14px; text-transform: uppercase; letter-spacing: 1px;">Add New Custom Sensor</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; margin-bottom: 12px;">
              <div>
                <label style="display: block; color: #94a3b8; font-size: 12px; margin-bottom: 6px; text-transform: uppercase;">Sensor Name *</label>
                <input type="text" id="newSensorName" placeholder="e.g., bearing_vibration_rms" 
                       style="width: 100%; padding: 8px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 6px; color: #e2e8f0; font-size: 14px;">
              </div>
              <div>
                <label style="display: block; color: #94a3b8; font-size: 12px; margin-bottom: 6px; text-transform: uppercase;">Category</label>
                <select id="newSensorCategory" 
                        style="width: 100%; padding: 8px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 6px; color: #e2e8f0; font-size: 14px;">
                  <option value="custom">Custom Parameters</option>
                  <option value="environmental">Environmental</option>
                  <option value="mechanical">Mechanical</option>
                  <option value="thermal">Thermal</option>
                  <option value="electrical">Electrical</option>
                  <option value="fluid">Fluid Dynamics</option>
                </select>
              </div>
              <div>
                <label style="display: block; color: #94a3b8; font-size: 12px; margin-bottom: 6px; text-transform: uppercase;">Unit</label>
                <input type="text" id="newSensorUnit" placeholder="e.g., mm/s, Â°F, PSI" 
                       style="width: 100%; padding: 8px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 6px; color: #e2e8f0; font-size: 14px;">
              </div>
              <div>
                <label style="display: block; color: #94a3b8; font-size: 12px; margin-bottom: 6px; text-transform: uppercase;">Min Range *</label>
                <input type="number" step="any" id="newSensorMinRange" placeholder="0.0" 
                       style="width: 100%; padding: 8px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 6px; color: #e2e8f0; font-size: 14px;">
              </div>
              <div>
                <label style="display: block; color: #94a3b8; font-size: 12px; margin-bottom: 6px; text-transform: uppercase;">Max Range *</label>
                <input type="number" step="any" id="newSensorMaxRange" placeholder="100.0" 
                       style="width: 100%; padding: 8px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 6px; color: #e2e8f0; font-size: 14px;">
              </div>
              <div>
                <label style="display: block; color: #94a3b8; font-size: 12px; margin-bottom: 6px; text-transform: uppercase;">Low Threshold</label>
                <input type="number" step="any" id="newSensorLowThreshold" placeholder="Optional" 
                       style="width: 100%; padding: 8px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 6px; color: #e2e8f0; font-size: 14px;">
              </div>
              <div>
                <label style="display: block; color: #94a3b8; font-size: 12px; margin-bottom: 6px; text-transform: uppercase;">High Threshold</label>
                <input type="number" step="any" id="newSensorHighThreshold" placeholder="Optional" 
                       style="width: 100%; padding: 8px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 6px; color: #e2e8f0; font-size: 14px;">
              </div>
            </div>
            <button onclick="addCustomSensor()" 
                    style="padding: 10px 24px; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 14px;">
              âž• Add Custom Sensor
            </button>
            <div id="customSensorMessage" style="margin-top: 12px; font-size: 13px;"></div>
          </div>
          
          <!-- Custom Sensors List -->
          <div>
            <h4 style="color: #60a5fa; margin-bottom: 16px; font-size: 14px; text-transform: uppercase; letter-spacing: 1px;">Existing Custom Sensors</h4>
            <div id="customSensorsList" style="min-height: 100px;">
              <div style="text-align: center; color: #94a3b8; padding: 20px;">Loading custom sensors...</div>
            </div>
          </div>
        </div>
      </div>

      <details class="hero-info" id="onboardingDetails">
        <summary>
          <span>?? New to this dashboard? Click to learn how it works.</span>
          <span class="chevron">â–¼</span>
        </summary>
        <div class="hero-wrapper">
          <div class="hero">
            <div>
              <h3>Quick start steps</h3>
              <p>
                This panel lets you start, stop, and watch an entire demo
                factory pipeline. Follow the three quick steps below and the
                rest of the cards will begin to fill themselves in.
              </p>
              <ul class="step-list">
                <li>
                  <span class="step-number">1</span>
                  <div>
                    <strong>Start the Consumer (Waiter)</strong>
                    <div class="hero-note">
                      It listens for new readings and writes them into
                      PostgreSQL. Start this before anything else.
                    </div>
                  </div>
                </li>
                <li>
                  <span class="step-number">2</span>
                  <div>
                    <strong>Start the Producer (Data maker)</strong>
                    <div class="hero-note">
                      This generates pretend sensor readings and hands them to
                      Kafka so the consumer has something to save.
                    </div>
                  </div>
                </li>
                <li>
                  <span class="step-number">3</span>
                  <div>
                    <strong>Watch the Status, Alerts, and Live Readings</strong>
                    <div class="hero-note">
                      Green dots mean the pieces are healthy. Any alert shows up
                      in plain English so you know what needs attention.
                    </div>
                  </div>
                </li>
              </ul>
              <div class="info-pill">
                âœ³ Need a shortcut? Use the presets in the Configuration card and
                keep this page open to see everything update in real time.
              </div>
            </div>
            <div>
              <h3>What is happening end-to-end?</h3>
              <div class="pipeline-flow" aria-label="Pipeline overview">
                <div class="flow-node">
                  <div class="flow-title">Producer</div>
                  <div class="flow-text">
                    Creates fake machine readings based on the ranges in
                    <code>config.py</code>.
                  </div>
                </div>
                <div class="flow-arrow">â†’</div>
                <div class="flow-node">
                  <div class="flow-title">Kafka</div>
                  <div class="flow-text">
                    Acts like a conveyor belt. Messages queue here until the
                    consumer grabs them.
                  </div>
                </div>
                <div class="flow-arrow">â†’</div>
                <div class="flow-node">
                  <div class="flow-title">Consumer</div>
                  <div class="flow-text">
                    Validates each reading, flags anomalies, and writes
                    everything to the database.
                  </div>
                </div>
                <div class="flow-arrow">â†’</div>
                <div class="flow-node">
                  <div class="flow-title">Database</div>
                  <div class="flow-text">
                    Stores the official record shown in the stats, alerts, and
                    history sections.
                  </div>
                </div>
              </div>
              <h3 style="margin-top: 20px">What the colors mean</h3>
              <div class="legend">
                <div class="legend-item">
                  <span class="status-indicator status-running"></span>
                  Running and healthy
                </div>
                <div class="legend-item">
                  <span class="status-indicator status-stopped"></span>
                  Stopped or not reachable
                </div>
                <div class="legend-item">
                  <span class="status-indicator status-pending"></span>
                  Starting up / waiting on a reply
                </div>
                <div class="legend-item">
                  <span class="status-indicator status-unknown"></span>
                  Not checked yet (refreshing soon)
                </div>
              </div>
              <div class="hero-note" style="margin-top: 16px">
                Tip: If you forget what a section is for, read the short
                description right under each card heading.
              </div>
            </div>
          </div>
        </div>
      </details>

      <div class="grid">
        <!-- Stats Card -->
        <div class="card">
          <h2>ðŸ“Š Statistics</h2>
          <p class="card-intro">
            Shows how many readings have been saved and highlights the latest
            sensor values. If you just started the pipeline, this number will
            ramp up as messages flow through.
          </p>
          <div class="big-stat">
            <div class="big-stat-value" id="totalCount">0</div>
            <div class="big-stat-label">Total Messages</div>
          </div>
          <div class="tabs" id="statsCategoryTabs"></div>
          <div id="statsCategoryContent"></div>
        </div>

        <!-- Control Card -->
        <div class="card">
          <h2>âš™ï¸ Controls</h2>
          <p class="card-intro">
            Think of this as the on/off switchboard. Start the consumer first,
            then the producer. Stop buttons immediately send a shutdown signal
            to each Python process.
          </p>
          <div class="stat">
            <span class="stat-label">
              <span class="status-indicator" id="producerStatus"></span>
              Producer
            </span>
          </div>
          <div class="controls">
            <button class="btn-success" onclick="startComponent('producer')">
              â–¶ Start
            </button>
            <button class="btn-danger" onclick="stopComponent('producer')">
              â¹ Stop
            </button>
          </div>

          <div class="stat" style="margin-top: 20px">
            <span class="stat-label">
              <span class="status-indicator" id="consumerStatus"></span>
              Consumer
            </span>
          </div>
          <div class="controls">
            <button class="btn-success" onclick="startComponent('consumer')">
              â–¶ Start
            </button>
            <button class="btn-danger" onclick="stopComponent('consumer')">
              â¹ Stop
            </button>
          </div>

          <div class="stat" style="margin-top: 20px">
            <span class="stat-label">
              <span class="status-indicator" id="kafkaStatus"></span>
              Kafka Broker
            </span>
            <span class="stat-value" id="kafkaStatusDetails">Checking...</span>
          </div>

          <div class="controls" style="margin-top: 20px">
            <button class="btn-secondary" onclick="exportData()">
              ðŸ—‚ï¸ Export CSV
            </button>
            <button class="btn-warning" onclick="clearData()">
              ðŸ—‘ï¸ Clear All Data
            </button>
          </div>

          <!-- Display Refresh Rate Control -->
          <div style="margin-top: 24px; padding-top: 24px; border-top: 1px solid rgba(148, 163, 184, 0.1);">
            <label style="font-size: 13px; color: #94a3b8; display: block; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 1px; font-weight: 600;">
              Display Refresh Rate
            </label>
            <p style="font-size: 12px; color: #64748b; margin-bottom: 12px; line-height: 1.4;">
              Controls how often the Live Sensor Readings panel updates. Does not affect data collection.
            </p>
            <div style="display: flex; gap: 8px; flex-wrap: wrap;">
              <button class="btn-primary refresh-rate-btn active" data-interval="1000" onclick="setRefreshRate(1000)" style="font-size: 12px; padding: 8px 16px;">
                1s
              </button>
              <button class="btn-primary refresh-rate-btn" data-interval="5000" onclick="setRefreshRate(5000)" style="font-size: 12px; padding: 8px 16px;">
                5s
              </button>
              <button class="btn-primary refresh-rate-btn" data-interval="10000" onclick="setRefreshRate(10000)" style="font-size: 12px; padding: 8px 16px;">
                10s
              </button>
              <button class="btn-primary refresh-rate-btn" data-interval="30000" onclick="setRefreshRate(30000)" style="font-size: 12px; padding: 8px 16px;">
                30s
              </button>
            </div>
          </div>
        </div>

        <!-- Configuration Card -->
        <div class="card">
          <h2>ðŸ”§ Configuration</h2>

          <p class="card-intro">
            Tell the producer how long to run and how often to send readings.
            The dashboard calculates the total messages for you and keeps the
            last update visible below.
          </p>
          <label>Duration</label>
          <div class="input-group">
            <div class="input-wrapper">
              <span class="input-label">Hours</span>
              <input type="number" id="durationHours" min="0" value="0" />
            </div>
            <div class="input-wrapper">
              <span class="input-label">Minutes</span>
              <input
                type="number"
                id="durationMinutes"
                min="0"
                max="59"
                value="0"
              />
            </div>
          </div>

          <label>Interval</label>
          <div class="input-wrapper">
            <span class="input-label">Seconds</span>
            <input type="number" id="intervalSeconds" value="30" />
          </div>

          <div class="controls">
            <button class="btn-primary" onclick="updateConfig()">
              ðŸ’¾ Update Config
            </button>
            <button class="btn-secondary" onclick="resetConfig()">
              ðŸ”„ Reset Defaults
            </button>
          </div>
          <div class="config-meta" id="configMessage">Ready for updates.</div>

          <div class="preset-container">
            <div class="preset-title">âš¡ Quick Presets</div>
            <div class="preset-buttons">
              <button class="btn-primary" onclick="setQuickTest()">
                Quick Test
              </button>
              <button class="btn-primary" onclick="setOneMin()">
                1 Minute
              </button>
              <button class="btn-primary" onclick="setOneHour()">1 Hour</button>
              <button class="btn-primary" onclick="setProduction()">
                24 Hours
              </button>
            </div>
          </div>
        </div>

        <!-- Alerts Card -->
        <div class="card">
          <h2>ðŸš¨ Alerts</h2>
          <p class="card-intro">
            Every anomaly, failure, or manual action is stored here in plain
            English. Use it as the event log when something looks off.
          </p>
          <div class="alert-list" id="alertList">
            <div style="text-align: center; color: #94a3b8; padding: 20px">
              No alerts yet
            </div>
          </div>
        </div>
      </div>

      <!-- LSTM Future Prediction Card -->
      <div class="card" style="margin-bottom: 24px">
        <h2>ðŸ”® LSTM Future Anomaly Prediction</h2>
        <p class="card-intro">
          LSTM Autoencoder analyzes temporal patterns to predict potential future anomalies.
        </p>
        
        <!-- LSTM Status -->
        <div id="lstmStatusContainer" style="margin-bottom: 20px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <span style="font-weight: 600; color: #cbd5e1;">Training Quality</span>
            <span id="lstmQualityPercent" style="font-weight: 600; color: #10b981;">--</span>
          </div>
          <div style="background: #1e293b; border-radius: 8px; height: 24px; overflow: hidden; position: relative;">
            <div id="lstmQualityBar" style="
              height: 100%;
              width: 0%;
              background: linear-gradient(90deg, #ef4444, #f59e0b, #10b981);
              transition: width 0.5s ease, background 0.5s ease;
              border-radius: 8px;
            "></div>
            <div style="
              position: absolute;
              top: 0;
              left: 0;
              right: 0;
              bottom: 0;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 12px;
              font-weight: 600;
              color: white;
              text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            " id="lstmQualityText">Loading...</div>
          </div>
          <div id="lstmStatusMessage" style="margin-top: 8px; font-size: 13px; color: #94a3b8; text-align: center;">
            Checking LSTM status...
          </div>
        </div>

        <!-- Current Prediction -->
        <div id="lstmPredictionContainer" style="
          background: linear-gradient(135deg, #1e293b, #0f172a);
          border: 1px solid #334155;
          border-radius: 12px;
          padding: 20px;
          margin-bottom: 16px;
        ">
          <h3 style="margin: 0 0 16px 0; color: #e2e8f0; font-size: 16px;">Current Risk Assessment</h3>
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
            <div>
              <div style="font-size: 12px; color: #94a3b8; margin-bottom: 4px;">Risk Score</div>
              <div id="lstmRiskScore" style="font-size: 24px; font-weight: 700; color: #10b981;">--</div>
            </div>
            <div>
              <div style="font-size: 12px; color: #94a3b8; margin-bottom: 4px;">Confidence</div>
              <div id="lstmConfidence" style="font-size: 24px; font-weight: 700; color: #3b82f6;">--</div>
            </div>
          </div>

          <div style="margin-bottom: 12px;">
            <div style="font-size: 12px; color: #94a3b8; margin-bottom: 4px;">Predicted Window</div>
            <div id="lstmPredictedWindow" style="font-size: 14px; color: #e2e8f0; font-weight: 500;">--</div>
          </div>

          <div style="margin-bottom: 12px;">
            <div style="font-size: 12px; color: #94a3b8; margin-bottom: 4px;">Trend</div>
            <div id="lstmTrend" style="font-size: 14px; color: #e2e8f0; font-weight: 500;">--</div>
          </div>

          <div>
            <div style="font-size: 12px; color: #94a3b8; margin-bottom: 4px;">Contributing Sensors</div>
            <div id="lstmSensors" style="font-size: 13px; color: #cbd5e1;">--</div>
          </div>
        </div>

        <!-- Problematic Sensors Analysis -->
        <div id="lstmSensorAnalysisContainer" style="
          background: linear-gradient(135deg, #1e293b, #0f172a);
          border: 1px solid #334155;
          border-radius: 12px;
          padding: 20px;
          margin-bottom: 16px;
          display: none;
        ">
          <h3 style="margin: 0 0 16px 0; color: #e2e8f0; font-size: 16px;">ðŸ” Problematic Sensors Analysis</h3>
          <p style="margin: 0 0 16px 0; font-size: 13px; color: #94a3b8;">
            Sensors that are trending toward problems and why:
          </p>
          <div id="lstmSensorAnalysisList" style="display: flex; flex-direction: column; gap: 12px;">
            <!-- Sensor analysis items will be inserted here -->
          </div>
        </div>

        <!-- Generate Future Report Button -->
        <button
          id="generateFutureReportBtn"
          onclick="generateFutureReport(this)"
          style="
            width: 100%;
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            color: white;
            border: none;
            padding: 14px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 15px;
          "
        >
          <span>ðŸ“Š</span>
          <span>Generate Future Anomaly Report (PDF)</span>
        </button>
      </div>

      <!-- ML Anomaly Detection Card -->
      <div class="card" style="margin-bottom: 24px">
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
          "
        >
          <h2 style="margin: 0">ðŸ¤– ML Anomaly Detection</h2>
          <button
            id="fullReportBtn"
            onclick="generateFullSessionReport(this)"
            style="
              background: linear-gradient(135deg, #10b981, #059669);
              color: white;
              border: none;
              padding: 12px 24px;
              border-radius: 8px;
              font-weight: 600;
              cursor: pointer;
              display: flex;
              align-items: center;
              gap: 8px;
              box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
              transition: all 0.3s ease;
            "
          >
            ðŸ“Š Generate Full Session Report
          </button>
        </div>
        <p class="card-intro">
          Isolation Forest model detects unusual patterns across all 50 sensor
          parameters. Click "Generate Report" for individual analysis, or "Full
          Session Report" for comprehensive analysis of ALL anomalies.
        </p>

        <!-- ML Stats -->
        <div
          style="
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 16px;
            margin-bottom: 20px;
          "
        >
          <div class="big-stat" style="padding: 20px">
            <div
              class="big-stat-value"
              id="mlTotalAnomalies"
              style="font-size: 36px"
            >
              0
            </div>
            <div class="big-stat-label">Anomalies Detected</div>
          </div>
          <div class="big-stat" style="padding: 20px">
            <div
              class="big-stat-value"
              id="mlAnomalyRate"
              style="font-size: 36px"
            >
              0%
            </div>
            <div class="big-stat-label">Recent Rate</div>
          </div>
          <div class="big-stat" style="padding: 20px">
            <div
              class="big-stat-value"
              id="mlReportsGenerated"
              style="font-size: 36px"
            >
              0
            </div>
            <div class="big-stat-label">Reports Generated</div>
          </div>
        </div>

        <!-- Anomaly List -->
        <div
          class="anomaly-list"
          id="anomalyList"
          style="max-height: 400px; overflow-y: auto"
        >
          <div style="text-align: center; color: #94a3b8; padding: 40px">
            No ML anomalies detected yet. Start the pipeline to begin
            monitoring.
          </div>
        </div>

        <!-- Anomaly Injection Controls -->
        <div
          style="
            margin-top: 24px;
            padding: 20px;
            background: rgba(239, 68, 68, 0.1);
            border-radius: 12px;
            border: 1px solid rgba(239, 68, 68, 0.3);
          "
        >
          <h3 style="margin: 0 0 16px 0; color: #f87171; font-size: 16px">
            ðŸŽ¯ Anomaly Injection Controls
          </h3>
          <p style="font-size: 13px; color: #94a3b8; margin-bottom: 16px">
            Control when anomalies are injected into the sensor data stream. Set
            custom thresholds above, then schedule anomaly injections here.
          </p>

          <div
            style="
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
              gap: 16px;
            "
          >
            <!-- Enable/Disable -->
            <div
              style="
                background: rgba(15, 23, 42, 0.6);
                padding: 16px;
                border-radius: 8px;
              "
            >
              <label
                style="
                  display: flex;
                  align-items: center;
                  gap: 10px;
                  cursor: pointer;
                "
              >
                <input
                  type="checkbox"
                  id="injectionEnabled"
                  onchange="toggleInjection()"
                  style="width: 20px; height: 20px; cursor: pointer"
                />
                <span style="font-size: 14px; color: #e2e8f0"
                  >Enable Scheduled Anomalies</span
                >
              </label>
            </div>

            <!-- Interval Setting -->
            <div
              style="
                background: rgba(15, 23, 42, 0.6);
                padding: 16px;
                border-radius: 8px;
              "
            >
              <label
                style="
                  font-size: 12px;
                  color: #94a3b8;
                  display: block;
                  margin-bottom: 8px;
                "
                >Inject Anomaly Every</label
              >
              <div style="display: flex; align-items: center; gap: 8px">
                <input
                  type="number"
                  id="injectionInterval"
                  value="30"
                  min="1"
                  max="1440"
                  style="
                    width: 80px;
                    padding: 8px;
                    background: rgba(15, 23, 42, 0.8);
                    border: 1px solid rgba(148, 163, 184, 0.3);
                    border-radius: 6px;
                    color: #e2e8f0;
                    font-size: 14px;
                    text-align: center;
                  "
                />
                <span style="color: #94a3b8">minutes</span>
                <button
                  onclick="updateInjectionInterval()"
                  style="
                    background: #3b82f6;
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 6px;
                    font-size: 12px;
                    cursor: pointer;
                  "
                >
                  Set
                </button>
              </div>
            </div>

            <!-- Inject Now Button -->
            <div
              style="
                background: rgba(15, 23, 42, 0.6);
                padding: 16px;
                border-radius: 8px;
              "
            >
              <label
                style="
                  font-size: 12px;
                  color: #94a3b8;
                  display: block;
                  margin-bottom: 8px;
                "
                >Manual Trigger</label
              >
              <button
                id="injectNowBtn"
                onclick="injectAnomalyNow(this)"
                style="
                  background: linear-gradient(135deg, #ef4444, #dc2626);
                  color: white;
                  border: none;
                  padding: 12px 24px;
                  border-radius: 8px;
                  font-weight: 600;
                  cursor: pointer;
                  width: 100%;
                  font-size: 14px;
                "
              >
                âš¡ Inject Anomaly NOW
              </button>
            </div>
          </div>

          <!-- Status -->
          <div
            id="injectionStatus"
            style="
              margin-top: 16px;
              padding: 12px;
              background: rgba(15, 23, 42, 0.4);
              border-radius: 8px;
              font-size: 13px;
              color: #64748b;
            "
          >
            Injection disabled. Enable to schedule automatic anomalies.
          </div>
        </div>
      </div>

      <!-- Report Modal (Individual Anomaly) -->
      <div id="reportModal" class="modal" style="display: none">
        <div class="modal-content">
          <div class="modal-header">
            <h2>ðŸ“‹ Anomaly Analysis Report</h2>
            <div style="display: flex; gap: 12px; align-items: center;">
              <button 
                id="downloadReportBtn" 
                class="btn-download-report" 
                onclick="downloadCurrentReport()"
                style="display: none;"
              >
                ðŸ“¥ Download
              </button>
              <button class="modal-close" onclick="closeReportModal()">
                &times;
              </button>
            </div>
          </div>
          <div class="modal-body" id="reportContent">Loading...</div>
        </div>
      </div>

      <!-- Full Session Report Modal -->
      <div id="fullReportModal" class="modal" style="display: none">
        <div class="modal-content" style="max-width: 1000px; max-height: 90vh">
          <div
            class="modal-header"
            style="background: linear-gradient(135deg, #10b981, #059669)"
          >
            <h2 style="color: white">ðŸ“Š Full Session Analysis Report</h2>
            <button
              class="modal-close"
              onclick="closeFullReportModal()"
              style="color: white"
            >
              &times;
            </button>
          </div>
          <div
            class="modal-body"
            id="fullReportContent"
            style="overflow-y: auto; max-height: calc(90vh - 80px)"
          >
            <div style="text-align: center; padding: 60px">
              <div
                class="loading-spinner"
                style="width: 48px; height: 48px; margin: 0 auto 20px"
              ></div>
              <p style="color: #94a3b8; font-size: 16px">
                Analyzing all anomalies with AI...
              </p>
              <p style="color: #64748b; font-size: 14px">
                This may take a minute for comprehensive analysis.
              </p>
            </div>
          </div>
        </div>
      </div>

      <!-- 50 Parameters by Category -->
      <div class="card">
        <h2>ðŸŽ¯ All Sensor Parameters (50)</h2>
        <p class="card-intro">
          Grouped by category so you can see how the 50 different readings are
          trending without memorizing names. Toggle categories to focus on the
          ones you care about.
        </p>
        <div class="tabs" id="categoryTabs"></div>
        <div id="categoryContent"></div>
      </div>

      <!-- Readings History Card -->
      <div class="card">
        <h2>ðŸ“¡ Live Sensor Readings</h2>
        <p class="card-intro">
          A rolling timeline of raw values pulled straight from the database.
          Pick a category and skim the cards to spot jumps or dips.
        </p>
        <label>Select Category to Monitor</label>
        <select
          id="historyCategory"
          onchange="changeHistoryCategory()"
          style="
            width: 100%;
            padding: 14px;
            border-radius: 12px;
            background: rgba(15, 23, 42, 0.6);
            color: #e2e8f0;
            border: 1px solid rgba(148, 163, 184, 0.2);
            font-size: 15px;
            font-weight: 600;
            margin-bottom: 20px;
            cursor: pointer;
          "
        >
          <option value="environmental">ðŸŒ Environmental Sensors</option>
          <option value="mechanical">âš™ï¸ Mechanical Sensors</option>
          <option value="thermal">ðŸ”¥ Thermal Sensors</option>
          <option value="electrical">âš¡ Electrical Sensors</option>
          <option value="fluid">ðŸ’§ Fluid Dynamics Sensors</option>
        </select>
        <div class="history-container" id="readingsHistory"></div>
      </div>
    </div>

    <script>
      // ========== Authentication State ==========
      let currentUser = null;
      let accessibleMachines = [];

      // Check authentication on page load
      async function checkAuth() {
        try {
          const response = await fetch('/api/auth/me');
          if (response.ok) {
            const data = await response.json();
            if (data.success) {
              currentUser = data.user;
              accessibleMachines = data.user.accessible_machines || [];
              showDashboard();
              filterMachineSelector();
              updateUserInfo();
              if (currentUser.role === 'admin') {
                // Hide mode toggle for admins (they only see admin panel)
                const modeToggle = document.querySelector('.mode-toggle');
                if (modeToggle) {
                  modeToggle.style.display = 'none';
                }
                // Auto-switch to admin mode for admins (permanent admin mode)
                switchMode('admin');
              } else {
                // Hide admin panel and mode toggle for operators
                document.getElementById('adminPanel').style.display = 'none';
                const modeToggle = document.querySelector('.mode-toggle');
                if (modeToggle) {
                  modeToggle.style.display = 'none';
                }
                // Ensure operator mode is active
                switchMode('operator');
              }
              return;
            }
          }
        } catch (e) {
          console.error('Auth check failed:', e);
        }
        showLogin();
      }

      function showLogin() {
        document.getElementById('loginForm').style.display = 'block';
        document.getElementById('mainDashboard').style.display = 'none';
        showLoginForm(); // Show login form by default
      }

      function showLoginForm() {
        document.getElementById('loginFormContent').style.display = 'block';
        document.getElementById('signupFormContent').style.display = 'none';
        const loginBtn = document.getElementById('showLoginBtn');
        const signupBtn = document.getElementById('showSignupBtnAuth');
        if (loginBtn) {
          loginBtn.style.background = 'linear-gradient(135deg, #60a5fa 0%, #a78bfa 100%)';
          loginBtn.style.color = 'white';
        }
        if (signupBtn) {
          signupBtn.style.background = 'rgba(15, 23, 42, 0.6)';
          signupBtn.style.color = '#94a3b8';
        }
      }

      function showSignupFormAuth() {
        document.getElementById('loginFormContent').style.display = 'none';
        document.getElementById('signupFormContent').style.display = 'block';
        const loginBtn = document.getElementById('showLoginBtn');
        const signupBtn = document.getElementById('showSignupBtnAuth');
        if (signupBtn) {
          signupBtn.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
          signupBtn.style.color = 'white';
        }
        if (loginBtn) {
          loginBtn.style.background = 'rgba(15, 23, 42, 0.6)';
          loginBtn.style.color = '#94a3b8';
        }
        toggleMachineSelectionAuth();
      }

      function toggleMachineSelectionAuth() {
        const adminToggle = document.getElementById('signupAdminToggle');
        const machineSelection = document.getElementById('machineSelectionAuth');
        if (adminToggle && machineSelection) {
          if (adminToggle.checked) {
            machineSelection.style.display = 'none';
          } else {
            machineSelection.style.display = 'block';
          }
        }
      }

      function showDashboard() {
        document.getElementById('loginForm').style.display = 'none';
        document.getElementById('mainDashboard').style.display = 'block';
      }

      async function handleLogin(event) {
        event.preventDefault();
        const username = document.getElementById('loginUsername').value;
        const password = document.getElementById('loginPassword').value;
        const errorDiv = document.getElementById('loginError');

        try {
          const response = await fetch('/api/auth/login', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username, password })
          });

          const data = await response.json();
          if (data.success) {
            currentUser = data.user;
            accessibleMachines = data.user.accessible_machines || [];
            showDashboard();
            filterMachineSelector();
            updateUserInfo();
            if (currentUser.role === 'admin') {
              // Hide mode toggle for admins (they only see admin panel)
              const modeToggle = document.querySelector('.mode-toggle');
              if (modeToggle) {
                modeToggle.style.display = 'none';
              }
              // Auto-switch to admin mode for admins (permanent admin mode)
              switchMode('admin');
            } else {
              // Hide admin panel and mode toggle for operators
              document.getElementById('adminPanel').style.display = 'none';
              const modeToggle = document.querySelector('.mode-toggle');
              if (modeToggle) {
                modeToggle.style.display = 'none';
              }
              document.getElementById('signupForm').style.display = 'none';
              // Ensure operator mode is active
              switchMode('operator');
            }
            errorDiv.style.display = 'none';
            // Select first accessible machine
            if (accessibleMachines.length > 0) {
              selectMachine(accessibleMachines[0]);
            }
          } else {
            errorDiv.textContent = data.error || 'Login failed';
            errorDiv.style.display = 'block';
          }
        } catch (e) {
          errorDiv.textContent = 'Network error. Please try again.';
          errorDiv.style.display = 'block';
        }
      }

      async function handleSignupAuth(event) {
        event.preventDefault();
        const username = document.getElementById('signupUsernameAuth').value;
        const password = document.getElementById('signupPasswordAuth').value;
        const isAdmin = document.getElementById('signupAdminToggle').checked;
        const errorDiv = document.getElementById('signupErrorAuth');
        const successDiv = document.getElementById('signupSuccessAuth');
        
        errorDiv.style.display = 'none';
        successDiv.style.display = 'none';

        const role = isAdmin ? 'admin' : 'operator';
        let machine_ids = [];
        
        if (!isAdmin) {
          const checkboxes = document.querySelectorAll('.machine-checkbox-auth:checked');
          machine_ids = Array.from(checkboxes).map(cb => cb.value);
          
          if (machine_ids.length === 0) {
            errorDiv.textContent = 'Operator users must have at least one machine assigned';
            errorDiv.style.display = 'block';
            return;
          }
        }

        try {
          const response = await fetch('/api/auth/signup', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username, password, role, machine_ids })
          });

          const data = await response.json();
          if (data.success) {
            successDiv.textContent = `User "${username}" created! You can now login.`;
            successDiv.style.display = 'block';
            // Reset form
            document.getElementById('signupFormElementAuth').reset();
            toggleMachineSelectionAuth();
            // Switch to login after 2 seconds
            setTimeout(() => {
              showLoginForm();
            }, 2000);
          } else {
            errorDiv.textContent = data.error || 'Failed to create user';
            errorDiv.style.display = 'block';
          }
        } catch (e) {
          errorDiv.textContent = 'Network error. Please try again.';
          errorDiv.style.display = 'block';
        }
      }

      async function handleLogout() {
        try {
          await fetch('/api/auth/logout', { method: 'POST' });
        } catch (e) {
          console.error('Logout error:', e);
        }
        currentUser = null;
        accessibleMachines = [];
        showLogin();
      }

      function updateUserInfo() {
        if (currentUser) {
          const roleText = currentUser.role === 'admin' ? 'Admin' : 'Operator';
          document.getElementById('userInfo').textContent = 
            `Logged in as ${currentUser.username} (${roleText})`;
        }
      }

      function filterMachineSelector() {
        const machineButtons = document.querySelectorAll('.machine-btn');
        machineButtons.forEach(btn => {
          const machineId = btn.dataset.machine;
          if (accessibleMachines.includes(machineId)) {
            btn.style.display = 'inline-block';
          } else {
            btn.style.display = 'none';
          }
        });
        // Select first accessible machine if current selection is not accessible
        if (!accessibleMachines.includes(selectedMachineId) && accessibleMachines.length > 0) {
          selectMachine(accessibleMachines[0]);
        }
      }

      // Check auth on page load
      checkAuth();

      // ========== Machine and Mode State Management ==========
      let selectedMachineId = 'A';
      let currentMode = 'operator';
      let selectedAdminCategory = 'environmental'; // For 3-pane admin UI
      
      // Per-machine sensor state: { machineId: { sensorName: { enabled: bool, baseline: number } } }
      let machineSensorState = {
        'A': {},
        'B': {},
        'C': {}
      };

      // Per-machine parameter configuration (in-memory only, resets on refresh)
      // Tracks sensor order and enabled/disabled state for admin configuration
      let machineParameterConfig = {
        'A': { sensorOrder: [], enabledSensors: new Set() },
        'B': { sensorOrder: [], enabledSensors: new Set() },
        'C': { sensorOrder: [], enabledSensors: new Set() }
      };

      // ========== Per-Machine Data Isolation ==========
      // TRUE machine-scoped data storage - each machine has its own independent data
      let machineData = {
        'A': {
          statsData: null,         // Full stats response for this machine
          recentReadings: [],      // Live sensor readings history (append-only)
          alerts: [],              // Alerts for this machine
          anomalies: [],           // ML anomalies for this machine
          mlStats: { totalAnomalies: 0, anomalyRate: 0, reportsGenerated: 0 },
          lstmPredictions: null,   // LSTM predictions for this machine
          totalCount: 0,           // Total message count for this machine
          sensorSums: {},          // Per-sensor sum accumulator for averages
          sensorCounts: {}         // Per-sensor count accumulator for averages
        },
        'B': {
          statsData: null,
          recentReadings: [],
          alerts: [],
          anomalies: [],
          mlStats: { totalAnomalies: 0, anomalyRate: 0, reportsGenerated: 0 },
          lstmPredictions: null,
          totalCount: 0,
          sensorSums: {},
          sensorCounts: {}
        },
        'C': {
          statsData: null,
          recentReadings: [],
          alerts: [],
          anomalies: [],
          mlStats: { totalAnomalies: 0, anomalyRate: 0, reportsGenerated: 0 },
          lstmPredictions: null,
          totalCount: 0,
          sensorSums: {},
          sensorCounts: {}
        }
      };

      // Get the data for the currently selected machine
      function getCurrentMachineData() {
        return machineData[selectedMachineId];
      }

      // ========== Producer + Machine Running State ==========
      // Global producer running state (synced with backend)
      let producerRunning = false;

      // Per-machine running state
      let machineRunning = {
        'A': false,
        'B': false,
        'C': false
      };

      // GUARD: Check if data collection is allowed for current machine
      // Data may ONLY be appended if: producerRunning === true AND machineRunning[selectedMachine] === true
      function canCollectData() {
        return producerRunning === true && machineRunning[selectedMachineId] === true;
      }

      // Reset all machine data buffers
      function resetMachineData(machineId) {
        machineData[machineId] = {
          statsData: null,
          recentReadings: [],
          alerts: [],
          anomalies: [],
          mlStats: { totalAnomalies: 0, anomalyRate: 0, reportsGenerated: 0 },
          lstmPredictions: null,
          totalCount: 0,
          sensorSums: {},
          sensorCounts: {}
        };
      }

      // Reset ALL machine data
      function resetAllMachineData() {
        ['A', 'B', 'C'].forEach(id => resetMachineData(id));
      }

      // Get machine-specific average for a sensor
      function getMachineAverage(machineId, sensorName) {
        const machine = machineData[machineId];
        const sum = machine.sensorSums[sensorName] || 0;
        const count = machine.sensorCounts[sensorName] || 0;
        if (count === 0) return null;
        return sum / count;
      }

      // Get current machine's average for a sensor
      function getCurrentMachineAverage(sensorName) {
        return getMachineAverage(selectedMachineId, sensorName);
      }

      // Initialize all sensors as enabled with no baseline override
      function initializeMachineState() {
        // Get all sensors from sensorsByCategory (defined later, but will be available when called)
        if (typeof sensorsByCategory !== 'undefined') {
          const allSensors = Object.keys(sensorsByCategory).flatMap(cat => sensorsByCategory[cat]);
          ['A', 'B', 'C'].forEach(machineId => {
            allSensors.forEach(sensor => {
              if (!machineSensorState[machineId][sensor]) {
                machineSensorState[machineId][sensor] = {
                  enabled: true,
                  baseline: null
                };
              }
            });

            // Initialize machineParameterConfig with sensor order and all enabled
            machineParameterConfig[machineId] = {
              sensorOrder: [...allSensors],
              enabledSensors: new Set(allSensors)
            };
          });
        }
      }
      
      function selectMachine(machineId) {
        selectedMachineId = machineId;
        document.querySelectorAll('.machine-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.machine === machineId);
        });
        document.getElementById('adminMachineLabel').textContent = machineId;

        // Load machine-specific custom sensor state when switching machines
        const customSensors = Object.values(unifiedSensorRegistry).filter(s => s.source === 'custom');
        if (customSensors.length > 0) {
          loadMachineCustomSensorState(machineId, customSensors.map(s => ({ sensor_name: s.name })));
        }

        // Render admin panel with new sortable list if in admin mode
        if (currentMode === 'admin') {
          renderAdminSensorList();
        }

        // ========== SYNC MACHINE RUNNING STATE ON SWITCH ==========
        // If producer is running, enable data collection for this machine
        if (producerRunning) {
          machineRunning[machineId] = true;
        }

        // ========== MACHINE DATA ISOLATION ==========
        // Immediately render from cached data for this machine (instant UI update)
        renderFromMachineCache(machineId);

        // Then fetch fresh data (which will also update the cache)
        updateStats();
        loadAlerts();
        loadMLStats();
        loadAnomalies();
        loadLSTMPredictions();
      }

      // Render UI from machine-specific cache (instant switch)
      function renderFromMachineCache(machineId) {
        const machine = machineData[machineId];

        // Render total count from cache
        document.getElementById("totalCount").textContent = machine.totalCount;

        // Render alerts from cache
        const alertContainer = document.getElementById("alertList");
        if (alertContainer) {
          if (machine.alerts.length === 0) {
            alertContainer.innerHTML = `<div style="text-align: center; color: #94a3b8; padding: 20px;">No alerts for Machine ${machineId} yet</div>`;
          } else {
            alertContainer.innerHTML = machine.alerts.map((alert) => {
              const severity = (alert.severity || "info").toLowerCase();
              return `
                <div class="alert-item">
                  <div>
                    <div class="alert-type">${alert.alert_type}</div>
                    <div class="alert-message">${alert.message}</div>
                  </div>
                  <div class="alert-meta">
                    <span class="alert-badge ${severity}">${alert.severity}</span>
                    <div class="alert-time">${formatDateTime(alert.created_at)}</div>
                  </div>
                </div>
              `;
            }).join("");
          }
        }

        // Render anomalies from cache
        const anomalyContainer = document.getElementById("anomalyList");
        if (anomalyContainer) {
          if (machine.anomalies.length === 0) {
            anomalyContainer.innerHTML = `
              <div style="text-align: center; color: #94a3b8; padding: 40px;">
                No ML anomalies detected for Machine ${machineId} yet. Start the pipeline to begin monitoring.
              </div>
            `;
          } else {
            anomalyContainer.innerHTML = machine.anomalies.map((anomaly) => {
              const sensors = filterSensorsArray(anomaly.detected_sensors || []);
              const sensorTags = sensors.slice(0, 5).map((s) => `<span>${s.replace(/_/g, " ")}</span>`).join("");
              const moreSensors = sensors.length > 5 ? `<span>+${sensors.length - 5} more</span>` : "";
              let actionBtn = "";
              if (anomaly.report_id && anomaly.report_status === "completed") {
                actionBtn = `<button class="btn-report btn-view-report" onclick="viewReport(${anomaly.report_id})">ðŸ“„ View Report</button>`;
              } else if (anomaly.report_status === "generating") {
                actionBtn = `<button class="btn-report" disabled><span class="loading-spinner"></span> Generating...</button>`;
              } else {
                actionBtn = `<button class="btn-report" onclick="generateReport(${anomaly.id}, this)">ðŸ¤– Generate Report</button>`;
              }
              return `
                <div class="anomaly-item">
                  <div class="anomaly-info">
                    <div class="anomaly-header">
                      <span class="anomaly-score">Score: ${anomaly.anomaly_score.toFixed(4)}</span>
                      <span class="anomaly-method">${anomaly.detection_method}</span>
                    </div>
                    <div class="anomaly-timestamp">${formatDateTime(anomaly.created_at)}</div>
                    <div class="anomaly-sensors">
                      <strong>Contributing sensors:</strong><br>
                      ${sensorTags}${moreSensors}
                    </div>
                  </div>
                  <div class="anomaly-actions">${actionBtn}</div>
                </div>
              `;
            }).join("");
          }
        }

        // Render ML stats from cache
        document.getElementById("mlTotalAnomalies").textContent = machine.mlStats.totalAnomalies;
        document.getElementById("mlAnomalyRate").textContent = machine.mlStats.anomalyRate.toFixed(1) + "%";
        document.getElementById("mlReportsGenerated").textContent = machine.mlStats.reportsGenerated;

        // Render live readings from cache - FULL RENDER from machine buffer
        const readingsContainer = document.getElementById("readingsHistory");
        if (readingsContainer) {
          const machineReadings = machine.recentReadings;
          if (machineReadings.length === 0) {
            readingsContainer.innerHTML = `<div style="text-align: center; color: #94a3b8; padding: 40px; font-size: 14px; text-transform: uppercase; letter-spacing: 2px;">No data yet for Machine ${machineId}</div>`;
          } else {
            const allSensors = sensorsByCategory[selectedHistoryCategory] || [];
            const currentState = machineSensorState[machineId];
            // Filter out hidden sensors AND disabled sensors for current machine
            const sensors = allSensors.filter(sensor => {
              return !hiddenSensors.has(sensor) &&
                     (currentState[sensor]?.enabled !== false);
            });

            const historyHTML = machineReadings.map((reading) => {
              const metricsHtml = sensors.map((sensor) => {
                const displayName = sensor.replace(/_/g, " ").toUpperCase();
                const value = reading[sensor];
                return `
                  <div class="history-metric">
                    <div class="metric-value">${formatNumber(value)}</div>
                    <div class="metric-label">${displayName}</div>
                  </div>
                `;
              }).join("");

              return `
                <div class="history-item">
                  <div class="history-timestamp">${formatDateTime(reading.created_at)}</div>
                  <div class="history-grid">${metricsHtml}</div>
                </div>
              `;
            }).join("");
            readingsContainer.innerHTML = historyHTML;
          }
        }
      }
      
      function switchMode(mode) {
        // Only allow admin mode if user is admin
        if (mode === 'admin' && (!currentUser || currentUser.role !== 'admin')) {
          return;
        }
        currentMode = mode;
        document.querySelectorAll('.mode-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.mode === mode);
        });
        const adminPanel = document.getElementById('adminPanel');
        if (mode === 'admin') {
          adminPanel.classList.add('active');
          // Use new sortable admin sensor list
          renderAdminSensorList();
          // Load custom sensors
          loadCustomSensors();
        } else {
          adminPanel.classList.remove('active');
          // Refresh operator dashboard when switching back
          refreshOperatorDashboard();
        }
      }
      
      function updateAdminPanel() {
        const container = document.getElementById('adminSensorControls');
        if (!container) return;
        
        const allSensors = Object.keys(sensorsByCategory).flatMap(cat => 
          sensorsByCategory[cat].map(sensor => ({ name: sensor, category: cat }))
        );
        
        const currentState = machineSensorState[selectedMachineId];
        
        let html = '<div class="sensor-control-grid">';
        allSensors.forEach(({ name, category }) => {
          const state = currentState[name] || { enabled: true, baseline: null };
          const displayName = name.replace(/_/g, ' ').toUpperCase();
          html += `
            <div class="sensor-control-item ${!state.enabled ? 'disabled' : ''}">
              <div class="sensor-control-name">${displayName}</div>
              <div class="sensor-control-actions">
                <input type="number" 
                       class="baseline-input" 
                       placeholder="Baseline" 
                       value="${state.baseline || ''}"
                       onchange="updateBaseline('${name}', this.value)"
                       ${!state.enabled ? 'disabled' : ''}>
                <label class="toggle-switch">
                  <input type="checkbox" 
                         ${state.enabled ? 'checked' : ''} 
                         onchange="toggleSensorEnabled('${name}', this.checked)">
                  <span class="toggle-slider"></span>
                </label>
              </div>
            </div>
          `;
        });
        html += '</div>';
        container.innerHTML = html;
      }
      
      function toggleSensorEnabled(sensorName, enabled) {
        if (!machineSensorState[selectedMachineId][sensorName]) {
          machineSensorState[selectedMachineId][sensorName] = { enabled: true, baseline: null };
        }
        machineSensorState[selectedMachineId][sensorName].enabled = enabled;
        updateAdminPanel();
        updateStats(); // Refresh display
      }
      
      function updateBaseline(sensorName, value) {
        if (!machineSensorState[selectedMachineId][sensorName]) {
          machineSensorState[selectedMachineId][sensorName] = { enabled: true, baseline: null };
        }
        machineSensorState[selectedMachineId][sensorName].baseline = value ? parseFloat(value) : null;
        updateStats(); // Refresh display
      }
      
      // Helper: Check if a sensor is enabled for the selected machine
      function isSensorEnabled(sensorName) {
        const currentState = machineSensorState[selectedMachineId];
        const sensorState = currentState[sensorName];
        return !sensorState || sensorState.enabled !== false;
      }
      
      // Helper: Get all enabled sensors for the selected machine
      function getEnabledSensors() {
        const currentState = machineSensorState[selectedMachineId];
        const allSensors = Object.keys(sensorsByCategory).flatMap(cat => sensorsByCategory[cat]);
        return allSensors.filter(sensor => isSensorEnabled(sensor));
      }
      
      // Helper: Check if an anomaly involves any enabled sensors
      function anomalyInvolvesEnabledSensors(anomaly) {
        const detectedSensors = anomaly.detected_sensors || [];
        return detectedSensors.some(sensor => isSensorEnabled(sensor));
      }
      
      // Helper: Filter sensors array to only enabled ones
      function filterSensorsArray(sensors) {
        return sensors.filter(sensor => isSensorEnabled(sensor));
      }

      // ========== Admin Sensor List (Drag-and-Drop Sortable) ==========

      // Get category for a sensor name
      function getSensorCategory(sensorName) {
        // Check unified registry first
        if (unifiedSensorRegistry[sensorName]) {
          return unifiedSensorRegistry[sensorName].category || 'custom';
        }
        // Fallback to sensorsByCategory (for backward compatibility)
        for (const [cat, sensors] of Object.entries(sensorsByCategory)) {
          if (sensors.includes(sensorName)) return cat;
        }
        return 'custom'; // Default to 'custom' instead of 'unknown'
      }

      // Get sensor metadata from unified registry
      function getSensorMetadata(sensorName) {
        return unifiedSensorRegistry[sensorName] || {
          name: sensorName,
          category: 'custom',
          unit: '',
          source: 'unknown',
          enabled: true
        };
      }

      // Format sensor name for display (underscores to spaces, capitalize words)
      function formatSensorName(sensorName) {
        return sensorName
          .replace(/_/g, ' ')
          .replace(/\b\w/g, c => c.toUpperCase());
      }

      // Category icons for admin panel
      const adminCategoryIcons = {
        environmental: 'ðŸŒ',
        mechanical: 'âš™ï¸',
        thermal: 'ðŸ”¥',
        electrical: 'âš¡',
        fluid: 'ðŸ’§',
        custom: 'âž•'
      };

      // Select admin category
      function selectAdminCategory(category) {
        selectedAdminCategory = category;
        renderAdminSensorList();
      }

      // Render the admin sensor list with 3-pane layout
      function renderAdminSensorList() {
        const container = document.getElementById('adminSensorControls');
        if (!container) return;

        const config = machineParameterConfig[selectedMachineId];
        if (!config || !config.sensorOrder || config.sensorOrder.length === 0) {
          // Config not initialized yet, fall back to updateAdminPanel
          updateAdminPanel();
          return;
        }

        // Get sensors for selected category (enabled, in order)
        const categorySensors = config.sensorOrder.filter(s =>
          getSensorCategory(s) === selectedAdminCategory && config.enabledSensors.has(s)
        );

        // Get all disabled sensors (from all categories)
        const disabledSensors = config.sensorOrder.filter(s => !config.enabledSensors.has(s));

        // Count enabled sensors per category
        const categoryCounts = {};
        Object.keys(sensorsByCategory).forEach(cat => {
          categoryCounts[cat] = config.sensorOrder.filter(s =>
            getSensorCategory(s) === cat && config.enabledSensors.has(s)
          ).length;
        });

        // Build 3-pane HTML
        let html = '<div class="admin-3pane">';

        // Left Pane: Category Selector
        html += `
          <div class="admin-pane">
            <div class="admin-pane-header">Categories</div>
            <div class="category-list">
        `;
        Object.keys(sensorsByCategory).forEach(cat => {
          const icon = adminCategoryIcons[cat] || 'ðŸ“Š';
          const isActive = cat === selectedAdminCategory ? 'active' : '';
          const displayName = cat.charAt(0).toUpperCase() + cat.slice(1);
          html += `
            <div class="category-item ${isActive}" onclick="selectAdminCategory('${cat}')">
              <span class="category-icon">${icon}</span>
              <span>${displayName}</span>
              <span class="category-count">${categoryCounts[cat]}</span>
            </div>
          `;
        });
        html += '</div></div>';

        // Center Pane: Active Sensors for Selected Category
        html += `
          <div class="admin-pane">
            <div class="admin-pane-header active-header">
              ${adminCategoryIcons[selectedAdminCategory] || 'ðŸ“Š'} Active - ${selectedAdminCategory.charAt(0).toUpperCase() + selectedAdminCategory.slice(1)}
            </div>
            <div class="admin-pane-content" id="activeSensorsPane" data-pane="active">
        `;

        if (categorySensors.length === 0) {
          html += '<div class="admin-sensor-list empty-list">No active sensors in this category.<br>Drag from Disabled to enable.</div>';
        } else {
          html += '<div class="admin-sensor-list" id="activeSensorList">';
          categorySensors.forEach((sensorName, index) => {
            html += renderSensorItem(sensorName, index, true);
          });
          html += '</div>';
        }
        html += '</div></div>';

        // Right Pane: Disabled Sensors Bucket
        html += `
          <div class="admin-pane">
            <div class="admin-pane-header disabled-header">
              ðŸš« Disabled (${disabledSensors.length})
            </div>
            <div class="admin-pane-content" id="disabledSensorsPane" data-pane="disabled">
        `;

        if (disabledSensors.length === 0) {
          html += '<div class="admin-sensor-list empty-list">No disabled sensors.<br>Drag here to disable.</div>';
        } else {
          html += '<div class="admin-sensor-list" id="disabledSensorList">';
          disabledSensors.forEach((sensorName, index) => {
            html += renderSensorItem(sensorName, index, false);
          });
          html += '</div>';
        }
        html += '</div></div>';

        html += '</div>'; // Close admin-3pane

        html += '<button class="reset-config-btn" onclick="resetMachineConfig()">Reset to Defaults</button>';

        container.innerHTML = html;
        attachDragListeners();
      }

      // Render a single sensor item
      function renderSensorItem(sensorName, index, isEnabled) {
        const category = getSensorCategory(sensorName);
        return `
          <div class="admin-sensor-item ${isEnabled ? '' : 'disabled'}"
               data-sensor="${sensorName}" data-index="${index}" data-enabled="${isEnabled}">
            <span class="drag-handle" title="Drag to reorder or move">â˜°</span>
            <div class="sensor-info">
              <span class="sensor-name">${formatSensorName(sensorName)}</span>
              <span class="sensor-category">${category}</span>
            </div>
          </div>
        `;
      }

      // ========== Custom Drag-and-Drop (Mouse + Touch) ==========

      // Drag-and-drop state
      let dragState = {
        item: null,
        startY: 0,
        startX: 0,
        startIndex: 0,
        offsetY: 0,
        offsetX: 0,
        clone: null,
        sourcePane: null // 'active' or 'disabled'
      };

      function attachDragListeners() {
        const handles = document.querySelectorAll('.admin-sensor-list .drag-handle');

        handles.forEach(handle => {
          // Mouse events
          handle.addEventListener('mousedown', startDrag);
          // Touch events
          handle.addEventListener('touchstart', startDrag, { passive: false });
        });
      }

      function startDrag(e) {
        e.preventDefault();
        const item = e.target.closest('.admin-sensor-item');
        if (!item) return;

        const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
        const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
        const rect = item.getBoundingClientRect();

        // Determine source pane
        const paneContent = item.closest('.admin-pane-content');
        dragState.sourcePane = paneContent?.dataset.pane || 'active';

        dragState.item = item;
        dragState.startY = clientY;
        dragState.startX = clientX;
        dragState.startIndex = parseInt(item.dataset.index);
        dragState.offsetY = clientY - rect.top;
        dragState.offsetX = clientX - rect.left;

        // Create visual clone for dragging
        dragState.clone = item.cloneNode(true);
        dragState.clone.classList.add('dragging');
        dragState.clone.style.position = 'fixed';
        dragState.clone.style.width = rect.width + 'px';
        dragState.clone.style.left = (clientX - dragState.offsetX) + 'px';
        dragState.clone.style.top = (clientY - dragState.offsetY) + 'px';
        dragState.clone.style.pointerEvents = 'none';
        dragState.clone.style.zIndex = '9999';
        document.body.appendChild(dragState.clone);

        // Fade original
        item.style.opacity = '0.3';

        // Bind move/end events
        if (e.type === 'touchstart') {
          document.addEventListener('touchmove', onDrag, { passive: false });
          document.addEventListener('touchend', endDrag);
        } else {
          document.addEventListener('mousemove', onDrag);
          document.addEventListener('mouseup', endDrag);
        }
      }

      function onDrag(e) {
        if (!dragState.item) return;
        e.preventDefault();

        const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
        const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;

        // Move clone
        if (dragState.clone) {
          dragState.clone.style.left = (clientX - dragState.offsetX) + 'px';
          dragState.clone.style.top = (clientY - dragState.offsetY) + 'px';
        }

        // Clear all drop indicators
        document.querySelectorAll('.admin-sensor-item').forEach(item => {
          item.classList.remove('drop-target-above', 'drop-target-below');
        });
        document.querySelectorAll('.admin-pane-content').forEach(pane => {
          pane.classList.remove('drop-zone-active');
        });

        // Check if over a pane
        const targetPane = getTargetPane(clientX, clientY);
        if (targetPane) {
          // If over a different pane, highlight it
          if (targetPane.pane !== dragState.sourcePane) {
            targetPane.element.classList.add('drop-zone-active');
          } else {
            // Same pane - show drop position indicators
            const target = getDropTarget(clientY);
            if (target && target.element !== dragState.item) {
              target.element.classList.add(target.position === 'above' ? 'drop-target-above' : 'drop-target-below');
            }
          }
        }
      }

      function getTargetPane(clientX, clientY) {
        const activePane = document.getElementById('activeSensorsPane');
        const disabledPane = document.getElementById('disabledSensorsPane');

        if (activePane) {
          const rect = activePane.getBoundingClientRect();
          if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom) {
            return { element: activePane, pane: 'active' };
          }
        }
        if (disabledPane) {
          const rect = disabledPane.getBoundingClientRect();
          if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom) {
            return { element: disabledPane, pane: 'disabled' };
          }
        }
        return null;
      }

      function getDropTarget(clientY) {
        const items = document.querySelectorAll('.admin-sensor-item');
        for (const item of items) {
          if (item === dragState.item) continue;
          const rect = item.getBoundingClientRect();
          const midY = rect.top + rect.height / 2;
          if (clientY >= rect.top && clientY <= rect.bottom) {
            return { element: item, position: clientY < midY ? 'above' : 'below' };
          }
        }
        return null;
      }

      function endDrag(e) {
        if (!dragState.item) return;

        const clientX = e.type === 'touchend' ? e.changedTouches[0].clientX : e.clientX;
        const clientY = e.type === 'touchend' ? e.changedTouches[0].clientY : e.clientY;
        const target = getDropTarget(clientY);
        const targetPane = getTargetPane(clientX, clientY);

        // Clean up event listeners
        document.removeEventListener('mousemove', onDrag);
        document.removeEventListener('mouseup', endDrag);
        document.removeEventListener('touchmove', onDrag);
        document.removeEventListener('touchend', endDrag);

        // Clean up visual elements
        if (dragState.clone) {
          dragState.clone.remove();
        }
        if (dragState.item) {
          dragState.item.style.opacity = '';
        }
        document.querySelectorAll('.admin-sensor-item').forEach(item => {
          item.classList.remove('drop-target-above', 'drop-target-below');
        });
        document.querySelectorAll('.admin-pane-content').forEach(pane => {
          pane.classList.remove('drop-zone-active');
        });

        const config = machineParameterConfig[selectedMachineId];
        const sensorName = dragState.item.dataset.sensor;

        // Handle cross-pane drops (enable/disable)
        if (targetPane && targetPane.pane !== dragState.sourcePane) {
          if (targetPane.pane === 'disabled') {
            // Dropped on disabled pane - disable the sensor
            const isCustomSensor = unifiedSensorRegistry[sensorName] && unifiedSensorRegistry[sensorName].source === 'custom';
            if (isCustomSensor) {
              // For custom sensors, use backend API
              fetch(`/api/machines/${selectedMachineId}/custom-sensors/${sensorName}/toggle`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
              })
                .then(response => response.json())
                .then(data => {
                  if (data.success) {
                    config.enabledSensors.delete(sensorName);
                    syncMachineSensorState(sensorName, false);
                    renderAdminSensorList();
                    refreshOperatorDashboard();
                  }
                })
                .catch(error => console.error('Error disabling custom sensor:', error));
            } else {
              config.enabledSensors.delete(sensorName);
              syncMachineSensorState(sensorName, false);
              renderAdminSensorList();
              refreshOperatorDashboard();
            }
          } else if (targetPane.pane === 'active') {
            // Dropped on active pane - enable the sensor
            const isCustomSensor = unifiedSensorRegistry[sensorName] && unifiedSensorRegistry[sensorName].source === 'custom';
            if (isCustomSensor) {
              // For custom sensors, use backend API
              fetch(`/api/machines/${selectedMachineId}/custom-sensors/${sensorName}/toggle`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
              })
                .then(response => response.json())
                .then(data => {
                  if (data.success && data.enabled) {
                    config.enabledSensors.add(sensorName);
                    syncMachineSensorState(sensorName, true);
                    renderAdminSensorList();
                    refreshOperatorDashboard();
                  }
                })
                .catch(error => console.error('Error enabling custom sensor:', error));
            } else {
              config.enabledSensors.add(sensorName);
              syncMachineSensorState(sensorName, true);
              renderAdminSensorList();
              refreshOperatorDashboard();
            }
          }
        }
        // Handle same-pane reorder (only in active pane)
        else if (target && target.element !== dragState.item && dragState.sourcePane === 'active') {
          const targetSensor = target.element.dataset.sensor;

          const oldIndex = config.sensorOrder.indexOf(sensorName);
          let newIndex = config.sensorOrder.indexOf(targetSensor);
          if (target.position === 'below') newIndex++;
          if (oldIndex < newIndex) newIndex--;

          // Reorder array
          config.sensorOrder.splice(oldIndex, 1);
          config.sensorOrder.splice(newIndex, 0, sensorName);

          renderAdminSensorList();
          refreshOperatorDashboard();
        }

        // Reset drag state
        dragState = { item: null, startY: 0, startX: 0, startIndex: 0, offsetY: 0, offsetX: 0, clone: null, sourcePane: null };
      }

      // Sync machineSensorState with config change
      function syncMachineSensorState(sensorName, enabled) {
        if (!machineSensorState[selectedMachineId][sensorName]) {
          machineSensorState[selectedMachineId][sensorName] = { enabled: true, baseline: null };
        }
        machineSensorState[selectedMachineId][sensorName].enabled = enabled;
      }

      // Refresh operator dashboard when config changes
      function refreshOperatorDashboard() {
        if (currentMode === 'operator') {
          updateStats();
          updateLiveSensorReadings();
        }
      }

      // ========== Keyboard Fallback (Move Up/Down Buttons) ==========

      function moveSensor(sensorName, direction) {
        const config = machineParameterConfig[selectedMachineId];
        if (!config || !config.sensorOrder) return;

        const currentIndex = config.sensorOrder.indexOf(sensorName);
        const newIndex = currentIndex + direction;

        // Bounds check
        if (newIndex < 0 || newIndex >= config.sensorOrder.length) return;

        // Swap positions
        [config.sensorOrder[currentIndex], config.sensorOrder[newIndex]] =
          [config.sensorOrder[newIndex], config.sensorOrder[currentIndex]];

        // Re-render and refresh
        renderAdminSensorList();
        refreshOperatorDashboard();
      }

      // ========== Toggle Sensor Enable/Disable ==========

      function toggleSensorEnabledNew(sensorName) {
        const config = machineParameterConfig[selectedMachineId];
        if (!config) return;

        // Check if this is a custom sensor
        const isCustomSensor = unifiedSensorRegistry[sensorName] && unifiedSensorRegistry[sensorName].source === 'custom';
        
        if (isCustomSensor) {
          // For custom sensors, use backend API to persist to machine_sensor_config
          const currentEnabled = config.enabledSensors.has(sensorName);
          fetch(`/api/machines/${selectedMachineId}/custom-sensors/${sensorName}/toggle`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          })
            .then(response => response.json())
            .then(data => {
              if (data.success) {
                // Update local state
                if (data.enabled) {
                  config.enabledSensors.add(sensorName);
                } else {
                  config.enabledSensors.delete(sensorName);
                }
                
                // Sync with machineSensorState
                if (!machineSensorState[selectedMachineId][sensorName]) {
                  machineSensorState[selectedMachineId][sensorName] = { enabled: true, baseline: null };
                }
                machineSensorState[selectedMachineId][sensorName].enabled = data.enabled;
                
                // Re-render and refresh
                renderAdminSensorList();
                refreshOperatorDashboard();
              } else {
                console.error('Failed to toggle custom sensor:', data.error);
              }
            })
            .catch(error => {
              console.error('Error toggling custom sensor:', error);
            });
        } else {
          // For built-in sensors, use existing logic (in-memory only)
          if (config.enabledSensors.has(sensorName)) {
            config.enabledSensors.delete(sensorName);
          } else {
            config.enabledSensors.add(sensorName);
          }

          // Sync with existing machineSensorState for backward compatibility
          if (!machineSensorState[selectedMachineId][sensorName]) {
            machineSensorState[selectedMachineId][sensorName] = { enabled: true, baseline: null };
          }
          machineSensorState[selectedMachineId][sensorName].enabled = config.enabledSensors.has(sensorName);

          // Re-render and refresh
          renderAdminSensorList();
          refreshOperatorDashboard();
        }
      }

      // ========== Reset to Defaults ==========

      function resetMachineConfig() {
        if (!confirm(`Reset all sensor settings for Machine ${selectedMachineId} to defaults?`)) {
          return;
        }

        // Get all sensors in original category order
        const allSensors = Object.values(sensorsByCategory).flat();

        // Reset machineParameterConfig
        machineParameterConfig[selectedMachineId] = {
          sensorOrder: [...allSensors],
          enabledSensors: new Set(allSensors)
        };

        // Sync machineSensorState
        for (const sensor of allSensors) {
          machineSensorState[selectedMachineId][sensor] = { enabled: true, baseline: null };
        }

        // Re-render and refresh
        renderAdminSensorList();
        refreshOperatorDashboard();
      }

      // ========== Helper Functions for Ordered Sensor Rendering ==========

      // Get sensors in configured order, filtered to enabled only, optionally by category
      function getOrderedEnabledSensors(category = null) {
        const config = machineParameterConfig[selectedMachineId];
        if (!config || !config.sensorOrder || config.sensorOrder.length === 0) {
          // Fallback to category order if config not initialized
          if (category) {
            return sensorsByCategory[category] || [];
          }
          return Object.values(sensorsByCategory).flat();
        }

        // Filter to enabled sensors in configured order
        let sensors = config.sensorOrder.filter(s => config.enabledSensors.has(s));

        // Optionally filter by category
        if (category) {
          sensors = sensors.filter(s => getSensorCategory(s) === category);
        }

        return sensors;
      }

      // Filter and order an array of sensor names based on config
      function filterAndOrderSensors(sensorArray) {
        const config = machineParameterConfig[selectedMachineId];
        if (!config || !config.sensorOrder || config.sensorOrder.length === 0) {
          // Fallback: just filter by enabled
          return sensorArray.filter(s => isSensorEnabled(s));
        }

        const orderMap = new Map(config.sensorOrder.map((s, i) => [s, i]));

        return sensorArray
          .filter(s => config.enabledSensors.has(s))
          .sort((a, b) => (orderMap.get(a) ?? 999) - (orderMap.get(b) ?? 999));
      }

      // Filter sensor data by machine and enabled state (non-destructive wrapper)
      function filterSensorData(data) {
        if (!data) return data;
        
        const currentState = machineSensorState[selectedMachineId];
        const filtered = JSON.parse(JSON.stringify(data)); // Deep copy to avoid modifying original
        
        // Filter sensor readings - only show enabled sensors, apply baselines
        if (filtered.recent_readings_full) {
          filtered.recent_readings_full = filtered.recent_readings_full.map(reading => {
            const filteredReading = {};
            Object.keys(reading).forEach(key => {
              if (key === 'timestamp' || key === 'created_at') {
                filteredReading[key] = reading[key];
              } else {
                const sensorState = currentState[key];
                // Only include if sensor is enabled (default to enabled if not set)
                if (!sensorState || sensorState.enabled !== false) {
                  // Apply baseline if set, otherwise use actual value
                  if (sensorState && sensorState.baseline !== null) {
                    filteredReading[key] = sensorState.baseline;
                  } else {
                    filteredReading[key] = reading[key];
                  }
                }
                // If disabled, don't include in filtered reading (will be filtered out in display)
              }
            });
            return filteredReading;
          });
        }
        
        // Filter stats by category - remove disabled sensors from display
        if (filtered.stats_by_category) {
          Object.keys(filtered.stats_by_category).forEach(category => {
            const categoryData = filtered.stats_by_category[category];
            if (categoryData.sensors) {
              Object.keys(categoryData.sensors).forEach(sensorName => {
                const sensorState = currentState[sensorName];
                // Remove from display if disabled
                if (sensorState && sensorState.enabled === false) {
                  delete categoryData.sensors[sensorName];
                } else if (sensorState && sensorState.baseline !== null) {
                  // Apply baseline override
                  categoryData.sensors[sensorName].value = sensorState.baseline;
                }
              });
            }
          });
        }
        
        return filtered;
      }
      // ========== End Machine and Mode State Management ==========

      // ========== Display Refresh Rate Control ==========
      let uiRefreshIntervalMs = 10000; // Default 10 seconds
      let liveReadingsTimer = null;

      function setRefreshRate(intervalMs) {
        // Guard: minimum 1000ms
        if (intervalMs < 1000) {
          intervalMs = 1000;
        }
        
        uiRefreshIntervalMs = intervalMs;
        
        // Update button states
        document.querySelectorAll('.refresh-rate-btn').forEach(btn => {
          btn.classList.toggle('active', parseInt(btn.dataset.interval) === intervalMs);
        });
        
        // Restart the live readings timer with new interval
        if (liveReadingsTimer) {
          clearInterval(liveReadingsTimer);
        }
        
        // Start new timer for Live Sensor Readings only
        liveReadingsTimer = setInterval(() => {
          updateLiveSensorReadings();
        }, uiRefreshIntervalMs);
        
        // Immediately update to show change
        updateLiveSensorReadings();
      }

      // RENDER-ONLY function for Live Sensor Readings (no data fetching, no accumulation)
      function updateLiveSensorReadings() {
        // STRICTLY render-only: use cached data, no API calls, no mutations
        const machine = machineData[selectedMachineId];
        const readingsContainer = document.getElementById("readingsHistory");
        
        if (!readingsContainer) return;
        
        const machineReadings = machine.recentReadings || [];
        
        if (machineReadings.length === 0) {
          readingsContainer.innerHTML = `<div style="text-align: center; color: #94a3b8; padding: 40px; font-size: 14px; text-transform: uppercase; letter-spacing: 2px;">No data yet for Machine ${selectedMachineId}</div>`;
          return;
        }
        
        // Get sensor units from cached stats data (no API call)
        const sensorUnits = machine.statsData?.stats_by_category?.[selectedHistoryCategory]?.sensors || {};

        // Use ordered enabled sensors from machineParameterConfig, also filter hidden sensors
        const sensors = getOrderedEnabledSensors(selectedHistoryCategory)
          .filter(sensor => !hiddenSensors.has(sensor));

        const historyHTML = machineReadings.map((reading) => {
          // Merge custom_sensors into reading if present
          const mergedReading = { ...reading };
          if (reading.custom_sensors && typeof reading.custom_sensors === 'object') {
            Object.assign(mergedReading, reading.custom_sensors);
          }
          
          const metricsHtml = sensors.map((sensor) => {
            const displayName = sensor.replace(/_/g, " ").toUpperCase();
            // Check both direct property and custom_sensors object
            const value = mergedReading[sensor];
            // Get unit from stats or unified registry
            const unit = sensorUnits[sensor]?.unit || getSensorMetadata(sensor).unit || "";
            return `
              <div class="history-metric">
                <div class="metric-value">${value !== undefined && value !== null ? formatNumber(value) : '--'}${unit ? '<span class="sensor-unit">' + unit + "</span>" : ""}</div>
                <div class="metric-label">${displayName}</div>
              </div>
            `;
          }).join("");

          return `
            <div class="history-item">
              <div class="history-timestamp">${formatDateTime(reading.created_at)}</div>
              <div class="history-grid">${metricsHtml}</div>
            </div>
          `;
        }).join("");
        
        readingsContainer.innerHTML = historyHTML;
      }
      // ========== End Display Refresh Rate Control ==========

      let selectedHistoryCategory = "environmental";
      let configLimits = null;
      let configDefaults = null;

      // ============================================================================
      // UNIFIED SENSOR REGISTRY (Built-in + Custom Sensors)
      // ============================================================================
      
      // Built-in sensors definition (static)
      const builtInSensorsByCategory = {
        environmental: [
          "temperature",
          "pressure",
          "humidity",
          "ambient_temp",
          "dew_point",
          "air_quality_index",
          "co2_level",
          "particle_count",
          "noise_level",
          "light_intensity",
        ],
        mechanical: [
          "vibration",
          "rpm",
          "torque",
          "shaft_alignment",
          "bearing_temp",
          "motor_current",
          "belt_tension",
          "gear_wear",
          "coupling_temp",
          "lubrication_pressure",
        ],
        thermal: [
          "coolant_temp",
          "exhaust_temp",
          "oil_temp",
          "radiator_temp",
          "thermal_efficiency",
          "heat_dissipation",
          "inlet_temp",
          "outlet_temp",
          "core_temp",
          "surface_temp",
        ],
        electrical: [
          "voltage",
          "current",
          "power_factor",
          "frequency",
          "resistance",
          "capacitance",
          "inductance",
          "phase_angle",
          "harmonic_distortion",
          "ground_fault",
        ],
        fluid: [
          "flow_rate",
          "fluid_pressure",
          "viscosity",
          "density",
          "reynolds_number",
          "pipe_pressure_drop",
          "pump_efficiency",
          "cavitation_index",
          "turbulence",
          "valve_position",
        ],
      };

      // Unified sensor registry: {sensorName: {name, category, unit, source, enabled}}
      let unifiedSensorRegistry = {};
      
      // Dynamic sensorsByCategory (built from unified registry)
      let sensorsByCategory = {};

      // Initialize built-in sensors in unified registry
      function initializeBuiltInSensors() {
        Object.keys(builtInSensorsByCategory).forEach(category => {
          builtInSensorsByCategory[category].forEach(sensorName => {
            unifiedSensorRegistry[sensorName] = {
              name: sensorName,
              category: category,
              unit: '', // Will be populated from stats API
              source: 'builtin',
              enabled: true
            };
          });
        });
        rebuildSensorsByCategory();
      }

      // Merge custom sensors into unified registry
      function mergeCustomSensors(customSensors) {
        // Only merge active custom sensors
        const activeCustomSensors = (customSensors || []).filter(s => s.is_active);
        
        activeCustomSensors.forEach(sensor => {
          const category = sensor.category || 'custom';
          unifiedSensorRegistry[sensor.sensor_name] = {
            name: sensor.sensor_name,
            category: category,
            unit: sensor.unit || '',
            source: 'custom',
            enabled: true // Default enabled, can be overridden by machine config
          };
        });
        
        rebuildSensorsByCategory();
        
        // Update machine state to include new custom sensors
        updateMachineStateForCustomSensors(activeCustomSensors);
      }

      // Update machine state when custom sensors are added
      function updateMachineStateForCustomSensors(customSensors) {
        const allSensors = Object.keys(sensorsByCategory).flatMap(cat => sensorsByCategory[cat]);
        ['A', 'B', 'C'].forEach(machineId => {
          // Load machine-specific enabled state from backend
          loadMachineCustomSensorState(machineId, customSensors);
        });
      }

      // Load machine-specific custom sensor enabled state from backend
      function loadMachineCustomSensorState(machineId, customSensors) {
        fetch(`/api/machines/${machineId}/custom-sensors`)
          .then(response => response.json())
          .then(data => {
            if (data.success && data.sensors) {
              // Add custom sensors to machine state with their enabled status
              customSensors.forEach(sensor => {
                const sensorName = sensor.sensor_name;
                const enabled = data.sensors[sensorName]?.enabled !== false; // Default to true if not set
                
                if (!machineSensorState[machineId][sensorName]) {
                  machineSensorState[machineId][sensorName] = {
                    enabled: enabled,
                    baseline: null
                  };
                } else {
                  machineSensorState[machineId][sensorName].enabled = enabled;
                }
              });
              
              // Update machineParameterConfig to include new sensors with correct enabled state
              const config = machineParameterConfig[machineId];
              customSensors.forEach(sensor => {
                const sensorName = sensor.sensor_name;
                const enabled = data.sensors[sensorName]?.enabled !== false;
                
                if (!config.sensorOrder.includes(sensorName)) {
                  config.sensorOrder.push(sensorName);
                }
                if (enabled) {
                  config.enabledSensors.add(sensorName);
                } else {
                  config.enabledSensors.delete(sensorName);
                }
              });
              
              // If this is the currently selected machine, refresh the UI
              if (machineId === selectedMachineId && currentMode === 'admin') {
                renderAdminSensorList();
              }
            }
          })
          .catch(error => {
            console.error(`Error loading custom sensor state for machine ${machineId}:`, error);
            // Fallback: enable all custom sensors by default
            customSensors.forEach(sensor => {
              const sensorName = sensor.sensor_name;
              if (!machineSensorState[machineId][sensorName]) {
                machineSensorState[machineId][sensorName] = {
                  enabled: true,
                  baseline: null
                };
              }
              const config = machineParameterConfig[machineId];
              if (!config.sensorOrder.includes(sensorName)) {
                config.sensorOrder.push(sensorName);
              }
              config.enabledSensors.add(sensorName);
            });
          });
      }

      // Rebuild sensorsByCategory from unified registry
      function rebuildSensorsByCategory() {
        // Initialize all categories (including 'custom' if needed)
        sensorsByCategory = {};
        Object.keys(builtInSensorsByCategory).forEach(cat => {
          sensorsByCategory[cat] = [];
        });
        sensorsByCategory['custom'] = [];
        
        // Populate from unified registry
        Object.values(unifiedSensorRegistry).forEach(sensor => {
          const category = sensor.category || 'custom';
          if (!sensorsByCategory[category]) {
            sensorsByCategory[category] = [];
          }
          if (!sensorsByCategory[category].includes(sensor.name)) {
            sensorsByCategory[category].push(sensor.name);
          }
        });
      }

      // Initialize built-in sensors on page load
      initializeBuiltInSensors();

      // Hidden sensors state tracking
      let hiddenSensors = new Set();
      
      // Initialize machine state now that sensorsByCategory is defined
      initializeMachineState();

      // Load hidden sensors from localStorage on page load
      function loadHiddenSensors() {
        try {
          const stored = localStorage.getItem("hiddenSensors");
          if (stored) {
            hiddenSensors = new Set(JSON.parse(stored));
          }
        } catch (e) {
          console.error("Failed to load hidden sensors:", e);
        }
      }

      // Save hidden sensors to localStorage
      function saveHiddenSensors() {
        try {
          localStorage.setItem(
            "hiddenSensors",
            JSON.stringify([...hiddenSensors])
          );
        } catch (e) {
          console.error("Failed to save hidden sensors:", e);
        }
      }

      // Toggle sensor visibility
      function toggleSensor(sensorName) {
        if (hiddenSensors.has(sensorName)) {
          hiddenSensors.delete(sensorName);
        } else {
          hiddenSensors.add(sensorName);
        }
        saveHiddenSensors();
        updateStats();
      }

      // =============================================
      // THRESHOLD MANAGEMENT
      // =============================================

      // Store custom thresholds in sessionStorage
      let customThresholds = {};

      // Track expanded threshold controls (survives re-renders)
      let expandedThresholds = new Set();

      // Store default thresholds from backend (SENSOR_THRESHOLDS)
      let defaultThresholds = {};

      // Load thresholds from sessionStorage on page load
      function loadThresholds() {
        try {
          const stored = sessionStorage.getItem("customThresholds");
          if (stored) {
            customThresholds = JSON.parse(stored);
          }
        } catch (e) {
          console.error("Failed to load thresholds:", e);
        }
      }

      // Load default thresholds from backend API
      function loadDefaultThresholds() {
        fetch("/api/thresholds")
          .then((r) => r.json())
          .then((data) => {
            if (data.defaults) {
              defaultThresholds = data.defaults;
            }
          })
          .catch(console.error);
      }

      // Save thresholds to sessionStorage
      function saveThresholdsToStorage() {
        try {
          sessionStorage.setItem(
            "customThresholds",
            JSON.stringify(customThresholds)
          );
        } catch (e) {
          console.error("Failed to save thresholds:", e);
        }
      }

      // Get threshold for a sensor (custom or default from SENSOR_THRESHOLDS)
      function getThreshold(sensorName) {
        if (customThresholds[sensorName]) {
          return customThresholds[sensorName];
        }
        // Return default from SENSOR_THRESHOLDS (loaded from backend)
        const defaults = defaultThresholds[sensorName];
        if (defaults) {
          return { min: defaults.low, max: defaults.high };
        }
        return { min: 0, max: 100 }; // Fallback
      }

      // Get default threshold values for a sensor
      function getDefaultThreshold(sensorName) {
        const defaults = defaultThresholds[sensorName];
        if (defaults) {
          return {
            low: defaults.low,
            high: defaults.high,
            unit: defaults.unit,
          };
        }
        return { low: 0, high: 100, unit: "" };
      }

      // Toggle threshold controls visibility
      function toggleThreshold(sensorName, event) {
        if (event) {
          event.stopPropagation();
        }
        const controls = document.getElementById(`threshold-${sensorName}`);
        if (controls) {
          const isExpanded = controls.classList.toggle("expanded");
          if (isExpanded) {
            expandedThresholds.add(sensorName);
          } else {
            expandedThresholds.delete(sensorName);
          }
        }
      }

      // Restore expanded state after re-render
      function restoreExpandedThresholds() {
        expandedThresholds.forEach((sensorName) => {
          const controls = document.getElementById(`threshold-${sensorName}`);
          if (controls) {
            controls.classList.add("expanded");
          }
        });
      }

      // Save custom threshold
      function saveThreshold(sensorName, event) {
        if (event) {
          event.stopPropagation();
        }
        const minInput = document.getElementById(`min-${sensorName}`);
        const maxInput = document.getElementById(`max-${sensorName}`);
        const defaults = getDefaultThreshold(sensorName);

        if (minInput && maxInput) {
          const minVal = parseFloat(minInput.value);
          const maxVal = parseFloat(maxInput.value);

          if (isNaN(minVal) || isNaN(maxVal)) {
            alert("Please enter valid numbers");
            return;
          }

          if (minVal >= maxVal) {
            alert("Low limit must be less than High limit");
            return;
          }

          customThresholds[sensorName] = { min: minVal, max: maxVal };
          saveThresholdsToStorage();

          // Send to backend
          fetch("/api/thresholds", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              sensor: sensorName,
              min: minVal,
              max: maxVal,
            }),
          })
            .then((r) => r.json())
            .then((data) => {
              if (data.success) {
                // Update UI to show threshold is active
                const sensorItem = document.querySelector(
                  `[data-sensor="${sensorName}"]`
                );
                if (sensorItem) {
                  sensorItem.classList.add("threshold-active");
                }
                // Show success feedback
                const btn = event?.target;
                if (btn) {
                  const originalText = btn.textContent;
                  btn.textContent = "âœ“ Saved";
                  btn.style.background = "#059669";
                  setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = "";
                  }, 1500);
                }
              }
            })
            .catch(console.error);
        }
      }

      // Reset threshold to default
      function resetThreshold(sensorName, event) {
        if (event) {
          event.stopPropagation();
        }
        delete customThresholds[sensorName];
        saveThresholdsToStorage();

        // Get actual defaults from SENSOR_THRESHOLDS
        const defaults = getDefaultThreshold(sensorName);

        // Update inputs
        const minInput = document.getElementById(`min-${sensorName}`);
        const maxInput = document.getElementById(`max-${sensorName}`);
        if (minInput) minInput.value = defaults.low;
        if (maxInput) maxInput.value = defaults.high;

        // Send to backend
        fetch("/api/thresholds", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            sensor: sensorName,
            min: defaults.low,
            max: defaults.high,
            reset: true,
          }),
        }).catch(console.error);

        // Update UI
        const sensorItem = document.querySelector(
          `[data-sensor="${sensorName}"]`
        );
        if (sensorItem) {
          sensorItem.classList.remove("threshold-active");
        }
      }

      // Initialize thresholds on load
      loadThresholds();
      loadDefaultThresholds();

      function changeHistoryCategory() {
        selectedHistoryCategory =
          document.getElementById("historyCategory").value;
        // Update Live Sensor Readings immediately when category changes
        updateLiveSensorReadings();
      }

      function formatNumber(value, decimals = 2) {
        if (value === null || value === undefined || isNaN(value)) {
          return "--";
        }
        return Number(value).toFixed(decimals);
      }

      function formatDateTime(value) {
        if (!value) return "";
        const date = new Date(value);
        return isNaN(date.getTime()) ? value : date.toLocaleString();
      }

      let activeCategory = "environmental";
      let activeStatsCategory = "environmental";
      const categoryIcons = {
        environmental: "ðŸŒ",
        mechanical: "âš™ï¸",
        thermal: "ðŸ”¥",
        electrical: "âš¡",
        fluid: "ðŸ’§",
        custom: "âž•",
      };

      function switchCategory(category) {
        activeCategory = category;
        // Update tab UI for All Sensor Parameters
        document.querySelectorAll("#categoryTabs .tab").forEach((tab) => {
          tab.classList.toggle("active", tab.dataset.category === category);
        });
        // Update content UI for All Sensor Parameters
        document
          .querySelectorAll("#categoryContent .tab-content")
          .forEach((content) => {
            content.classList.toggle(
              "active",
              content.dataset.category === category
            );
          });
      }

      function switchStatsCategory(category) {
        activeStatsCategory = category;
        // Update tab UI for Statistics
        document.querySelectorAll("#statsCategoryTabs .tab").forEach((tab) => {
          tab.classList.toggle("active", tab.dataset.category === category);
        });
        // Update content UI for Statistics
        document
          .querySelectorAll("#statsCategoryContent .tab-content")
          .forEach((content) => {
            content.classList.toggle(
              "active",
              content.dataset.category === category
            );
          });
      }

      function updateStats() {
        fetch("/api/stats")
          .then((r) => r.json())
          .then((data) => {
            // ========== MACHINE DATA ISOLATION ==========
            // Store incoming data ONLY for the currently selected machine
            const currentMachine = machineData[selectedMachineId];

            // Apply machine filtering (non-destructive wrapper)
            data = filterSensorData(data);

            // ========== GUARD: Only collect data if producer + machine are running ==========
            if (canCollectData()) {
              // Store filtered data in machine-specific buffer
              currentMachine.statsData = JSON.parse(JSON.stringify(data)); // Deep copy

              // Accumulate readings for this machine (append-only, keep last 100)
              if (data.recent_readings_full && data.recent_readings_full.length > 0) {
                const newReadings = data.recent_readings_full;
                // Merge new readings avoiding duplicates by timestamp
                const existingTimestamps = new Set(currentMachine.recentReadings.map(r => r.created_at));
                newReadings.forEach(reading => {
                  if (!existingTimestamps.has(reading.created_at)) {
                    currentMachine.recentReadings.unshift(reading);

                    // ========== ACCUMULATE SENSOR SUMS/COUNTS FOR AVERAGES ==========
                    // For each sensor value in this reading, add to machine-specific accumulators
                    // Merge custom_sensors into reading for accumulation
                    const mergedReading = { ...reading };
                    if (reading.custom_sensors && typeof reading.custom_sensors === 'object') {
                      Object.assign(mergedReading, reading.custom_sensors);
                    }
                    
                    Object.keys(mergedReading).forEach(sensorName => {
                      if (sensorName !== 'created_at' && sensorName !== 'id' && sensorName !== 'custom_sensors' && typeof mergedReading[sensorName] === 'number') {
                        if (!currentMachine.sensorSums[sensorName]) {
                          currentMachine.sensorSums[sensorName] = 0;
                          currentMachine.sensorCounts[sensorName] = 0;
                        }
                        currentMachine.sensorSums[sensorName] += mergedReading[sensorName];
                        currentMachine.sensorCounts[sensorName] += 1;
                      }
                    });
                  }
                });
                // Keep last 100 readings per machine (increased from 50)
                currentMachine.recentReadings = currentMachine.recentReadings.slice(0, 100);
              }

              // Update total count for THIS machine specifically
              // Each fetch increments machine-specific counter
              const previousCount = currentMachine.totalCount || 0;
              const newDataCount = (data.recent_readings_full || []).length;
              if (newDataCount > 0) {
                currentMachine.totalCount = previousCount + newDataCount;
              }
            }
            // ========== END GUARD ==========

            // Always display count from machine buffer (even when not collecting)
            document.getElementById("totalCount").textContent = currentMachine.totalCount;

            // Update Statistics section with category tabs
            if (data.stats_by_category) {
              const statsTabsEl = document.getElementById("statsCategoryTabs");
              const statsContentEl = document.getElementById(
                "statsCategoryContent"
              );

              if (statsTabsEl && !statsTabsEl.hasChildNodes()) {
                // Build tabs for Statistics (only once)
                const categories = Object.keys(data.stats_by_category);
                statsTabsEl.innerHTML = categories
                  .map((cat) => {
                    const catData = data.stats_by_category[cat];
                    const icon = categoryIcons[cat] || "ðŸ“Š";
                    const isActive =
                      cat === activeStatsCategory ? "active" : "";
                    return `<div class="tab ${isActive}" data-category="${cat}" onclick="switchStatsCategory('${cat}')">${icon} ${catData.name}</div>`;
                  })
                  .join("");
              }

              if (statsContentEl) {
                // Build content for Statistics categories
                const categories = Object.keys(data.stats_by_category);
                statsContentEl.innerHTML = categories
                  .map((cat) => {
                    const catData = data.stats_by_category[cat];
                    const isActive =
                      cat === activeStatsCategory ? "active" : "";

                    // Get sensors in configured order, filtered to enabled, also filter hidden
                    // Include custom sensors from unified registry even if not in stats API yet
                    const orderedSensors = getOrderedEnabledSensors(cat)
                      .filter(name => {
                        if (hiddenSensors.has(name)) return false;
                        // Include if in stats API response OR if it's a custom sensor in unified registry
                        return catData.sensors[name] || (unifiedSensorRegistry[name] && unifiedSensorRegistry[name].source === 'custom' && unifiedSensorRegistry[name].category === cat);
                      });

                    const statsHtml = orderedSensors
                      .map((name) => {
                        // Get info from stats API or fallback to unified registry
                        const info = catData.sensors[name] || {
                          unit: getSensorMetadata(name).unit || '',
                          metadata: {}
                        };
                        const displayName = name
                          .replace(/_/g, " ")
                          .toUpperCase();
                        // ========== USE MACHINE-SPECIFIC AVERAGE ==========
                        const machineAvg = getCurrentMachineAverage(name);
                        const value = machineAvg !== null
                            ? formatNumber(machineAvg)
                            : "--";
                        // Get metadata if available
                        const metadata = info.metadata || {};
                        const location = metadata.location || '';
                        const equipment = metadata.equipment_section || '';
                        const criticality = metadata.criticality || 'medium';
                        const metadataHtml = (location || equipment || criticality) ? `
                                            <div class="sensor-metadata" style="margin-top: 4px;">
                                                ${location ? `<span class="metadata-badge metadata-location">ðŸ“ ${location}</span>` : ''}
                                                ${equipment ? `<span class="metadata-badge metadata-equipment">âš™ï¸ ${equipment}</span>` : ''}
                                                ${criticality ? `<span class="metadata-badge metadata-criticality ${criticality}">${criticality.toUpperCase()}</span>` : ''}
                                            </div>
                                        ` : '';
                        
                        return `
                                        <div class="stat">
                                            <span class="stat-label">${displayName}</span>
                                            <span class="stat-value">${value}${
                          info.unit ? " " + info.unit : ""
                        }</span>
                                            ${metadataHtml}
                                        </div>
                                    `;
                      })
                      .join("");

                    // Only show "No visible sensors" if there are truly no sensors in this category
                    const hasSensorsInCategory = sensorsByCategory[cat] && sensorsByCategory[cat].length > 0;
                    const noSensorsMessage = hasSensorsInCategory 
                      ? '<div class="stat"><span class="stat-label" style="color: #94a3b8;">All sensors in this category are hidden or disabled</span></div>'
                      : '<div class="stat"><span class="stat-label">No sensors in this category</span></div>';

                    return `
                                    <div class="tab-content ${isActive}" data-category="${cat}">
                                        ${
                                          statsHtml || noSensorsMessage
                                        }
                                    </div>
                                `;
                  })
                  .join("");
              }
            }

            // Update categorized sensor data for All Sensor Parameters section
            if (data.stats_by_category) {
              const tabsEl = document.getElementById("categoryTabs");
              const contentEl = document.getElementById("categoryContent");

              if (tabsEl && !tabsEl.hasChildNodes()) {
                // Build tabs (only once)
                const categories = Object.keys(data.stats_by_category);
                tabsEl.innerHTML = categories
                  .map((cat) => {
                    const catData = data.stats_by_category[cat];
                    const icon = categoryIcons[cat] || "ðŸ“Š";
                    const isActive = cat === activeCategory ? "active" : "";
                    return `<div class="tab ${isActive}" data-category="${cat}" onclick="switchCategory('${cat}')">${icon} ${catData.name}</div>`;
                  })
                  .join("");
              }

              if (contentEl) {
                // Build content for all categories
                const categories = Object.keys(data.stats_by_category);
                contentEl.innerHTML = categories
                  .map((cat) => {
                    const catData = data.stats_by_category[cat];
                    const isActive = cat === activeCategory ? "active" : "";
                    // Get sensors in configured order, filtered to enabled
                    // Include custom sensors from unified registry even if not in stats API yet
                    const orderedSensors = getOrderedEnabledSensors(cat)
                      .filter(name => {
                        // Include if in stats API response OR if it's a custom sensor in unified registry
                        return catData.sensors[name] || (unifiedSensorRegistry[name] && unifiedSensorRegistry[name].source === 'custom' && unifiedSensorRegistry[name].category === cat);
                      });
                    const sensorsHtml = orderedSensors
                      .map((name) => {
                        // Get info from stats API or fallback to unified registry
                        const info = catData.sensors[name] || {
                          unit: getSensorMetadata(name).unit || '',
                          metadata: {}
                        };
                        const displayName = name
                          .replace(/_/g, " ")
                          .toUpperCase();
                        // ========== USE MACHINE-SPECIFIC AVERAGE ==========
                        const machineAvg = getCurrentMachineAverage(name);
                        const value = machineAvg !== null
                            ? formatNumber(machineAvg)
                            : "--";
                        const isHidden = hiddenSensors.has(name);
                        const hiddenClass = isHidden ? "hidden-sensor" : "";
                        const checkedAttr = isHidden ? "" : "checked";
                        const threshold = getThreshold(name);
                        const defaults = getDefaultThreshold(name);
                        const hasCustomThreshold =
                          customThresholds[name] !== undefined;
                        const thresholdActiveClass = hasCustomThreshold
                          ? "threshold-active"
                          : "";
                        // Get metadata if available
                        const metadata = info.metadata || {};
                        const location = metadata.location || '';
                        const equipment = metadata.equipment_section || '';
                        const criticality = metadata.criticality || 'medium';
                        const metadataHtml = (location || equipment || criticality) ? `
                                            <div class="sensor-metadata">
                                                ${location ? `<span class="metadata-badge metadata-location">ðŸ“ ${location}</span>` : ''}
                                                ${equipment ? `<span class="metadata-badge metadata-equipment">âš™ï¸ ${equipment}</span>` : ''}
                                                ${criticality ? `<span class="metadata-badge metadata-criticality ${criticality}">${criticality.toUpperCase()}</span>` : ''}
                                            </div>
                                        ` : '';
                        
                        return `
                                        <div class="sensor-item ${hiddenClass} ${thresholdActiveClass}" data-sensor="${name}">
                                            <input type="checkbox" class="sensor-toggle" ${checkedAttr} onchange="toggleSensor('${name}')" title="Toggle visibility">
                                            <div class="sensor-name">${displayName}</div>
                                            <div class="sensor-value">${value}<span class="sensor-unit">${
                          info.unit
                        }</span></div>
                                            ${metadataHtml}
                                            <div class="threshold-toggle" onclick="toggleThreshold('${name}', event)">
                                                âš™ï¸ Set Limits ${
                                                  hasCustomThreshold ? "âœ“" : ""
                                                }
                                            </div>
                                            <div class="threshold-controls" id="threshold-${name}" onclick="event.stopPropagation()">
                                                <div class="threshold-row">
                                                    <div class="threshold-field">
                                                        <span class="threshold-label">Low Limit</span>
                                                        <input type="number" class="threshold-input" id="min-${name}" 
                                                               value="${
                                                                 threshold.min
                                                               }" step="any" 
                                                               placeholder="${
                                                                 defaults.low
                                                               }">
                                                    </div>
                                                    <div class="threshold-field">
                                                        <span class="threshold-label">High Limit</span>
                                                        <input type="number" class="threshold-input" id="max-${name}" 
                                                               value="${
                                                                 threshold.max
                                                               }" step="any"
                                                               placeholder="${
                                                                 defaults.high
                                                               }">
                                                    </div>
                                                </div>
                                                <div class="threshold-buttons">
                                                    <button class="threshold-save-btn" onclick="saveThreshold('${name}', event)">ðŸ’¾ Save</button>
                                                    <button class="threshold-reset-btn" onclick="resetThreshold('${name}', event)">â†©ï¸ Reset</button>
                                                </div>
                                                <div class="threshold-default">ðŸ“Š Safe range: ${
                                                  defaults.low
                                                } â€“ ${defaults.high} ${
                          defaults.unit
                        }</div>
                                            </div>
                                        </div>
                                    `;
                      })
                      .join("");

                    return `
                                    <div class="tab-content ${isActive}" data-category="${cat}">
                                        <div class="sensor-grid">${sensorsHtml}</div>
                                    </div>
                                `;
                  })
                  .join("");

                // Restore any expanded threshold controls after re-render
                restoreExpandedThresholds();
              }
            }

            // Render history for selected category - USE MACHINE-SPECIFIC BUFFER
            const machineReadings = currentMachine.recentReadings;
            if (machineReadings && machineReadings.length > 0) {
              const allSensors = sensorsByCategory[selectedHistoryCategory] || [];
              const currentState = machineSensorState[selectedMachineId];
              // Filter out hidden sensors AND disabled sensors for current machine
              const sensors = allSensors.filter(sensor => {
                return !hiddenSensors.has(sensor) &&
                       (currentState[sensor]?.enabled !== false);
              });
              const sensorUnits =
                data.stats_by_category?.[selectedHistoryCategory]?.sensors ||
                {};

              const historyHTML = machineReadings
                .map((reading) => {
                  const metricsHtml = sensors
                    .map((sensor) => {
                      const displayName = sensor
                        .replace(/_/g, " ")
                        .toUpperCase();
                      const value = reading[sensor];
                      const unit = sensorUnits[sensor]?.unit || "";
                      return `
                                        <div class="history-metric">
                                            <div class="metric-value">${formatNumber(
                                              value
                                            )}${
                        unit
                          ? '<span class="sensor-unit">' + unit + "</span>"
                          : ""
                      }</div>
                                            <div class="metric-label">${displayName}</div>
                                        </div>
                                    `;
                    })
                    .join("");

                  return `
                                <div class="history-item">
                                    <div class="history-timestamp">${formatDateTime(
                                      reading.created_at
                                    )}</div>
                                    <div class="history-grid">${metricsHtml}</div>
                                </div>
                            `;
                })
                .join("");
              document.getElementById("readingsHistory").innerHTML =
                historyHTML;
            } else {
              document.getElementById("readingsHistory").innerHTML =
                `<div style="text-align: center; color: #94a3b8; padding: 40px; font-size: 14px; text-transform: uppercase; letter-spacing: 2px;">No data yet for Machine ${selectedMachineId}</div>`;
            }
          });
      }

      function updateStatus() {
        fetch("/api/status")
          .then((r) => r.json())
          .then((data) => {
            // ========== SYNC PRODUCER RUNNING STATE ==========
            // This is the single source of truth for producer state
            producerRunning = data.producer_running === true;

            const producerEl = document.getElementById("producerStatus");
            const consumerEl = document.getElementById("consumerStatus");
            if (producerEl) {
              producerEl.className =
                "status-indicator " +
                (producerRunning ? "status-running" : "status-stopped");
            }
            if (consumerEl) {
              consumerEl.className =
                "status-indicator " +
                (data.consumer_running ? "status-running" : "status-stopped");
            }

            if (data.kafka) {
              const kafkaIndicator = document.getElementById("kafkaStatus");
              const kafkaDetails =
                document.getElementById("kafkaStatusDetails");
              if (kafkaIndicator) {
                let className = "status-indicator ";
                if (data.kafka.status === "healthy") {
                  className += "status-running";
                } else if (data.kafka.status === "unhealthy") {
                  className += "status-stopped";
                }
                kafkaIndicator.className = className;
              }
              if (kafkaDetails) {
                if (data.kafka.status === "healthy") {
                  kafkaDetails.textContent = data.kafka.latency_ms
                    ? `OK (${data.kafka.latency_ms} ms)`
                    : "OK";
                } else if (data.kafka.status === "unhealthy") {
                  kafkaDetails.textContent = data.kafka.error || "Unreachable";
                } else {
                  kafkaDetails.textContent = "Checking...";
                }
              }
            }
          });
      }

      function loadConfig() {
        fetch("/api/config")
          .then((r) => r.json())
          .then((data) => {
            document.getElementById("durationHours").value =
              data.duration_hours ?? 0;
            document.getElementById("durationMinutes").value =
              data.duration_minutes ?? 0;
            document.getElementById("intervalSeconds").value =
              data.interval_seconds ?? 5;
            configLimits = data.limits || null;
            configDefaults = data.defaults || null;
            if (configLimits) {
              const intervalInput = document.getElementById("intervalSeconds");
              intervalInput.min = configLimits.interval_seconds?.min ?? 1;
              intervalInput.max = configLimits.interval_seconds?.max ?? 3600;
            }
            displayConfigMessage("Ready for updates.");
          });
      }

      function displayConfigMessage(message, isError = false) {
        const el = document.getElementById("configMessage");
        if (!el) return;
        el.textContent = message;
        el.style.color = isError ? "#f87171" : "#34d399";
      }

      function updateConfig() {
        const payload = {
          duration_hours: parseInt(
            document.getElementById("durationHours").value,
            10
          ),
          duration_minutes: parseInt(
            document.getElementById("durationMinutes").value,
            10
          ),
          interval_seconds: parseInt(
            document.getElementById("intervalSeconds").value,
            10
          ),
        };

        fetch("/api/config", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        })
          .then((r) => r.json())
          .then((result) => {
            if (result.success) {
              displayConfigMessage("Configuration updated!", false);
              loadConfig();
            } else {
              displayConfigMessage(
                result.error || "Failed to update config",
                true
              );
            }
          })
          .catch(() => displayConfigMessage("Failed to update config", true));
      }

      function resetConfig() {
        fetch("/api/config/reset", { method: "POST" })
          .then((r) => r.json())
          .then((result) => {
            if (result.success) {
              displayConfigMessage("Reset to defaults.", false);
              loadConfig();
            } else {
              displayConfigMessage(
                result.error || "Failed to reset config",
                true
              );
            }
          })
          .catch(() => displayConfigMessage("Failed to reset config", true));
      }

      function exportData(limit = 500) {
        window.open(`/api/export?limit=${limit}`, "_blank");
      }

      function startComponent(component) {
        fetch(`/api/start/${component}`, {
          method: 'POST'
        })
          .then((r) => r.json())
          .then((result) => {
            if (result.success) {
              // ========== SYNC MACHINE RUNNING STATE ON START ==========
              if (component === 'producer') {
                producerRunning = true;
                // Enable data collection for current machine
                machineRunning[selectedMachineId] = true;
              }
              alert(`âœ… ${component} started!`);
            } else {
              alert(`âŒ Failed: ${result.error}`);
            }
            updateStatus();
          })
          .catch((error) => {
            alert(`âŒ Failed to start ${component}: ${error.message}`);
          });
      }

      function stopComponent(component) {
        fetch(`/api/stop/${component}`, {
          method: 'POST'
        })
          .then((r) => r.json())
          .then((result) => {
            if (result.success) {
              // ========== SYNC MACHINE RUNNING STATE ON STOP ==========
              if (component === 'producer') {
                producerRunning = false;
                // Disable data collection for ALL machines
                machineRunning['A'] = false;
                machineRunning['B'] = false;
                machineRunning['C'] = false;
              }
              alert(`âœ… ${component} stopped!`);
            } else {
              alert(`âŒ Failed: ${result.error}`);
            }
            updateStatus();
          })
          .catch((error) => {
            alert(`âŒ Failed to stop ${component}: ${error.message}`);
          });
      }

      function clearData() {
        if (confirm("ðŸ—‘ï¸ Clear all sensor data from database?")) {
          fetch("/api/clear_data")
            .then((r) => r.json())
            .then((result) => {
              if (result.success) {
                // ========== RESET ALL MACHINE DATA BUFFERS ==========
                resetAllMachineData();
                // Update UI to show zeros
                document.getElementById("totalCount").textContent = "0";
                document.getElementById("mlTotalAnomalies").textContent = "0";
                document.getElementById("mlAnomalyRate").textContent = "0.0%";
                document.getElementById("mlReportsGenerated").textContent = "0";
                // Re-render from empty cache
                renderFromMachineCache(selectedMachineId);
                alert("âœ… Data cleared!");
              } else {
                alert("âŒ Failed to clear data");
              }
              updateStats();
            });
        }
      }

      function loadAlerts() {
        fetch("/api/alerts?limit=20")
          .then((r) => r.json())
          .then((data) => {
            const container = document.getElementById("alertList");
            if (!container) return;

            // ========== MACHINE DATA ISOLATION ==========
            const currentMachine = machineData[selectedMachineId];

            // ========== GUARD: Only collect data if producer + machine are running ==========
            if (canCollectData()) {
              const allAlerts = data.alerts || [];
              // Filter alerts: only show if they mention enabled sensors for selected machine
              const enabledSensors = getEnabledSensors();
              const filteredAlerts = allAlerts.filter(alert => {
                // Check if alert message mentions any enabled sensor
                const message = (alert.message || '').toLowerCase();
                return enabledSensors.some(sensor =>
                  message.includes(sensor.toLowerCase()) ||
                  message.includes(sensor.replace(/_/g, ' ').toLowerCase())
                ) || enabledSensors.length === 0; // Show all if no sensors enabled (edge case)
              });

              // Store alerts in machine-specific buffer (accumulate unique alerts by ID)
              const existingIds = new Set(currentMachine.alerts.map(a => a.id));
              filteredAlerts.forEach(alert => {
                if (!existingIds.has(alert.id)) {
                  currentMachine.alerts.unshift(alert);
                }
              });
              // Keep only last 50 alerts per machine
              currentMachine.alerts = currentMachine.alerts.slice(0, 50);
            }
            // ========== END GUARD ==========

            // Always render from machine-specific buffer
            const alerts = currentMachine.alerts;

            if (alerts.length === 0) {
              container.innerHTML =
                `<div style="text-align: center; color: #94a3b8; padding: 20px;">No alerts for Machine ${selectedMachineId} yet</div>`;
              return;
            }

            container.innerHTML = alerts
              .map((alert) => {
                const severity = (alert.severity || "info").toLowerCase();
                return `
                            <div class="alert-item">
                                <div>
                                    <div class="alert-type">${
                                      alert.alert_type
                                    }</div>
                                    <div class="alert-message">${
                                      alert.message
                                    }</div>
                                </div>
                                <div class="alert-meta">
                                    <span class="alert-badge ${severity}">${
                  alert.severity
                }</span>
                                    <div class="alert-time">${formatDateTime(
                                      alert.created_at
                                    )}</div>
                                </div>
                            </div>
                        `;
              })
              .join("");
          });
      }

      function setQuickTest() {
        document.getElementById("durationHours").value = 0;
        document.getElementById("durationMinutes").value = 2;
        document.getElementById("intervalSeconds").value = 10;
      }

      function setOneMin() {
        document.getElementById("durationHours").value = 0;
        document.getElementById("durationMinutes").value = 1;
        document.getElementById("intervalSeconds").value = 5;
      }

      function setOneHour() {
        document.getElementById("durationHours").value = 1;
        document.getElementById("durationMinutes").value = 0;
        document.getElementById("intervalSeconds").value = 30;
      }

      function setProduction() {
        document.getElementById("durationHours").value = 24;
        document.getElementById("durationMinutes").value = 0;
        document.getElementById("intervalSeconds").value = 30;
      }

      // ========== Anomaly Injection Functions ==========

      function toggleInjection() {
        const enabled = document.getElementById("injectionEnabled").checked;
        const interval =
          parseInt(document.getElementById("injectionInterval").value) || 30;

        fetch("/api/injection-settings", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ enabled, interval_minutes: interval }),
        })
          .then((r) => r.json())
          .then((data) => {
            updateInjectionStatus(data.settings);
          })
          .catch(console.error);
      }

      function updateInjectionInterval() {
        const interval =
          parseInt(document.getElementById("injectionInterval").value) || 30;
        const enabled = document.getElementById("injectionEnabled").checked;

        fetch("/api/injection-settings", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ enabled, interval_minutes: interval }),
        })
          .then((r) => r.json())
          .then((data) => {
            updateInjectionStatus(data.settings);
          })
          .catch(console.error);
      }

      function injectAnomalyNow(button) {
        button.disabled = true;
        button.innerHTML =
          '<span class="loading-spinner" style="width: 14px; height: 14px;"></span> Injecting...';

        fetch("/api/inject-anomaly", { method: "POST" })
          .then((r) => r.json())
          .then((data) => {
            if (data.success) {
              button.innerHTML = "âœ“ Injection Triggered!";
              button.style.background = "#10b981";
              setTimeout(() => {
                button.innerHTML = "âš¡ Inject Anomaly NOW";
                button.style.background =
                  "linear-gradient(135deg, #ef4444, #dc2626)";
                button.disabled = false;
              }, 2000);
            }
          })
          .catch((err) => {
            button.innerHTML = "âœ— Failed";
            button.disabled = false;
            setTimeout(() => {
              button.innerHTML = "âš¡ Inject Anomaly NOW";
            }, 2000);
          });
      }

      function updateInjectionStatus(settings) {
        const statusEl = document.getElementById("injectionStatus");
        if (!statusEl) return;

        if (settings && settings.enabled) {
          const nextTime = settings.next_injection_time
            ? new Date(settings.next_injection_time).toLocaleTimeString()
            : "calculating...";
          statusEl.innerHTML = `<span style="color: #f87171;">â—</span> Injection ENABLED - Every ${settings.interval_minutes} min. Next: ${nextTime}`;
          statusEl.style.borderColor = "rgba(239, 68, 68, 0.5)";
        } else {
          statusEl.innerHTML =
            "Injection disabled. Enable to schedule automatic anomalies.";
          statusEl.style.borderColor = "transparent";
        }
      }

      function loadInjectionSettings() {
        fetch("/api/injection-settings")
          .then((r) => r.json())
          .then((data) => {
            document.getElementById("injectionEnabled").checked = data.enabled;
            document.getElementById("injectionInterval").value =
              data.interval_minutes || 30;
            updateInjectionStatus(data);
          })
          .catch(console.error);
      }

      // ========== LSTM Prediction Functions ==========

      function loadLSTMStatus() {
        fetch("/api/lstm-status")
          .then((r) => r.json())
          .then((data) => {
            if (!data.available) {
              document.getElementById("lstmQualityText").textContent = "Not Available";
              document.getElementById("lstmStatusMessage").textContent = data.message || "LSTM not available";
              document.getElementById("lstmQualityBar").style.width = "0%";
              return;
            }

            if (!data.trained) {
              document.getElementById("lstmQualityText").textContent = "Not Trained";
              document.getElementById("lstmStatusMessage").textContent = data.message || "Model not trained";
              document.getElementById("lstmQualityBar").style.width = "0%";
              return;
            }

            // Update quality bar
            const quality = data.quality_score || 0;
            document.getElementById("lstmQualityPercent").textContent = quality.toFixed(0) + "%";
            document.getElementById("lstmQualityBar").style.width = quality + "%";
            document.getElementById("lstmQualityText").textContent = quality.toFixed(0) + "%";
            document.getElementById("lstmStatusMessage").textContent = data.message || "Model trained";

            // Color based on quality
            const bar = document.getElementById("lstmQualityBar");
            if (quality >= 80) {
              bar.style.background = "linear-gradient(90deg, #10b981, #059669)";
            } else if (quality >= 60) {
              bar.style.background = "linear-gradient(90deg, #f59e0b, #10b981)";
            } else {
              bar.style.background = "linear-gradient(90deg, #ef4444, #f59e0b)";
            }
          })
          .catch(console.error);
      }

      function loadLSTMPredictions() {
        fetch("/api/lstm-predictions")
          .then((r) => r.json())
          .then((data) => {
            // ========== MACHINE DATA ISOLATION ==========
            const currentMachine = machineData[selectedMachineId];

            if (!data.available || !data.trained) {
              // Store null prediction for this machine (only if collecting)
              if (canCollectData()) {
                currentMachine.lstmPredictions = null;
              }
              document.getElementById("lstmRiskScore").textContent = "N/A";
              document.getElementById("lstmConfidence").textContent = "N/A";
              document.getElementById("lstmPredictedWindow").textContent = "LSTM not trained";
              document.getElementById("lstmTrend").textContent = "N/A";
              document.getElementById("lstmSensors").textContent = "N/A";
              return;
            }

            const pred = data.current_prediction;

            // ========== GUARD: Only store prediction if producer + machine are running ==========
            if (canCollectData()) {
              // Store prediction in machine-specific buffer
              currentMachine.lstmPredictions = JSON.parse(JSON.stringify(pred));
            }
            // ========== END GUARD ==========

            // Risk score with color
            const riskScore = pred.risk_score || 0;
            const riskEl = document.getElementById("lstmRiskScore");
            riskEl.textContent = riskScore.toFixed(1) + "%";

            if (riskScore >= 70) {
              riskEl.style.color = "#ef4444";
            } else if (riskScore >= 40) {
              riskEl.style.color = "#f59e0b";
            } else {
              riskEl.style.color = "#10b981";
            }

            // Confidence
            const confidence = pred.confidence || 0;
            document.getElementById("lstmConfidence").textContent = (confidence * 100).toFixed(0) + "%";

            // Predicted window
            document.getElementById("lstmPredictedWindow").textContent = pred.predicted_window || "N/A";

            // Trend with emoji
            const trend = pred.trend || "unknown";
            let trendText = trend;
            if (trend === "increasing") {
              trendText = "ðŸ“ˆ Increasing (Risk Rising)";
            } else if (trend === "decreasing") {
              trendText = "ðŸ“‰ Decreasing (Risk Falling)";
            } else if (trend === "stable") {
              trendText = "âž¡ï¸ Stable";
            }
            document.getElementById("lstmTrend").textContent = trendText;

            // Contributing sensors - filter and order based on machineParameterConfig
            const allSensors = pred.contributing_sensors || [];
            const sensors = filterAndOrderSensors(allSensors);
            if (sensors.length > 0) {
              document.getElementById("lstmSensors").textContent = sensors.slice(0, 5).join(", ");
            } else {
              document.getElementById("lstmSensors").textContent = "None identified for Machine " + selectedMachineId;
            }

            // Display detailed sensor analysis - filter and order based on config
            const allSensorAnalyses = pred.sensor_analyses || [];
            const enabledSensorNames = new Set(getOrderedEnabledSensors());
            const sensorAnalyses = allSensorAnalyses.filter(analysis =>
              enabledSensorNames.has(analysis.sensor)
            );
            const analysisContainer = document.getElementById("lstmSensorAnalysisContainer");
            const analysisList = document.getElementById("lstmSensorAnalysisList");

            if (sensorAnalyses.length > 0) {
              analysisContainer.style.display = "block";
              analysisList.innerHTML = "";

              // Show top 5 most problematic sensors
              sensorAnalyses.slice(0, 5).forEach((sensor) => {
                const severityColors = {
                  'critical': '#ef4444',
                  'high': '#f59e0b',
                  'medium': '#eab308',
                  'low': '#10b981'
                };
                const severityEmojis = {
                  'critical': 'ðŸ”´',
                  'high': 'ðŸŸ ',
                  'medium': 'ðŸŸ¡',
                  'low': 'ðŸŸ¢'
                };

                const item = document.createElement("div");
                item.style.cssText = `
                  background: rgba(30, 41, 59, 0.5);
                  border-left: 3px solid ${severityColors[sensor.severity] || '#64748b'};
                  padding: 12px;
                  border-radius: 6px;
                `;

                const sensorName = document.createElement("div");
                sensorName.style.cssText = "font-weight: 600; color: #e2e8f0; margin-bottom: 6px; font-size: 14px;";
                sensorName.textContent = `${severityEmojis[sensor.severity] || 'âšª'} ${sensor.sensor} (${sensor.severity.toUpperCase()})`;
                item.appendChild(sensorName);

                const reason = document.createElement("div");
                reason.style.cssText = "font-size: 12px; color: #cbd5e1; margin-bottom: 4px; line-height: 1.4;";
                reason.textContent = sensor.reason;
                item.appendChild(reason);

                if (sensor.predicted_failure_reading) {
                  const failure = document.createElement("div");
                  failure.style.cssText = "font-size: 11px; color: #f59e0b; margin-top: 4px;";
                  failure.textContent = `âš ï¸ Predicted failure at reading: ${sensor.predicted_failure_reading}`;
                  item.appendChild(failure);
                }

                const trendInfo = document.createElement("div");
                trendInfo.style.cssText = "font-size: 11px; color: #94a3b8; margin-top: 4px;";
                const trendEmoji = sensor.trend === 'increasing' ? 'ðŸ“ˆ' : sensor.trend === 'decreasing' ? 'ðŸ“‰' : 'âž¡ï¸';
                trendInfo.textContent = `${trendEmoji} Trend: ${sensor.trend} (${sensor.trend_rate > 0 ? '+' : ''}${sensor.trend_rate.toFixed(2)} per reading) | Current: ${sensor.current_value.toFixed(2)}`;
                item.appendChild(trendInfo);

                analysisList.appendChild(item);
              });
            } else {
              analysisContainer.style.display = "none";
            }
          })
          .catch(console.error);
      }

      function generateFutureReport(button) {
        button.disabled = true;
        button.innerHTML = '<span class="loading-spinner" style="width: 16px; height: 16px;"></span> Generating...';

        fetch("/api/generate-future-report", { method: "POST" })
          .then((r) => {
            if (!r.ok) throw new Error("Failed to generate report");
            return r.blob();
          })
          .then((blob) => {
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `future_anomaly_report_${new Date().toISOString().split('T')[0]}.pdf`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);

            button.innerHTML = '<span>âœ“</span><span>Report Downloaded!</span>';
            button.style.background = "linear-gradient(135deg, #10b981, #059669)";
            setTimeout(() => {
              button.innerHTML = '<span>ðŸ“Š</span><span>Generate Future Anomaly Report (PDF)</span>';
              button.style.background = "linear-gradient(135deg, #8b5cf6, #7c3aed)";
              button.disabled = false;
            }, 3000);
          })
          .catch((err) => {
            console.error(err);
            button.innerHTML = '<span>âœ—</span><span>Failed</span>';
            button.style.background = "linear-gradient(135deg, #ef4444, #dc2626)";
            setTimeout(() => {
              button.innerHTML = '<span>ðŸ“Š</span><span>Generate Future Anomaly Report (PDF)</span>';
              button.style.background = "linear-gradient(135deg, #8b5cf6, #7c3aed)";
              button.disabled = false;
            }, 3000);
          });
      }

      // ========== ML Anomaly Detection Functions ==========

      function loadMLStats() {
        fetch("/api/ml-stats")
          .then((r) => r.json())
          .then((data) => {
            if (data.error) return;

            // ========== MACHINE DATA ISOLATION ==========
            const currentMachine = machineData[selectedMachineId];

            // ========== GUARD: Only update stats if producer + machine are running ==========
            if (canCollectData()) {
              // Use machine-specific anomaly buffer for stats calculation
              const machineAnomalies = currentMachine.anomalies || [];

              // Calculate machine-specific stats from buffer
              const totalAnomalies = machineAnomalies.length;

              // Calculate rate based on machine anomalies
              const recentAnomalies = machineAnomalies.filter(a => {
                const age = Date.now() - new Date(a.created_at).getTime();
                return age < 3600000; // Last hour
              }).length;
              const enabledSensors = getEnabledSensors();
              const enabledCount = enabledSensors.length;
              const recentRate = enabledCount > 0 ? (recentAnomalies / Math.max(1, enabledCount)) * 10 : 0;

              // Store in machine-specific buffer
              currentMachine.mlStats = {
                totalAnomalies: totalAnomalies,
                anomalyRate: recentRate,
                reportsGenerated: data.completed_reports || 0
              };
            }
            // ========== END GUARD ==========

            // Always render from machine buffer
            document.getElementById("mlTotalAnomalies").textContent = currentMachine.mlStats.totalAnomalies;
            document.getElementById("mlAnomalyRate").textContent = currentMachine.mlStats.anomalyRate.toFixed(1) + "%";
            document.getElementById("mlReportsGenerated").textContent = currentMachine.mlStats.reportsGenerated;
          })
          .catch(() => {});
      }

      function loadAnomalies() {
        fetch("/api/anomalies?limit=20&only_anomalies=true")
          .then((r) => r.json())
          .then((data) => {
            const container = document.getElementById("anomalyList");
            if (!container) return;

            // ========== MACHINE DATA ISOLATION ==========
            const currentMachine = machineData[selectedMachineId];

            // ========== GUARD: Only collect data if producer + machine are running ==========
            if (canCollectData()) {
              const allAnomalies = data.anomalies || [];
              // Filter to only show anomalies involving enabled sensors for selected machine
              const filteredAnomalies = allAnomalies.filter(anomaly =>
                anomalyInvolvesEnabledSensors(anomaly)
              );

              // Store anomalies in machine-specific buffer (accumulate unique by ID)
              const existingIds = new Set(currentMachine.anomalies.map(a => a.id));
              filteredAnomalies.forEach(anomaly => {
                if (!existingIds.has(anomaly.id)) {
                  currentMachine.anomalies.unshift(anomaly);
                }
              });
              // Keep only last 50 anomalies per machine
              currentMachine.anomalies = currentMachine.anomalies.slice(0, 50);
            }
            // ========== END GUARD ==========

            // Always render from machine-specific buffer
            const anomalies = currentMachine.anomalies;

            if (anomalies.length === 0) {
              container.innerHTML = `
                            <div style="text-align: center; color: #94a3b8; padding: 40px;">
                                No ML anomalies detected for Machine ${selectedMachineId} yet. Start the pipeline to begin monitoring.
                            </div>
                        `;
              return;
            }

            container.innerHTML = anomalies
              .map((anomaly) => {
                // Filter and order detected sensors based on machineParameterConfig
                const allSensors = anomaly.detected_sensors || [];
                const sensors = filterAndOrderSensors(allSensors);
                const sensorTags = sensors
                  .slice(0, 5)
                  .map((s) => `<span>${s.replace(/_/g, " ")}</span>`)
                  .join("");
                const moreSensors =
                  sensors.length > 5
                    ? `<span>+${sensors.length - 5} more</span>`
                    : "";

                let actionBtn = "";
                if (
                  anomaly.report_id &&
                  anomaly.report_status === "completed"
                ) {
                  actionBtn = `
                                <button class="btn-report btn-view-report" onclick="viewReport(${anomaly.report_id})">
                                    ðŸ“„ View Report
                                </button>
                            `;
                } else if (anomaly.report_status === "generating") {
                  actionBtn = `
                                <button class="btn-report" disabled>
                                    <span class="loading-spinner"></span> Generating...
                                </button>
                            `;
                } else {
                  actionBtn = `
                                <button class="btn-report" onclick="generateReport(${anomaly.id}, this)">
                                    ðŸ¤– Generate Report
                                </button>
                            `;
                }

                return `
                            <div class="anomaly-item">
                                <div class="anomaly-info">
                                    <div class="anomaly-header">
                                        <span class="anomaly-score">Score: ${anomaly.anomaly_score.toFixed(
                                          4
                                        )}</span>
                                        <span class="anomaly-method">${
                                          anomaly.detection_method
                                        }</span>
                                    </div>
                                    <div class="anomaly-timestamp">${formatDateTime(
                                      anomaly.created_at
                                    )}</div>
                                    <div class="anomaly-sensors">
                                        <strong>Contributing sensors:</strong><br>
                                        ${sensorTags}${moreSensors}
                                    </div>
                                </div>
                                <div class="anomaly-actions">
                                    ${actionBtn}
                                </div>
                            </div>
                        `;
              })
              .join("");
          })
          .catch(() => {});
      }

      function generateReport(anomalyId, button) {
        if (button) {
          button.disabled = true;
          button.innerHTML =
            '<span class="loading-spinner"></span> Generating...';
        }

        fetch(`/api/generate-report/${anomalyId}`, { method: "POST" })
          .then((r) => r.json())
          .then((result) => {
            if (result.success) {
              alert("âœ… Report generated successfully!");
              loadAnomalies();
              loadMLStats();
              viewReport(result.report_id);
            } else {
              alert(
                "âŒ Failed to generate report: " +
                  (result.error || "Unknown error")
              );
              if (button) {
                button.disabled = false;
                button.innerHTML = "ðŸ¤– Generate Report";
              }
            }
          })
          .catch((err) => {
            alert("âŒ Error generating report");
            if (button) {
              button.disabled = false;
              button.innerHTML = "ðŸ¤– Generate Report";
            }
          });
      }

      // Store current report for download
      let currentReport = null;

      function viewReport(reportId) {
        const modal = document.getElementById("reportModal");
        const content = document.getElementById("reportContent");
        const downloadBtn = document.getElementById("downloadReportBtn");

        modal.style.display = "flex";
        downloadBtn.style.display = "none"; // Hide until loaded
        content.innerHTML =
          '<div style="text-align: center; padding: 40px;"><span class="loading-spinner" style="width: 40px; height: 40px; border-width: 3px;"></span><p style="margin-top: 16px;">Loading report...</p></div>';

        fetch(`/api/reports/${reportId}`)
          .then((r) => r.json())
          .then((report) => {
            if (report.error) {
              content.innerHTML = `<div style="color: #ef4444; text-align: center; padding: 40px;">${report.error}</div>`;
              return;
            }

            // Store report for download
            currentReport = report;
            downloadBtn.style.display = "inline-flex"; // Show download button

            // Format the report
            const analysis = report.chatgpt_analysis || "No analysis available";

            content.innerHTML = `
                        <div class="report-meta">
                            <div class="report-meta-item">
                                <div class="report-meta-label">Report ID</div>
                                <div class="report-meta-value">#${
                                  report.id
                                }</div>
                            </div>
                            <div class="report-meta-item">
                                <div class="report-meta-label">Anomaly ID</div>
                                <div class="report-meta-value">#${
                                  report.anomaly_id
                                }</div>
                            </div>
                            <div class="report-meta-item">
                                <div class="report-meta-label">Generated</div>
                                <div class="report-meta-value">${formatDateTime(
                                  report.completed_at || report.created_at
                                )}</div>
                            </div>
                            <div class="report-meta-item">
                                <div class="report-meta-label">Status</div>
                                <div class="report-meta-value" style="color: ${
                                  report.status === "completed"
                                    ? "#10b981"
                                    : "#f59e0b"
                                }">${report.status.toUpperCase()}</div>
                            </div>
                        </div>
                        <div class="report-analysis">
                            ${formatMarkdown(analysis)}
                        </div>
                    `;
          })
          .catch((err) => {
            content.innerHTML = `<div style="color: #ef4444; text-align: center; padding: 40px;">Failed to load report</div>`;
          });
      }

      function downloadCurrentReport() {
        if (!currentReport) {
          alert("No report loaded to download");
          return;
        }

        const report = currentReport;
        
        // Show loading indicator
        const downloadBtn = document.getElementById("downloadReportBtn");
        const originalText = downloadBtn.innerHTML;
        downloadBtn.disabled = true;
        downloadBtn.innerHTML = "â³ Generating PDF...";
        
        // Call the server-side PDF generation endpoint
        fetch(`/api/reports/${report.id}/pdf`)
          .then(response => {
            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.blob();
          })
          .then(blob => {
            // Create a download link
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = `anomaly_report_${report.id}_${new Date().toISOString().slice(0, 10)}.pdf`;
            document.body.appendChild(a);
            a.click();
            
            // Cleanup
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
            
            downloadBtn.disabled = false;
            downloadBtn.innerHTML = originalText;
          })
          .catch(err => {
            console.error('PDF download error:', err);
            alert('Error downloading PDF: ' + err.message);
            downloadBtn.disabled = false;
            downloadBtn.innerHTML = originalText;
          });
      }

      function closeReportModal() {
        document.getElementById("reportModal").style.display = "none";
      }

      function closeFullReportModal() {
        document.getElementById("fullReportModal").style.display = "none";
      }

      function generateFullSessionReport(button) {
        // Show modal immediately with loading state
        document.getElementById("fullReportModal").style.display = "flex";
        const content = document.getElementById("fullReportContent");
        content.innerHTML = `
                <div style="text-align: center; padding: 60px;">
                    <div class="loading-spinner" style="width: 48px; height: 48px; margin: 0 auto 20px;"></div>
                    <p style="color: #94a3b8; font-size: 16px;">Analyzing all anomalies with AI...</p>
                    <p style="color: #64748b; font-size: 14px;">This may take 30-60 seconds for comprehensive analysis.</p>
                </div>
            `;

        // Disable button
        if (button) {
          button.disabled = true;
          button.innerHTML =
            '<span class="loading-spinner" style="width: 16px; height: 16px;"></span> Generating...';
        }

        fetch("/api/generate-full-report", { method: "POST" })
          .then((r) => r.json())
          .then((result) => {
            if (result.success) {
              displayFullSessionReport(result);
            } else {
              content.innerHTML = `
                            <div style="text-align: center; padding: 40px; color: #ef4444;">
                                <h3>Failed to Generate Report</h3>
                                <p>${
                                  result.error || "Unknown error occurred"
                                }</p>
                            </div>
                        `;
            }
          })
          .catch((err) => {
            content.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #ef4444;">
                            <h3>Connection Error</h3>
                            <p>${err.message}</p>
                        </div>
                    `;
          })
          .finally(() => {
            if (button) {
              button.disabled = false;
              button.innerHTML = "ðŸ“Š Generate Full Session Report";
            }
          });
      }

      function displayFullSessionReport(result) {
        const content = document.getElementById("fullReportContent");
        const stats = result.stats || {};
        const corrs = result.correlations || {};

        let html = `
                <style>
                    .report-stats-grid {
                        display: grid;
                        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
                        gap: 12px;
                        margin-bottom: 24px;
                    }
                    .report-stat-box {
                        background: rgba(15, 23, 42, 0.6);
                        padding: 16px;
                        border-radius: 8px;
                        text-align: center;
                        border: 1px solid rgba(148, 163, 184, 0.2);
                    }
                    .report-stat-value {
                        font-size: 24px;
                        font-weight: 700;
                        color: #10b981;
                    }
                    .report-stat-label {
                        font-size: 12px;
                        color: #94a3b8;
                        margin-top: 4px;
                    }
                    .severity-critical { color: #ef4444; }
                    .severity-high { color: #f97316; }
                    .severity-medium { color: #eab308; }
                    .severity-low { color: #22c55e; }
                    .cooccurrence-item {
                        display: flex;
                        align-items: center;
                        gap: 12px;
                        padding: 12px 16px;
                        background: rgba(15, 23, 42, 0.6);
                        border-radius: 8px;
                        margin-bottom: 8px;
                        border: 1px solid rgba(148, 163, 184, 0.15);
                    }
                    .cooccurrence-sensors {
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        flex: 1;
                    }
                    .cooccurrence-sensor {
                        background: linear-gradient(135deg, rgba(96, 165, 250, 0.2), rgba(139, 92, 246, 0.2));
                        color: #a5b4fc;
                        padding: 6px 12px;
                        border-radius: 6px;
                        font-size: 13px;
                        font-weight: 600;
                    }
                    .cooccurrence-arrow {
                        color: #64748b;
                        font-size: 16px;
                    }
                    .cooccurrence-count {
                        background: rgba(16, 185, 129, 0.2);
                        color: #10b981;
                        padding: 4px 10px;
                        border-radius: 12px;
                        font-size: 12px;
                        font-weight: 700;
                    }
                    .report-actions {
                        display: flex;
                        gap: 12px;
                        margin-bottom: 24px;
                    }
                    .btn-download-pdf {
                        background: linear-gradient(135deg, #3b82f6, #1d4ed8);
                        color: white;
                        border: none;
                        padding: 12px 24px;
                        border-radius: 8px;
                        font-size: 14px;
                        font-weight: 600;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                        transition: all 0.2s;
                    }
                    .btn-download-pdf:hover {
                        transform: translateY(-2px);
                        box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
                    }
                    .sensor-tag {
                        display: inline-block;
                        background: rgba(59, 130, 246, 0.2);
                        color: #60a5fa;
                        padding: 4px 8px;
                        border-radius: 4px;
                        font-size: 12px;
                        margin: 2px;
                    }
                    .analysis-content {
                        background: rgba(15, 23, 42, 0.4);
                        padding: 24px;
                        border-radius: 12px;
                        border: 1px solid rgba(148, 163, 184, 0.2);
                        line-height: 1.6;
                    }
                    .analysis-content h3 {
                        color: #10b981;
                        border-bottom: 1px solid rgba(148, 163, 184, 0.2);
                        padding-bottom: 8px;
                        margin-top: 20px;
                    }
                    .analysis-content ul {
                        margin-left: 20px;
                    }
                    .analysis-content li {
                        margin-bottom: 8px;
                    }
                </style>
                
                <div style="background: rgba(96, 165, 250, 0.1); border: 1px solid rgba(96, 165, 250, 0.3); border-radius: 8px; padding: 12px; margin-bottom: 20px; text-align: center;">
                    <p style="color: #60a5fa; font-weight: 600; font-size: 14px; margin: 0;">
                        ðŸ“Š Report for Machine ${selectedMachineId} (Filtered by enabled sensors)
                    </p>
                </div>
                
                <div class="report-actions">
                    <button class="btn-download-pdf" onclick="downloadReportAsPDF()">
                        ðŸ“„ Download PDF Report
                    </button>
                    <p style="color: #64748b; font-size: 14px; margin: auto 0;">Generated: ${
                      result.generated_at || new Date().toISOString()
                    }</p>
                </div>
                
                <div class="report-stats-grid">
                    <div class="report-stat-box">
                        <div class="report-stat-value">${(
                          stats.total_readings || 0
                        ).toLocaleString()}</div>
                        <div class="report-stat-label">Total Readings</div>
                    </div>
                    <div class="report-stat-box">
                        <div class="report-stat-value" style="color: #ef4444;">${
                          stats.total_anomalies || 0
                        }</div>
                        <div class="report-stat-label">Anomalies</div>
                    </div>
                    <div class="report-stat-box">
                        <div class="report-stat-value">${
                          stats.anomaly_rate || 0
                        }%</div>
                        <div class="report-stat-label">Anomaly Rate</div>
                    </div>
                    <div class="report-stat-box">
                        <div class="report-stat-value severity-critical">${
                          stats.severity_distribution?.critical || 0
                        }</div>
                        <div class="report-stat-label">Critical</div>
                    </div>
                    <div class="report-stat-box">
                        <div class="report-stat-value severity-high">${
                          stats.severity_distribution?.high || 0
                        }</div>
                        <div class="report-stat-label">High</div>
                    </div>
                    <div class="report-stat-box">
                        <div class="report-stat-value severity-medium">${
                          stats.severity_distribution?.medium || 0
                        }</div>
                        <div class="report-stat-label">Medium</div>
                    </div>
                    <div class="report-stat-box">
                        <div class="report-stat-value severity-low">${
                          stats.severity_distribution?.low || 0
                        }</div>
                        <div class="report-stat-label">Low</div>
                    </div>
                </div>
            `;

        // Top sensors
        if (stats.top_anomaly_sensors && stats.top_anomaly_sensors.length > 0) {
          html += `<h3 style="color: #e2e8f0; margin-bottom: 12px;">ðŸŽ¯ Top Anomaly-Contributing Sensors</h3>
                         <div style="margin-bottom: 24px;">`;
          stats.top_anomaly_sensors.forEach((s) => {
            html += `<span class="sensor-tag">${s.sensor}: ${s.count}x</span>`;
          });
          html += `</div>`;
        }

        // Sensor Co-occurrences
        const cooccurrences = corrs.sensor_co_occurrences || [];
        if (cooccurrences.length > 0) {
          html += `<h3 style="color: #e2e8f0; margin-bottom: 12px;">ðŸ”— Sensor Co-occurrences</h3>
                   <p style="color: #94a3b8; font-size: 13px; margin-bottom: 16px;">
                       Sensors that frequently trigger anomalies together - may indicate related system issues
                   </p>
                   <div style="margin-bottom: 24px;">`;
          cooccurrences.slice(0, 10).forEach((c) => {
            const sensors = c.sensors || [];
            html += `<div class="cooccurrence-item">
                        <div class="cooccurrence-sensors">
                            <span class="cooccurrence-sensor">${
                              sensors[0] || "Unknown"
                            }</span>
                            <span class="cooccurrence-arrow">â†”</span>
                            <span class="cooccurrence-sensor">${
                              sensors[1] || "Unknown"
                            }</span>
                        </div>
                        <span class="cooccurrence-count">${
                          c.count
                        }x together</span>
                     </div>`;
          });
          html += `</div>`;
        }

        // AI Analysis
        html += `<h3 style="color: #e2e8f0; margin-bottom: 12px;">ðŸ¤– AI Analysis</h3>
                     <div class="analysis-content">
                         ${formatMarkdown(
                           result.analysis || "No analysis available."
                         )}
                     </div>`;

        // Store for PDF export
        window.currentFullReport = { result, stats, corrs };

        content.innerHTML = html;
      }

      // PDF Download function
      function downloadReportAsPDF() {
        const report = window.currentFullReport;
        if (!report) {
          alert("No report data available");
          return;
        }

        const { result, stats, corrs } = report;
        const cooccurrences = corrs.sensor_co_occurrences || [];

        // Build text content for PDF
        let textContent = `SENSOR DATA PIPELINE - FULL SESSION ANALYSIS REPORT
${"=".repeat(60)}

Generated: ${result.generated_at || new Date().toISOString()}

SESSION STATISTICS
${"-".repeat(40)}
Total Readings:    ${(stats.total_readings || 0).toLocaleString()}
Total Anomalies:   ${stats.total_anomalies || 0}
Anomaly Rate:      ${stats.anomaly_rate || 0}%

SEVERITY DISTRIBUTION
${"-".repeat(40)}
Critical:  ${stats.severity_distribution?.critical || 0}
High:      ${stats.severity_distribution?.high || 0}
Medium:    ${stats.severity_distribution?.medium || 0}
Low:       ${stats.severity_distribution?.low || 0}

TOP ANOMALY-CONTRIBUTING SENSORS
${"-".repeat(40)}
`;

        if (stats.top_anomaly_sensors && stats.top_anomaly_sensors.length > 0) {
          stats.top_anomaly_sensors.forEach((s, i) => {
            textContent += `${i + 1}. ${s.sensor}: ${s.count} occurrences\n`;
          });
        } else {
          textContent += "No sensor data available\n";
        }

        textContent += `
SENSOR CO-OCCURRENCES
${"-".repeat(40)}
`;
        if (cooccurrences.length > 0) {
          cooccurrences.slice(0, 15).forEach((c, i) => {
            const sensors = c.sensors || [];
            textContent += `${i + 1}. ${sensors[0]} <-> ${sensors[1]}: ${
              c.count
            } times together\n`;
          });
        } else {
          textContent += "No co-occurrence data available\n";
        }

        textContent += `
AI ANALYSIS
${"-".repeat(40)}
${result.analysis || "No analysis available"}

${"=".repeat(60)}
Report generated by Sensor Data Pipeline Dashboard
`;

        // Create and download as text file (works without external libraries)
        const blob = new Blob([textContent], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `sensor_report_${new Date()
          .toISOString()
          .slice(0, 10)}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      // Close modal on escape key or clicking outside
      document.addEventListener("keydown", function (e) {
        if (e.key === "Escape") {
          closeReportModal();
          closeFullReportModal();
        }
      });

      document
        .getElementById("reportModal")
        ?.addEventListener("click", function (e) {
          if (e.target === this) closeReportModal();
        });

      document
        .getElementById("fullReportModal")
        ?.addEventListener("click", function (e) {
          if (e.target === this) closeFullReportModal();
        });

      // Markdown formatter for PDF (light theme, print-friendly)
      function formatMarkdownForPDF(text) {
        if (!text) return "";

        // Escape HTML first
        text = text.replace(/</g, "&lt;").replace(/>/g, "&gt;");

        // Process code blocks (```...```) before other processing
        const codeBlocks = [];
        text = text.replace(/```([^`]+)```/g, (match, code) => {
          const index = codeBlocks.length;
          codeBlocks.push(`<pre style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 6px; padding: 15px; overflow-x: auto; margin: 15px 0;"><code style="background: none; padding: 0; color: #059669; font-family: 'Courier New', monospace; font-size: 13px;">${code.trim()}</code></pre>`);
          return `__CODEBLOCK_${index}__`;
        });

        // Process inline code (`...`)
        text = text.replace(/`([^`]+)`/g, '<code style="background: #f1f5f9; color: #059669; padding: 2px 6px; border-radius: 4px; font-family: \'Courier New\', monospace; font-size: 13px;">$1</code>');

        // Headers (process in order: h3, h2, h1 to avoid conflicts)
        text = text.replace(/^### (.*$)/gm, '<h3 style="color: #059669; font-size: 18px; margin-top: 30px; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 2px solid #d1fae5;">$1</h3>');
        text = text.replace(/^## (.*$)/gm, '<h3 style="color: #059669; font-size: 20px; margin-top: 30px; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 2px solid #d1fae5;">$1</h3>');
        text = text.replace(/^# (.*$)/gm, '<h3 style="color: #059669; font-size: 22px; margin-top: 30px; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 2px solid #d1fae5;">$1</h3>');

        // Bold (process before italic to handle ** vs *)
        text = text.replace(/\*\*(.*?)\*\*/g, '<strong style="color: #1e40af; font-weight: 700;">$1</strong>');

        // Italic
        text = text.replace(/\*([^*]+)\*/g, '<em style="color: #92400e; font-style: italic;">$1</em>');

        // Horizontal rules
        text = text.replace(/^---+$/gm, '<hr style="border: none; border-top: 1px solid #e2e8f0; margin: 20px 0;">');

        // Lists - handle multi-level indentation
        text = text.replace(/^(\s*)- (.*$)/gm, (match, indent, content) => {
          const level = indent.length / 2;
          return `<li style="margin-bottom: 10px; line-height: 1.7;">${content}</li>`;
        });
        
        // Wrap lists in ul tags
        text = text.replace(/(<li[^>]*>.*<\/li>\n?)+/g, (match) => {
          return `<ul style="margin-left: 25px; margin-bottom: 15px;">${match}</ul>`;
        });

        // Numbered lists
        text = text.replace(/^(\s*)\d+\. (.*$)/gm, (match, indent, content) => {
          return `<li style="margin-bottom: 10px; line-height: 1.7;">${content}</li>`;
        });
        text = text.replace(/(<li>.*<\/li>\n?)+/g, (match) => {
          // Only wrap if not already wrapped in ul
          if (!match.includes('<ul>')) {
            return `<ol style="margin-left: 25px; margin-bottom: 15px;">${match}</ol>`;
          }
          return match;
        });

        // Paragraphs and line breaks
        text = text.replace(/\n\n+/g, "</p><p style='margin-bottom: 15px; line-height: 1.8;'>");
        text = text.replace(/\n/g, "<br>");

        // Wrap in paragraph tags
        text = "<p style='margin-bottom: 15px; line-height: 1.8;'>" + text + "</p>";

        // Clean up empty paragraphs
        text = text.replace(/<p[^>]*><\/p>/g, "");
        text = text.replace(/<p[^>]*>\s*<\/p>/g, "");

        // Restore code blocks
        codeBlocks.forEach((block, index) => {
          text = text.replace(`__CODEBLOCK_${index}__`, block);
        });

        return text;
      }

      // Enhanced markdown formatter (for screen display)
      function formatMarkdown(text) {
        if (!text) return "";

        // Escape HTML first
        text = text.replace(/</g, "&lt;").replace(/>/g, "&gt;");

        // Process code blocks (```...```) before other processing
        const codeBlocks = [];
        text = text.replace(/```([^`]+)```/g, (match, code) => {
          const index = codeBlocks.length;
          codeBlocks.push(`<pre><code>${code.trim()}</code></pre>`);
          return `__CODEBLOCK_${index}__`;
        });

        // Process inline code (`...`)
        text = text.replace(/`([^`]+)`/g, "<code>$1</code>");

        // Headers (process in order: h3, h2, h1 to avoid conflicts)
        text = text.replace(/^### (.*$)/gm, "<h3>$1</h3>");
        text = text.replace(/^## (.*$)/gm, '<h3 style="font-size: 18px;">$1</h3>');
        text = text.replace(/^# (.*$)/gm, '<h3 style="font-size: 20px;">$1</h3>');

        // Bold (process before italic to handle ** vs *)
        text = text.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>");

        // Italic
        text = text.replace(/\*([^*]+)\*/g, "<em>$1</em>");

        // Horizontal rules
        text = text.replace(/^---+$/gm, '<hr style="border: none; border-top: 1px solid rgba(148, 163, 184, 0.2); margin: 20px 0;">');

        // Lists - handle multi-level indentation
        text = text.replace(/^(\s*)- (.*$)/gm, (match, indent, content) => {
          const level = indent.length / 2;
          return `<li data-level="${level}">${content}</li>`;
        });
        
        // Wrap lists in ul tags
        text = text.replace(/(<li[^>]*>.*<\/li>\n?)+/g, (match) => {
          return `<ul>${match}</ul>`;
        });

        // Numbered lists
        text = text.replace(/^(\s*)\d+\. (.*$)/gm, (match, indent, content) => {
          return `<li>${content}</li>`;
        });
        text = text.replace(/(<li>.*<\/li>\n?)+/g, (match) => {
          // Only wrap if not already wrapped in ul
          if (!match.includes('<ul>')) {
            return `<ol>${match}</ol>`;
          }
          return match;
        });

        // Paragraphs and line breaks
        text = text.replace(/\n\n+/g, "</p><p>");
        text = text.replace(/\n/g, "<br>");

        // Wrap in paragraph tags
        text = "<p>" + text + "</p>";

        // Clean up empty paragraphs
        text = text.replace(/<p><\/p>/g, "");
        text = text.replace(/<p>\s*<\/p>/g, "");

        // Restore code blocks
        codeBlocks.forEach((block, index) => {
          text = text.replace(`__CODEBLOCK_${index}__`, block);
        });

        return text;
      }

      // Auto-refresh every 2 seconds (for stats, alerts, ML, etc. - NOT Live Sensor Readings)
      setInterval(() => {
        updateStats();
        updateStatus();
        loadAlerts();
        loadMLStats();
        loadAnomalies();
        loadLSTMPredictions();
      }, 2000);

      // Initial load
      loadHiddenSensors();
      initializeMachineState(); // Initialize machine sensor state (after sensorsByCategory is defined)
      updateStats();
      updateStatus();
      loadConfig();
      loadAlerts();
      loadMLStats();
      loadAnomalies();
      loadInjectionSettings();
      loadLSTMStatus();
      loadLSTMPredictions();
      
      // Load custom sensors and merge into unified registry
      loadCustomSensors();
      
      // Initialize Live Sensor Readings timer with default 10s interval
      setRefreshRate(10000);
      
      // ============================================================================
      // CUSTOM SENSOR MANAGEMENT FUNCTIONS (Phase 5)
      // ============================================================================
      
      function loadCustomSensors() {
        fetch('/api/admin/custom-sensors')
          .then(response => response.json())
          .then(data => {
            if (data.error) {
              document.getElementById('customSensorsList').innerHTML = 
                `<div style="text-align: center; color: #ef4444; padding: 20px;">Error: ${data.error}</div>`;
              return;
            }
            
            const sensors = data.sensors || [];
            
            // Merge custom sensors into unified registry
            mergeCustomSensors(sensors);
            
            // Refresh UI to show custom sensors
            updateStats();
            updateLiveSensorReadings();
            if (currentMode === 'admin') {
              renderAdminSensorList();
            }
            
            // Update admin panel custom sensors list
            const container = document.getElementById('customSensorsList');
            if (!container) return;
            
            if (sensors.length === 0) {
              container.innerHTML = 
                '<div style="text-align: center; color: #94a3b8; padding: 20px;">No custom sensors defined yet. Add one above to get started.</div>';
              return;
            }
            
            let html = '<div style="display: grid; gap: 12px;">';
            sensors.forEach(sensor => {
              const statusClass = sensor.is_active ? 'active' : 'inactive';
              const statusText = sensor.is_active ? 'Active' : 'Inactive';
              const statusColor = sensor.is_active ? '#10b981' : '#ef4444';
              
              html += `
                <div style="background: rgba(15, 23, 42, 0.6); padding: 16px; border-radius: 8px; border: 1px solid rgba(148, 163, 184, 0.1);">
                  <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 12px;">
                    <div>
                      <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                        <strong style="color: #60a5fa; font-size: 16px;">${sensor.sensor_name}</strong>
                        <span style="padding: 2px 8px; background: ${statusColor}; color: white; border-radius: 4px; font-size: 11px; font-weight: 600;">${statusText}</span>
                        <span style="color: #94a3b8; font-size: 12px;">${sensor.category}</span>
                      </div>
                      <div style="color: #94a3b8; font-size: 12px; margin-top: 4px;">
                        Range: ${sensor.min_range} - ${sensor.max_range} ${sensor.unit || ''}
                        ${sensor.low_threshold !== null ? `| Low: ${sensor.low_threshold}` : ''}
                        ${sensor.high_threshold !== null ? `| High: ${sensor.high_threshold}` : ''}
                      </div>
                    </div>
                    <div style="display: flex; gap: 8px;">
                      <button onclick="editCustomSensor(${sensor.id})" 
                              style="padding: 6px 12px; background: rgba(96, 165, 250, 0.2); color: #60a5fa; border: 1px solid rgba(96, 165, 250, 0.3); border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600;">
                        âœï¸ Edit
                      </button>
                      ${sensor.is_active ? 
                        `<button onclick="deleteCustomSensor(${sensor.id}, '${sensor.sensor_name}')" 
                                style="padding: 6px 12px; background: rgba(239, 68, 68, 0.2); color: #ef4444; border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600;">
                          ðŸ—‘ï¸ Deactivate
                        </button>` :
                        `<button onclick="activateCustomSensor(${sensor.id})" 
                                style="padding: 6px 12px; background: rgba(16, 185, 129, 0.2); color: #10b981; border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600;">
                          âœ… Activate
                        </button>`
                      }
                    </div>
                  </div>
                </div>
              `;
            });
            html += '</div>';
            container.innerHTML = html;
          })
          .catch(error => {
            console.error('Error loading custom sensors:', error);
            document.getElementById('customSensorsList').innerHTML = 
              `<div style="text-align: center; color: #ef4444; padding: 20px;">Error loading custom sensors: ${error.message}</div>`;
          });
      }
      
      function addCustomSensor() {
        const sensorName = document.getElementById('newSensorName').value.trim();
        const category = document.getElementById('newSensorCategory').value;
        const unit = document.getElementById('newSensorUnit').value.trim();
        const minRange = parseFloat(document.getElementById('newSensorMinRange').value);
        const maxRange = parseFloat(document.getElementById('newSensorMaxRange').value);
        const lowThreshold = document.getElementById('newSensorLowThreshold').value.trim();
        const highThreshold = document.getElementById('newSensorHighThreshold').value.trim();
        
        const messageDiv = document.getElementById('customSensorMessage');
        messageDiv.innerHTML = '';
        messageDiv.style.color = '';
        
        // Validation
        if (!sensorName) {
          messageDiv.innerHTML = '<span style="color: #ef4444;">âš ï¸ Sensor name is required</span>';
          return;
        }
        
        if (isNaN(minRange) || isNaN(maxRange)) {
          messageDiv.innerHTML = '<span style="color: #ef4444;">âš ï¸ Min and max range are required and must be numbers</span>';
          return;
        }
        
        if (minRange >= maxRange) {
          messageDiv.innerHTML = '<span style="color: #ef4444;">âš ï¸ Min range must be less than max range</span>';
          return;
        }
        
        const payload = {
          sensor_name: sensorName,
          category: category,
          unit: unit,
          min_range: minRange,
          max_range: maxRange
        };
        
        if (lowThreshold) {
          const low = parseFloat(lowThreshold);
          if (!isNaN(low)) {
            payload.low_threshold = low;
          }
        }
        
        if (highThreshold) {
          const high = parseFloat(highThreshold);
          if (!isNaN(high)) {
            payload.high_threshold = high;
          }
        }
        
        fetch('/api/admin/custom-sensors', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(payload)
        })
          .then(response => response.json())
          .then(data => {
            if (data.error) {
              messageDiv.innerHTML = `<span style="color: #ef4444;">âŒ Error: ${data.error}</span>`;
            } else {
              messageDiv.innerHTML = '<span style="color: #10b981;">âœ… Custom sensor added successfully! Producer will start emitting it on next config reload.</span>';
              // Clear form
              document.getElementById('newSensorName').value = '';
              document.getElementById('newSensorCategory').value = 'custom';
              document.getElementById('newSensorUnit').value = '';
              document.getElementById('newSensorMinRange').value = '';
              document.getElementById('newSensorMaxRange').value = '';
              document.getElementById('newSensorLowThreshold').value = '';
              document.getElementById('newSensorHighThreshold').value = '';
              // Reload list and refresh UI
              setTimeout(() => {
                loadCustomSensors(); // This will merge into unified registry and refresh UI
              }, 500);
            }
          })
          .catch(error => {
            console.error('Error adding custom sensor:', error);
            messageDiv.innerHTML = `<span style="color: #ef4444;">âŒ Error: ${error.message}</span>`;
          });
      }
      
      function editCustomSensor(sensorId) {
        fetch(`/api/admin/custom-sensors/${sensorId}`)
          .then(response => response.json())
          .then(data => {
            if (data.error) {
              alert(`Error: ${data.error}`);
              return;
            }
            
            // Populate form with sensor data
            document.getElementById('newSensorName').value = data.sensor_name;
            document.getElementById('newSensorCategory').value = data.category || 'custom';
            document.getElementById('newSensorUnit').value = data.unit || '';
            document.getElementById('newSensorMinRange').value = data.min_range;
            document.getElementById('newSensorMaxRange').value = data.max_range;
            document.getElementById('newSensorLowThreshold').value = data.low_threshold || '';
            document.getElementById('newSensorHighThreshold').value = data.high_threshold || '';
            
            // Change button to "Update" mode
            const addButton = document.querySelector('button[onclick="addCustomSensor()"]');
            const originalOnClick = addButton.getAttribute('onclick');
            addButton.textContent = 'ðŸ’¾ Update Sensor';
            addButton.setAttribute('onclick', `updateCustomSensor(${sensorId})`);
            addButton.setAttribute('data-original-onclick', originalOnClick);
            
            // Scroll to form
            document.getElementById('newSensorName').scrollIntoView({ behavior: 'smooth', block: 'center' });
            document.getElementById('newSensorName').focus();
          })
          .catch(error => {
            console.error('Error loading sensor for edit:', error);
            alert(`Error: ${error.message}`);
          });
      }
      
      function updateCustomSensor(sensorId) {
        const category = document.getElementById('newSensorCategory').value;
        const unit = document.getElementById('newSensorUnit').value.trim();
        const minRange = parseFloat(document.getElementById('newSensorMinRange').value);
        const maxRange = parseFloat(document.getElementById('newSensorMaxRange').value);
        const lowThreshold = document.getElementById('newSensorLowThreshold').value.trim();
        const highThreshold = document.getElementById('newSensorHighThreshold').value.trim();
        
        const messageDiv = document.getElementById('customSensorMessage');
        messageDiv.innerHTML = '';
        
        if (isNaN(minRange) || isNaN(maxRange)) {
          messageDiv.innerHTML = '<span style="color: #ef4444;">âš ï¸ Min and max range must be numbers</span>';
          return;
        }
        
        if (minRange >= maxRange) {
          messageDiv.innerHTML = '<span style="color: #ef4444;">âš ï¸ Min range must be less than max range</span>';
          return;
        }
        
        const payload = {
          category: category,
          unit: unit,
          min_range: minRange,
          max_range: maxRange
        };
        
        if (lowThreshold) {
          const low = parseFloat(lowThreshold);
          if (!isNaN(low)) {
            payload.low_threshold = low;
          } else {
            payload.low_threshold = null;
          }
        } else {
          payload.low_threshold = null;
        }
        
        if (highThreshold) {
          const high = parseFloat(highThreshold);
          if (!isNaN(high)) {
            payload.high_threshold = high;
          } else {
            payload.high_threshold = null;
          }
        } else {
          payload.high_threshold = null;
        }
        
        fetch(`/api/admin/custom-sensors/${sensorId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(payload)
        })
          .then(response => response.json())
          .then(data => {
            if (data.error) {
              messageDiv.innerHTML = `<span style="color: #ef4444;">âŒ Error: ${data.error}</span>`;
            } else {
              messageDiv.innerHTML = '<span style="color: #10b981;">âœ… Sensor updated successfully!</span>';
              // Reset form and button
              document.getElementById('newSensorName').value = '';
              document.getElementById('newSensorCategory').value = 'custom';
              document.getElementById('newSensorUnit').value = '';
              document.getElementById('newSensorMinRange').value = '';
              document.getElementById('newSensorMaxRange').value = '';
              document.getElementById('newSensorLowThreshold').value = '';
              document.getElementById('newSensorHighThreshold').value = '';
              
              const addButton = document.querySelector('button[onclick^="updateCustomSensor"]');
              if (addButton) {
                const originalOnClick = addButton.getAttribute('data-original-onclick');
                addButton.textContent = 'âž• Add Custom Sensor';
                addButton.setAttribute('onclick', originalOnClick);
                addButton.removeAttribute('data-original-onclick');
              }
              
              // Reload list and refresh UI
              setTimeout(() => {
                loadCustomSensors(); // This will merge into unified registry and refresh UI
              }, 500);
            }
          })
          .catch(error => {
            console.error('Error updating custom sensor:', error);
            messageDiv.innerHTML = `<span style="color: #ef4444;">âŒ Error: ${error.message}</span>`;
          });
      }
      
      function deleteCustomSensor(sensorId, sensorName) {
        if (!confirm(`Deactivate sensor "${sensorName}"? It will stop appearing in new readings, but historical data will be preserved.`)) {
          return;
        }
        
        fetch(`/api/admin/custom-sensors/${sensorId}`, {
          method: 'DELETE'
        })
          .then(response => response.json())
          .then(data => {
            if (data.error) {
              alert(`Error: ${data.error}`);
            } else {
              loadCustomSensors();
              updateStats(); // Refresh stats
            }
          })
          .catch(error => {
            console.error('Error deleting custom sensor:', error);
            alert(`Error: ${error.message}`);
          });
      }
      
      function activateCustomSensor(sensorId) {
        fetch(`/api/admin/custom-sensors/${sensorId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ is_active: true })
        })
          .then(response => response.json())
          .then(data => {
            if (data.error) {
              alert(`Error: ${data.error}`);
            } else {
              loadCustomSensors();
              updateStats(); // Refresh stats
            }
          })
          .catch(error => {
            console.error('Error activating custom sensor:', error);
            alert(`Error: ${error.message}`);
          });
      }
    </script>
  </body>
</html>
