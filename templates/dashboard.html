<!DOCTYPE html>
<html>
  <head>
    <title>Ithena Industrial IoT Dashboard</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/static/css/theme.css">
    <link rel="stylesheet" href="/static/css/style.css">
    <!-- All CSS has been moved to static/css/style.css -->
    <!-- Gridstack.js for grid layout -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gridstack@9.4.0/dist/gridstack.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gridstack@9.4.0/dist/gridstack-extra.min.css">
    <!-- Three.js for 3D Digital Twin -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls for 3D rig interaction -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Gridstack.js -->
    <script src="https://cdn.jsdelivr.net/npm/gridstack@9.4.0/dist/gridstack-all.js"></script>
  </head>
  <body>
    <div id="boot-overlay" style="position:fixed;top:0;left:0;width:100%;height:100%;background:black;z-index:9999;color:#0f0;font-family:monospace;display:flex;align-items:center;justify-content:center;flex-direction:column;">
      <div id="boot-text">INITIALIZING...</div>
    </div>
    <div class="container dashboard-container">
      <!-- Hidden header - replaced by SCADA topbar -->
      <h1 style="display:none;">Sensor Data Pipeline</h1>
      <div class="subtitle" style="display:none;">Real-Time IoT Monitoring Dashboard</div>

      <!-- Login/Signup Form (shown when not authenticated) -->
      <div id="loginForm" style="display: none; max-width: 400px; margin: 100px auto; padding: 40px; background: rgba(30, 41, 59, 0.8); border-radius: 20px; border: 1px solid rgba(148, 163, 184, 0.2);">
        <div style="display: flex; gap: 10px; margin-bottom: 30px; border-bottom: 1px solid rgba(148, 163, 184, 0.2);">
          <button id="showLoginBtn" onclick="showLoginForm()" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #60a5fa 0%, #a78bfa 100%); border: none; border-radius: 8px 8px 0 0; color: white; font-weight: 600; font-size: 14px; cursor: pointer;">Login</button>
          <button id="showSignupBtnAuth" onclick="showSignupFormAuth()" style="flex: 1; padding: 12px; background: rgba(15, 23, 42, 0.6); border: none; border-radius: 8px 8px 0 0; color: #94a3b8; font-weight: 600; font-size: 14px; cursor: pointer;">Sign Up</button>
        </div>
        
        <!-- Login Form -->
        <div id="loginFormContent">
          <form id="loginFormElement" onsubmit="handleLogin(event)">
            <div style="margin-bottom: 20px;">
              <label style="display: block; margin-bottom: 8px; color: #94a3b8; font-size: 14px;">Username</label>
              <input type="text" id="loginUsername" required style="width: 100%; padding: 12px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 8px; color: #e2e8f0; font-size: 14px; box-sizing: border-box;">
            </div>
            <div style="margin-bottom: 20px;">
              <label style="display: block; margin-bottom: 8px; color: #94a3b8; font-size: 14px;">Password</label>
              <input type="password" id="loginPassword" required style="width: 100%; padding: 12px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 8px; color: #e2e8f0; font-size: 14px; box-sizing: border-box;">
            </div>
            <button type="submit" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #60a5fa 0%, #a78bfa 100%); border: none; border-radius: 8px; color: white; font-weight: 600; font-size: 14px; cursor: pointer;">Login</button>
            <div id="loginError" style="margin-top: 16px; color: #f87171; font-size: 14px; text-align: center; display: none;"></div>
          </form>
        </div>

        <!-- Signup Form (hidden by default) -->
        <div id="signupFormContent" style="display: none;">
          <form id="signupFormElementAuth" onsubmit="handleSignupAuth(event)">
            <div style="margin-bottom: 16px;">
              <label style="display: block; margin-bottom: 6px; color: #94a3b8; font-size: 13px;">Username</label>
              <input type="text" id="signupUsernameAuth" required style="width: 100%; padding: 10px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 8px; color: #e2e8f0; font-size: 14px; box-sizing: border-box;">
            </div>
            <div style="margin-bottom: 16px;">
              <label style="display: block; margin-bottom: 6px; color: #94a3b8; font-size: 13px;">Password</label>
              <input type="password" id="signupPasswordAuth" required style="width: 100%; padding: 10px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 8px; color: #e2e8f0; font-size: 14px; box-sizing: border-box;">
            </div>
            <div style="margin-bottom: 16px;">
              <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="signupAdminToggle" onchange="toggleMachineSelectionAuth()" style="cursor: pointer; width: 18px; height: 18px;">
                <span style="color: #e2e8f0; font-size: 14px;">Create as Admin</span>
              </label>
            </div>
            <div id="machineSelectionAuth" style="margin-bottom: 16px; display: none;">
              <label style="display: block; margin-bottom: 8px; color: #94a3b8; font-size: 13px;">Machine Access (select at least one)</label>
              <div style="display: flex; gap: 12px;">
                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                  <input type="checkbox" value="A" class="machine-checkbox-auth" style="cursor: pointer;">
                  <span style="color: #e2e8f0;">Machine A</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                  <input type="checkbox" value="B" class="machine-checkbox-auth" style="cursor: pointer;">
                  <span style="color: #e2e8f0;">Machine B</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                  <input type="checkbox" value="C" class="machine-checkbox-auth" style="cursor: pointer;">
                  <span style="color: #e2e8f0;">Machine C</span>
                </label>
              </div>
            </div>
            <button type="submit" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #10b981 0%, #059669 100%); border: none; border-radius: 8px; color: white; font-weight: 600; font-size: 14px; cursor: pointer;">Sign Up</button>
            <div id="signupErrorAuth" style="margin-top: 12px; color: #f87171; font-size: 13px; text-align: center; display: none;"></div>
            <div id="signupSuccessAuth" style="margin-top: 12px; color: #10b981; font-size: 13px; text-align: center; display: none;"></div>
          </form>
        </div>
      </div>

      <!-- Main Dashboard (hidden when not authenticated) -->
      <div id="mainDashboard" style="display: none;">
        <!-- SCADA Left Sidebar -->
        <div class="scada-left-sidebar" id="leftSidebar">
          <div class="scada-sidebar-hamburger" onclick="toggleLeftSidebar()">
            ‚ò∞
          </div>
          <div class="scada-sidebar-icons">
            <div class="scada-sidebar-icon active" onclick="switchSection('monitoring')" data-section="monitoring" title="Monitoring">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                <line x1="9" y1="9" x2="9" y2="21"></line>
                <line x1="15" y1="9" x2="15" y2="21"></line>
                <line x1="3" y1="15" x2="21" y2="15"></line>
              </svg>
              <span class="scada-sidebar-icon-label">MONITORING</span>
            </div>
            <div class="scada-sidebar-icon" onclick="switchSection('alarms')" data-section="alarms" title="Alarms">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path>
                <path d="M13.73 21a2 2 0 0 1-3.46 0"></path>
              </svg>
              <span class="scada-sidebar-icon-label">ALARMS</span>
            </div>
            <div class="scada-sidebar-icon" onclick="switchSection('configuration')" data-section="configuration" title="Configuration" id="sidebarConfigIcon">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="3"></circle>
                <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
              </svg>
              <span class="scada-sidebar-icon-label">CONFIG</span>
            </div>
            <!-- Admin War Room (Admin Only) -->
            <div class="scada-sidebar-icon" onclick="switchSection('admin')" data-section="admin" title="Admin War Room" id="sidebarAdminIcon" style="display: none;">
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
                <path d="M9 12l2 2 4-4"></path>
              </svg>
              <span class="scada-sidebar-icon-label">ADMIN</span>
            </div>
          </div>
        </div>
        
        <!-- SCADA Fixed Top Bar -->
        <div class="scada-topbar">
          <div class="scada-topbar-left">
            <div class="scada-logo">I</div>
            <div class="scada-branding">ITHENA SCADA</div>
            <div class="scada-machine-dropdown">
              <span style="color: var(--text-muted);">Machine:</span>
              <select class="scada-machine-select" id="scadaMachineSelect" onchange="selectMachine(this.value)">
                <option value="A">A</option>
                <option value="B">B</option>
                <option value="C">C</option>
              </select>
            </div>
            <div class="scada-status-dots">
              <div class="scada-status-dot">
                <span class="scada-status-dot-label">SYSTEM</span>
                <div class="scada-status-dot-indicator" id="statusSystem"></div>
              </div>
              <div class="scada-status-dot">
                <span class="scada-status-dot-label">COMM</span>
                <div class="scada-status-dot-indicator" id="statusComm"></div>
              </div>
              <div class="scada-status-dot">
                <span class="scada-status-dot-label">POWER</span>
                <div class="scada-status-dot-indicator" id="statusPower"></div>
              </div>
              <div class="scada-status-dot">
                <span class="scada-status-dot-label">SAFETY</span>
                <div class="scada-status-dot-indicator" id="statusSafety"></div>
              </div>
            </div>
            
            <div class="scada-pipeline-health" style="border: none;">
              <div class="scada-pipeline-metric scada-total-messages">
                <span class="scada-pipeline-label">TOTAL</span>
                <span class="scada-pipeline-value scada-odometer" id="total-readings">0</span>
              </div>
              <div class="scada-pipeline-metric">
                <span class="scada-pipeline-label">MPS</span>
                <span class="scada-pipeline-value" id="message-velocity">0.0</span>
              </div>
              <div class="scada-pipeline-metric">
                <span class="scada-pipeline-label">CPU</span>
                <span class="scada-pipeline-value" id="cpu-load" style="color: var(--status-running);">--%</span>
              </div>
              <div class="scada-pipeline-metric">
                <span class="scada-pipeline-label">DB</span>
                <span class="scada-pipeline-value" id="db-latency" style="color: var(--status-info);">--ms</span>
              </div>
            </div>
          </div>

          <div class="scada-topbar-right">
            <button id="editLayoutBtn" onclick="toggleLayoutEditMode()" class="scada-btn" style="padding: 6px 12px; font-size: 10px; margin-right: var(--space-md); background: var(--bg-secondary); border: 1px solid var(--border-default); color: var(--text-primary); font-family: var(--font-mono); cursor: pointer;">
              ‚öôÔ∏è EDIT LAYOUT
            </button>
            <div class="scada-alerts-badge none" id="scadaAlertsBadge">
              <span>ALERTS</span>
              <span id="scadaAlertsCount">0</span>
            </div>
            <div class="scada-utc-time" id="scadaUTCTime">--:--:-- UTC</div>
            <div class="scada-topbar-controls">
              <button onclick="handleLogout()" class="scada-btn">LOGOUT</button>
            </div>
          </div>
        </div>
        
        <!-- User Info (hidden, kept for compatibility) -->
        <div style="display: none;">
          <span id="userInfo"></span>
          <button id="showSignupBtn" onclick="toggleSignupForm()" style="display: none;">‚ûï Create User</button>
        </div>

        <!-- Sign Up Form (admin only, hidden by default) -->
        <div id="signupForm" style="display: none; max-width: 500px; margin: 0 auto 30px; padding: 30px; background: rgba(30, 41, 59, 0.8); border-radius: 16px; border: 1px solid rgba(148, 163, 184, 0.2);">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="color: #60a5fa; margin: 0;">Create New User</h3>
            <button onclick="toggleSignupForm()" style="background: none; border: none; color: #94a3b8; font-size: 20px; cursor: pointer; padding: 0; width: 24px; height: 24px;">‚úï</button>
          </div>
          <form id="signupFormElement" onsubmit="handleSignup(event)">
            <div style="margin-bottom: 16px;">
              <label style="display: block; margin-bottom: 6px; color: #94a3b8; font-size: 13px;">Username</label>
              <input type="text" id="signupUsername" required style="width: 100%; padding: 10px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 8px; color: #e2e8f0; font-size: 14px; box-sizing: border-box;">
            </div>
            <div style="margin-bottom: 16px;">
              <label style="display: block; margin-bottom: 6px; color: #94a3b8; font-size: 13px;">Password</label>
              <input type="password" id="signupPassword" required style="width: 100%; padding: 10px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 8px; color: #e2e8f0; font-size: 14px; box-sizing: border-box;">
            </div>
            <div style="margin-bottom: 16px;">
              <label style="display: block; margin-bottom: 6px; color: #94a3b8; font-size: 13px;">Role</label>
              <select id="signupRole" required onchange="toggleMachineSelection()" style="width: 100%; padding: 10px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 8px; color: #e2e8f0; font-size: 14px; box-sizing: border-box; cursor: pointer;">
                <option value="operator">Operator</option>
                <option value="admin">Admin</option>
              </select>
            </div>
            <div id="machineSelection" style="margin-bottom: 16px;">
              <label style="display: block; margin-bottom: 8px; color: #94a3b8; font-size: 13px;">Machine Access (select at least one)</label>
              <div style="display: flex; gap: 12px;">
                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                  <input type="checkbox" value="A" class="machine-checkbox" style="cursor: pointer;">
                  <span style="color: #e2e8f0;">Machine A</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                  <input type="checkbox" value="B" class="machine-checkbox" style="cursor: pointer;">
                  <span style="color: #e2e8f0;">Machine B</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                  <input type="checkbox" value="C" class="machine-checkbox" style="cursor: pointer;">
                  <span style="color: #e2e8f0;">Machine C</span>
                </label>
              </div>
            </div>
            <button type="submit" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #10b981 0%, #059669 100%); border: none; border-radius: 8px; color: white; font-weight: 600; font-size: 14px; cursor: pointer;">Create User</button>
            <div id="signupError" style="margin-top: 12px; color: #f87171; font-size: 13px; text-align: center; display: none;"></div>
            <div id="signupSuccess" style="margin-top: 12px; color: #10b981; font-size: 13px; text-align: center; display: none;"></div>
          </form>
        </div>

      <!-- SCADA Main Content Area -->
      <div class="scada-main">
        <!-- Monitoring Section (Default) - Zero Scroll 1080p Layout -->
        <div class="scada-section active" id="section-monitoring">
          <div class="grid-stack" id="monitoringGrid">
            
            <!-- Command Deck (top-left) -->
            <div class="grid-stack-item" data-gs-x="0" data-gs-y="0" data-gs-width="3" data-gs-height="3">
              <div class="grid-stack-item-content">
                <div class="grid-item-drag-handle" style="display: none; position: absolute; top: 4px; right: 4px; color: var(--theme-interactive-primary); font-size: 12px; font-weight: bold; z-index: 1000; background: rgba(0, 0, 0, 0.8); padding: 4px 8px; border-radius: 3px; font-family: var(--font-mono); pointer-events: none;">‚ãÆ‚ãÆ DRAG</div>
                <div class="rig-card command-deck">
                  <div class="rig-card-header">
                    <span>COMMAND DECK</span>
                    <span class="status-indicator status-nom"></span>
                  </div>
                  <div class="rig-card-body">
                    <div class="command-btn-row">
                      <button id="btn-start" class="rig-btn rig-btn-start" onclick="globalStartMachine()">START</button>
                      <button id="btn-stop" class="rig-btn rig-btn-stop" onclick="globalStopMachine()">STOP</button>
                    </div>

                    <div class="command-slider-group">
                      <div class="command-slider-header">
                        <label for="commandSamplingRate">SAMPLING SPEED</label>
                        <span id="commandMPSDisplay">10 MPS</span>
                      </div>
                      <input type="range" id="commandSamplingRate" min="1" max="20" value="10" step="1" onchange="updateTargetMPS(this.value)">
                    </div>

                    <div class="command-anomaly-group">
                      <label>ANOMALY INJECT</label>
                      <div class="command-anomaly-row">
                        <select id="anomalyTypeSelect" class="rig-select">
                          <option value="temperature_spike">Temp Spike</option>
                          <option value="pressure_drop">Pressure Drop</option>
                          <option value="vibration_surge">Vibration</option>
                        </select>
                        <button class="rig-btn rig-btn-warn" onclick="triggerAnomalyInjection()">INJECT</button>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Health Matrix (left-center) -->
            <div class="grid-stack-item" data-gs-x="0" data-gs-y="3" data-gs-width="3" data-gs-height="5">
              <div class="grid-stack-item-content">
                <div class="grid-item-drag-handle" style="display: none; position: absolute; top: 4px; right: 4px; color: var(--theme-interactive-primary); font-size: 12px; font-weight: bold; z-index: 1000; background: rgba(0, 0, 0, 0.8); padding: 4px 8px; border-radius: 3px; font-family: var(--font-mono); pointer-events: none;">‚ãÆ‚ãÆ DRAG</div>
                <div class="rig-card">
                  <div class="rig-card-header">
                    <span>HEALTH MATRIX</span>
                    <span class="status-indicator status-nom"></span>
                  </div>
                  <div class="rig-card-body" style="overflow-y: auto;">
                    <div id="healthMatrixContainer"></div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- NEW: Live Sensor Stream (left-bottom) -->
            <div class="grid-stack-item" data-gs-x="0" data-gs-y="8" data-gs-width="3" data-gs-height="4">
              <div class="grid-stack-item-content">
                <div class="grid-item-drag-handle" style="display: none; position: absolute; top: 4px; right: 4px; color: var(--theme-interactive-primary); font-size: 12px; font-weight: bold; z-index: 1000; background: rgba(0, 0, 0, 0.8); padding: 4px 8px; border-radius: 3px; font-family: var(--font-mono); pointer-events: none;">‚ãÆ‚ãÆ DRAG</div>
                <div class="rig-card">
                  <div class="rig-card-header">
                    <span>LIVE SENSOR STREAM</span>
                    <span class="status-indicator status-nom"></span>
                  </div>
                  <div class="rig-card-body" style="overflow-y: auto; max-height: 250px;">
                    <div id="liveSensorStreamWidget" style="font-family: var(--font-mono); font-size: 9px;">
                      <!-- Populated by JS -->
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- 3D Digital Twin (center-top) - Hero Element -->
            <div class="grid-stack-item" data-gs-x="3" data-gs-y="0" data-gs-width="9" data-gs-height="8">
              <div class="grid-stack-item-content">
                <div class="grid-item-drag-handle" style="display: none; position: absolute; top: 4px; right: 4px; color: var(--theme-interactive-primary); font-size: 12px; font-weight: bold; z-index: 1000; background: rgba(0, 0, 0, 0.8); padding: 4px 8px; border-radius: 3px; font-family: var(--font-mono); pointer-events: none;">‚ãÆ‚ãÆ DRAG</div>
                <div class="rig-card digital-twin-card">
                  <div class="rig-card-header">
                    <span>3D DIGITAL TWIN</span>
                    <span class="status-indicator" id="digitalTwinStatus" style="background: var(--status-running);"></span>
                  </div>
                  <div class="rig-card-body" style="position: relative; flex: 1; min-height: 0;">
                    <canvas id="rigCanvas" style="cursor: grab; width: 100%; height: 100%;"></canvas>
                    <button id="resetViewBtn" onclick="reset3DView()" style="position: absolute; top: 10px; right: 10px; padding: 6px 12px; background: rgba(0,0,0,0.8); border: 1px solid var(--border-default); border-radius: 4px; color: var(--text-primary); font-family: var(--font-mono); font-size: 9px; font-weight: 600; cursor: pointer; transition: background var(--transition-normal); z-index: 10;">
                      ‚Üª RESET VIEW
                    </button>
                    <div id="rigRiskIndicator" style="position: absolute; bottom: 10px; left: 10px; font-family: var(--font-mono); font-size: 11px; font-weight: 700; color: var(--status-running); text-transform: uppercase; background: rgba(0,0,0,0.7); padding: 6px 12px; border-radius: 4px;">
                      RIG STATUS: NOMINAL
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Telemetry Grid (center-bottom) -->
            <div class="grid-stack-item" data-gs-x="3" data-gs-y="8" data-gs-width="6" data-gs-height="4">
              <div class="grid-stack-item-content">
                <div class="grid-item-drag-handle" style="display: none; position: absolute; top: 4px; right: 4px; color: var(--theme-interactive-primary); font-size: 12px; font-weight: bold; z-index: 1000; background: rgba(0, 0, 0, 0.8); padding: 4px 8px; border-radius: 3px; font-family: var(--font-mono); pointer-events: none;">‚ãÆ‚ãÆ DRAG</div>
                <div class="rig-card">
                  <div class="rig-card-header">
                    <span>TELEMETRY RAIL</span>
                    <span class="status-indicator status-nom"></span>
                  </div>
                  <div class="rig-card-body" style="overflow-y: auto;">
                    <div id="telemetryContainer"></div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- NEW: Critical Alarms (right-bottom) -->
            <div class="grid-stack-item" data-gs-x="9" data-gs-y="8" data-gs-width="3" data-gs-height="4">
              <div class="grid-stack-item-content">
                <div class="grid-item-drag-handle" style="display: none; position: absolute; top: 4px; right: 4px; color: var(--theme-interactive-primary); font-size: 12px; font-weight: bold; z-index: 1000; background: rgba(0, 0, 0, 0.8); padding: 4px 8px; border-radius: 3px; font-family: var(--font-mono); pointer-events: none;">‚ãÆ‚ãÆ DRAG</div>
                <div class="rig-card">
                  <div class="rig-card-header">
                    <span>CRITICAL ALARMS</span>
                    <span class="status-indicator status-error"></span>
                  </div>
                  <div class="rig-card-body" style="overflow-y: auto; max-height: 300px;">
                    <table id="criticalAlarmsWidget" style="width: 100%; font-size: 9px; font-family: var(--font-mono);">
                      <thead>
                        <tr>
                          <th style="text-align: left; padding: 4px;">TIME</th>
                          <th style="text-align: left; padding: 4px;">SENSOR</th>
                        </tr>
                      </thead>
                      <tbody>
                        <!-- Populated by JS -->
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
            </div>
            
          </div>
        </div>

        <!-- Full-Screen Critical Alarm Overlay -->
        <div id="criticalAlarmOverlay" style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(220, 38, 38, 0.85); z-index: 10000; flex-direction: column; justify-content: center; align-items: center; backdrop-filter: blur(8px);">
          <div style="text-align: center; animation: alarmPulse 1s ease-in-out infinite;">
            <div style="font-family: var(--font-mono); font-size: 72px; font-weight: 900; color: #fff; text-shadow: 0 0 30px rgba(255,0,0,1), 0 0 60px rgba(255,0,0,0.8); letter-spacing: 8px; margin-bottom: 20px;">
              CRITICAL FAILURE IMMINENT
            </div>
            <div style="font-family: var(--font-mono); font-size: 32px; font-weight: 700; color: rgba(255,255,255,0.9); margin-bottom: 10px;">
              RISK SCORE: <span id="alarmRiskScore">--</span>%
            </div>
            <div style="font-family: var(--font-mono); font-size: 18px; color: rgba(255,255,255,0.7); margin-bottom: 40px;">
              MACHINE <span id="alarmMachineId">A</span> - IMMEDIATE ACTION REQUIRED
            </div>
            <button id="silenceAlarmBtn" onclick="silenceCriticalAlarm()" style="padding: 20px 60px; font-family: var(--font-mono); font-size: 18px; font-weight: 700; background: rgba(0,0,0,0.8); border: 3px solid #fff; border-radius: 8px; color: #fff; cursor: pointer; text-transform: uppercase; letter-spacing: 2px; transition: all 0.3s ease;">
              SILENCE ALARM
            </button>
          </div>
        </div>

        <style>
          @keyframes alarmPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.02); opacity: 0.9; }
          }
          @keyframes rigShake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
          }
          .rig-shaking {
            animation: rigShake 0.5s ease-in-out infinite;
          }
          #silenceAlarmBtn:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.05);
          }
          .monitoring-layout-container {
            display: flex;
            gap: var(--space-lg);
            flex-wrap: wrap;
          }
          .monitoring-center-panel {
            flex: 1;
            min-width: 300px;
          }
          @media (max-width: 1200px) {
            .monitoring-center-panel {
              order: -1;
              flex-basis: 100%;
            }
          }
        </style>

        <!-- Alarms Section -->
        <div class="scada-section" id="section-alarms" style="display: none;">
          <div style="display: flex; flex-direction: column; height: calc(100vh - 60px - var(--space-lg) * 2); gap: var(--space-md);">
            <!-- Category Filter Bar -->
            <div class="rig-card" style="flex-shrink: 0;">
              <div class="rig-card-body" style="padding: var(--space-sm);">
                <div style="display: flex; gap: var(--space-md); align-items: center; flex-wrap: wrap;">
                  <span class="config-label" style="font-weight: 900; margin-right: var(--space-sm);">FILTER:</span>
                  <div id="alarmsCategoryFilterBar" style="display: flex; gap: var(--space-sm); flex-wrap: wrap;">
                    <!-- Populated by renderAlarmsCategoryToggles() -->
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Chart Matrix Grid (Gridstack) -->
            <div class="grid-stack" id="alarmsGrid" style="flex: 1; overflow-y: auto; min-height: 0;">
              <!-- Charts will be dynamically generated by renderAlarmMatrix() -->
            </div>
            
            <!-- Bottom: Alarms List -->
            <div class="rig-card" style="height: 200px; flex-shrink: 0;">
              <div class="rig-card-header">
                <span>ACTIVE ALARMS</span>
                <span class="status-indicator status-nom"></span>
              </div>
              <div class="rig-card-body" style="flex: 1; overflow-y: auto; padding: 0;">
                <table style="width: 100%; border-collapse: collapse; font-size: 9px;">
                  <thead style="position: sticky; top: 0; background: var(--bg-secondary); z-index: 10;">
                    <tr>
                      <th class="config-table-header" style="font-weight: 900; padding: var(--space-xs); text-align: left;">TIME</th>
                      <th class="config-table-header" style="font-weight: 900; padding: var(--space-xs); text-align: left;">SENSOR</th>
                      <th class="config-table-header" style="font-weight: 900; padding: var(--space-xs); text-align: left;">VALUE</th>
                      <th class="config-table-header" style="font-weight: 900; padding: var(--space-xs); text-align: left;">THRESHOLD</th>
                      <th class="config-table-header" style="font-weight: 900; padding: var(--space-xs); text-align: left;">SEVERITY</th>
                    </tr>
                  </thead>
                  <tbody id="alarmsListBody">
                    <tr>
                      <td colspan="5" style="text-align: center; color: var(--text-muted); padding: var(--space-md); font-size: 10px;">No active alarms</td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Controls Section (Removed - moved to Operator Controls card) -->
        <div class="scada-section" id="section-controls" style="display: none;">
          <div style="background: var(--bg-secondary); border: 1px solid var(--border-subtle); border-radius: 6px; padding: var(--space-xl);">
            <h2 style="font-family: var(--font-mono); font-size: 12px; font-weight: 600; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: var(--space-lg);">
              KAFKA CONTROLS
            </h2>
            <div style="display: grid; gap: var(--space-lg);">
              <!-- Producer Controls -->
              <div>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-md);">
                  <div style="font-family: var(--font-mono); font-size: 12px; font-weight: 600; color: var(--text-primary); text-transform: uppercase;">
                    PRODUCER
                  </div>
                  <div style="display: flex; align-items: center; gap: var(--space-xs);">
                    <div class="scada-status-dot-indicator" id="sectionProducerStatus"></div>
                    <span style="font-family: var(--font-mono); font-size: 10px; color: var(--text-muted);" id="sectionProducerStatusText">STOPPED</span>
                  </div>
                </div>
                <div style="display: flex; gap: var(--space-sm);">
                  <button onclick="startComponent('producer')" class="scada-btn" style="flex: 1;">START</button>
                  <button onclick="stopComponent('producer')" class="scada-btn" style="flex: 1;">STOP</button>
                </div>
              </div>
              
              <!-- Consumer Controls -->
              <div>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-md);">
                  <div style="font-family: var(--font-mono); font-size: 12px; font-weight: 600; color: var(--text-primary); text-transform: uppercase;">
                    CONSUMER
                  </div>
                  <div style="display: flex; align-items: center; gap: var(--space-xs);">
                    <div class="scada-status-dot-indicator" id="sectionConsumerStatus"></div>
                    <span style="font-family: var(--font-mono); font-size: 10px; color: var(--text-muted);" id="sectionConsumerStatusText">STOPPED</span>
                  </div>
                </div>
                <div style="display: flex; gap: var(--space-sm);">
                  <button onclick="startComponent('consumer')" class="scada-btn" style="flex: 1;">START</button>
                  <button onclick="stopComponent('consumer')" class="scada-btn" style="flex: 1;">STOP</button>
                </div>
              </div>
              
              <!-- Kafka Status -->
              <div style="padding: var(--space-md); background: var(--bg-tertiary); border: 1px solid var(--border-subtle); border-radius: 4px;">
                <div style="font-family: var(--font-mono); font-size: 11px; color: var(--text-muted); margin-bottom: var(--space-xs); text-transform: uppercase;">
                  KAFKA BROKER
                </div>
                <div style="display: flex; align-items: center; gap: var(--space-sm);">
                  <div class="scada-status-dot-indicator" id="sectionKafkaStatus"></div>
                  <span style="font-family: var(--font-mono); font-size: 11px; color: var(--text-primary);" id="sectionKafkaStatusText">Checking...</span>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Configuration Section -->
        <div class="scada-section" id="section-configuration" style="display: none;">
          <div class="grid-stack" id="configGrid">
            
            <!-- Widget 0: Smart Sensor Onboarding (Top - AI Powered) -->
            <div class="grid-stack-item" data-gs-x="0" data-gs-y="0" data-gs-width="12" data-gs-height="3">
              <div class="grid-stack-item-content">
                <div class="grid-item-drag-handle" style="display: none; position: absolute; top: 4px; right: 4px; color: var(--theme-interactive-primary); font-size: 12px; font-weight: bold; z-index: 1000; background: rgba(0, 0, 0, 0.8); padding: 4px 8px; border-radius: 3px; font-family: var(--font-mono); pointer-events: none;">‚ãÆ‚ãÆ DRAG</div>
                <div class="rig-card" style="height: 100%; display: flex; flex-direction: column; border: 2px solid var(--theme-status-info); box-shadow: 0 0 20px rgba(0, 191, 255, 0.3);">
                  <div class="rig-card-header" style="border-bottom: 1px solid var(--theme-status-info);">
                    <span>‚ú® SMART SENSOR ONBOARDING (AI-POWERED)</span>
                    <span class="status-indicator" style="background: var(--theme-status-info);"></span>
                  </div>
                  <div class="rig-card-body" style="flex: 1; overflow-y: auto; padding: var(--space-md);">
                    <div id="sensorUploadZone" class="scada-upload-zone" ondrop="handleSensorFileDrop(event)" ondragover="event.preventDefault()" onclick="document.getElementById('sensorFileInput').click()">
                      <div class="scada-upload-icon">üìÑ</div>
                      <div class="scada-upload-text">
                        <span style="font-weight: 700;">Drag & Drop</span> or <span style="font-weight: 700;">Click</span>
                      </div>
                      <div class="scada-upload-hint">PDF, CSV, or JSON</div>
                      <input type="file" id="sensorFileInput" accept=".pdf,.csv,.json" style="display: none;" onchange="handleSensorFileSelect(event)">
                    </div>
                    <button onclick="aiParseSensorFile()" class="scada-btn" id="aiParseBtn" style="width: 100%; margin-top: var(--space-sm); background: var(--theme-status-info); border-color: var(--theme-status-info); font-weight: 700;">
                      <span style="margin-right: var(--space-xs);">‚ú®</span>AI PARSE
                    </button>
                    <div id="aiParseLoading" style="display: none; margin-top: var(--space-sm); text-align: center; padding: var(--space-md);">
                      <div class="scada-loading-spinner"></div>
                      <div class="config-label" style="margin-top: var(--space-sm); font-weight: 700;">Analyzing...</div>
                    </div>
                    <div id="aiParseResults" style="display: none; margin-top: var(--space-sm); padding: var(--space-md); border: 2px solid var(--theme-status-info); border-radius: 4px; background: var(--bg-tertiary);">
                      <div class="config-label" style="color: var(--theme-status-info); margin-bottom: var(--space-md); font-weight: 700; font-size: 11px;">‚úì REVIEW EXTRACTED SPECS</div>
                      <div id="aiParsePreview" class="config-value" style="font-weight: 700;"></div>
                      <button onclick="applyAIParseResults()" class="scada-btn" style="width: 100%; margin-top: var(--space-sm); background: var(--theme-status-info); border-color: var(--theme-status-info); font-weight: 700;">APPLY TO FORM</button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Widget 1: Sensor Management Accordion (Left) -->
            <div class="grid-stack-item" data-gs-x="0" data-gs-y="3" data-gs-width="4" data-gs-height="10">
              <div class="grid-stack-item-content">
                <div class="grid-item-drag-handle" style="display: none; position: absolute; top: 4px; right: 4px; color: var(--theme-interactive-primary); font-size: 12px; font-weight: bold; z-index: 1000; background: rgba(0, 0, 0, 0.8); padding: 4px 8px; border-radius: 3px; font-family: var(--font-mono); pointer-events: none;">‚ãÆ‚ãÆ DRAG</div>
                <div class="rig-card" style="height: 100%; display: flex; flex-direction: column;">
                  <div class="rig-card-header">
                    <span>SENSOR MANAGEMENT - MACHINE <span id="configMachineLabel" style="color: var(--status-running);">A</span></span>
                    <span class="status-indicator status-nom"></span>
                  </div>
                  <div class="rig-card-body" style="flex: 1; overflow-y: auto; padding: var(--space-md);">
                    <!-- Connection Status -->
                    <div class="rig-card" style="margin-bottom: var(--space-md);">
                      <div class="rig-card-header">
                        <span>CONNECTION STATUS</span>
                        <span class="status-indicator status-nom"></span>
                      </div>
                      <div class="rig-card-body" style="padding: var(--space-md);">
                        <div style="display: grid; gap: var(--space-sm);">
                          <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span class="config-label" style="font-weight: 700;">PRODUCER</span>
                            <div style="display: flex; align-items: center; gap: var(--space-xs);">
                              <div class="scada-status-dot-indicator" id="configProducerStatus"></div>
                              <span class="config-value" id="configProducerStatusText">STOPPED</span>
                            </div>
                          </div>
                          <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span class="config-label" style="font-weight: 700;">CONSUMER</span>
                            <div style="display: flex; align-items: center; gap: var(--space-xs);">
                              <div class="scada-status-dot-indicator" id="configConsumerStatus"></div>
                              <span class="config-value" id="configConsumerStatusText">STOPPED</span>
                            </div>
                          </div>
                          <div style="display: flex; justify-content: space-between; align-items: center; padding-top: var(--space-sm); border-top: 1px solid var(--border-subtle);">
                            <span class="config-label" style="font-weight: 700;">KAFKA</span>
                            <div style="display: flex; align-items: center; gap: var(--space-xs);">
                              <div class="scada-status-dot-indicator" id="configKafkaStatus"></div>
                              <span class="config-value" id="configKafkaStatusText">Checking...</span>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                    
                    <!-- Sensor Management Accordions (5 Categories) -->
                    <div id="configSensorAccordions" style="flex: 1; overflow-y: auto;">
                      <!-- Populated by renderConfigSensorAccordions() -->
                    </div>
                    
                    <!-- Custom Sensors List -->
                    <div class="rig-card">
                      <div class="rig-card-header">
                        <span>CUSTOM SENSORS</span>
                        <span class="status-indicator status-nom"></span>
                      </div>
                      <div class="rig-card-body" style="padding: var(--space-md);">
                        <div id="customSensorsList" style="max-height: 300px; overflow-y: auto;">
                          <div class="config-value" style="text-align: center; padding: var(--space-lg);">Loading...</div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>


            <!-- Widget 2: Add Custom Sensor Form (Center Top) -->
            <div class="grid-stack-item" data-gs-x="4" data-gs-y="3" data-gs-width="4" data-gs-height="6">
              <div class="grid-stack-item-content">
                <div class="grid-item-drag-handle" style="display: none; position: absolute; top: 4px; right: 4px; color: var(--theme-interactive-primary); font-size: 12px; font-weight: bold; z-index: 1000; background: rgba(0, 0, 0, 0.8); padding: 4px 8px; border-radius: 3px; font-family: var(--font-mono); pointer-events: none;">‚ãÆ‚ãÆ DRAG</div>
                <div id="sectionConfigContent" class="rig-card" style="height: 100%; display: flex; flex-direction: column;">
                  <div class="rig-card-header">
                    <span>‚ûï ADD CUSTOM SENSOR</span>
                    <span class="status-indicator status-nom"></span>
                  </div>
                  <div class="rig-card-body" style="flex: 1; overflow-y: auto; padding: var(--space-md);">
                    <p class="config-label" style="margin-bottom: var(--space-md); line-height: 1.4; font-weight: 700;">
                      Add custom sensor parameters. New sensors appear in producer messages and dashboard stats.
                    </p>
                    
                    <div style="display: grid; gap: var(--space-sm); margin-bottom: var(--space-md);">
                      <div>
                        <label class="config-label" style="font-weight: 700;">SENSOR NAME *</label>
                        <input type="text" id="newSensorName" placeholder="bearing_vibration_rms" class="scada-input" style="width: 100%; padding: var(--space-sm); margin-top: 2px;">
                      </div>
                      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--space-sm);">
                        <div>
                          <label class="config-label" style="font-weight: 700;">CATEGORY</label>
                          <select id="newSensorCategory" class="scada-input" style="width: 100%; padding: var(--space-sm); margin-top: 2px; cursor: pointer;">
                            <option value="custom">Custom</option>
                            <option value="environmental">Environmental</option>
                            <option value="mechanical">Mechanical</option>
                            <option value="thermal">Thermal</option>
                            <option value="electrical">Electrical</option>
                            <option value="fluid">Fluid</option>
                          </select>
                        </div>
                        <div>
                          <label class="config-label" style="font-weight: 700;">UNIT</label>
                          <input type="text" id="newSensorUnit" placeholder="mm/s" class="scada-input" style="width: 100%; padding: var(--space-sm); margin-top: 2px;">
                        </div>
                      </div>
                      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--space-sm);">
                        <div>
                          <label class="config-label" style="font-weight: 700;">MIN RANGE *</label>
                          <input type="number" step="any" id="newSensorMinRange" placeholder="0.0" class="scada-input" style="width: 100%; padding: var(--space-sm); margin-top: 2px;">
                        </div>
                        <div>
                          <label class="config-label" style="font-weight: 700;">MAX RANGE *</label>
                          <input type="number" step="any" id="newSensorMaxRange" placeholder="100.0" class="scada-input" style="width: 100%; padding: var(--space-sm); margin-top: 2px;">
                        </div>
                      </div>
                      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--space-sm);">
                        <div>
                          <label class="config-label" style="font-weight: 700;">LOW THRESHOLD</label>
                          <input type="number" step="any" id="newSensorLowThreshold" placeholder="Optional" class="scada-input" style="width: 100%; padding: var(--space-sm); margin-top: 2px;">
                        </div>
                        <div>
                          <label class="config-label" style="font-weight: 700;">HIGH THRESHOLD</label>
                          <input type="number" step="any" id="newSensorHighThreshold" placeholder="Optional" class="scada-input" style="width: 100%; padding: var(--space-sm); margin-top: 2px;">
                        </div>
                      </div>
                    </div>
                    <button onclick="addCustomSensor()" class="scada-btn" style="width: 100%;">
                      ‚ûï ADD SENSOR
                    </button>
                    <div id="customSensorMessage" class="config-value" style="margin-top: var(--space-sm); text-align: center;"></div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Widget 3: Anomaly Simulation (Right Top) -->
            <div class="grid-stack-item" data-gs-x="8" data-gs-y="3" data-gs-width="4" data-gs-height="4">
              <div class="grid-stack-item-content">
                <div class="grid-item-drag-handle" style="display: none; position: absolute; top: 4px; right: 4px; color: var(--theme-interactive-primary); font-size: 12px; font-weight: bold; z-index: 1000; background: rgba(0, 0, 0, 0.8); padding: 4px 8px; border-radius: 3px; font-family: var(--font-mono); pointer-events: none;">‚ãÆ‚ãÆ DRAG</div>
                <div class="rig-card" style="height: 100%; display: flex; flex-direction: column;">
                  <div class="rig-card-header">
                    <span>ANOMALY SIMULATION</span>
                    <span class="status-indicator status-warning"></span>
                  </div>
                  <div class="rig-card-body" style="flex: 1; overflow-y: auto; padding: var(--space-md);">
                    <p class="config-label" style="margin-bottom: var(--space-md); font-weight: 700;">
                      Inject synthetic anomalies for testing ML detection and alert workflows.
                    </p>
                    
                    <div style="display: grid; gap: var(--space-sm);">
                      <div style="display: flex; align-items: center; gap: var(--space-md);">
                        <label class="config-label" style="min-width: 100px; font-weight: 700;">Machine:</label>
                        <select id="injectionMachineId" class="scada-input" style="flex: 1; padding: var(--space-sm);">
                          <option value="A">Machine A</option>
                          <option value="B">Machine B</option>
                          <option value="C">Machine C</option>
                        </select>
                      </div>
                      
                      <div style="display: flex; align-items: center; gap: var(--space-md);">
                        <label class="config-label" style="min-width: 100px; font-weight: 700;">Anomaly Type:</label>
                        <select id="injectionAnomalyType" class="scada-input" style="flex: 1; padding: var(--space-sm);">
                          <option value="high_vibration">High Vibration</option>
                          <option value="high_temperature">High Temperature</option>
                          <option value="rpm_spike">RPM Spike</option>
                          <option value="bearing_overheat">Bearing Overheat</option>
                        </select>
                      </div>
                      
                      <button onclick="injectAnomalyNow()" class="rig-btn-primary" style="width: 100%; margin-top: var(--space-sm);">
                        <span style="margin-right: var(--space-xs);">‚ö†Ô∏è</span>INJECT ANOMALY
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Widget 4: Data Export (Right Bottom) -->
            <div class="grid-stack-item" data-gs-x="8" data-gs-y="7" data-gs-width="4" data-gs-height="4">
              <div class="grid-stack-item-content">
                <div class="grid-item-drag-handle" style="display: none; position: absolute; top: 4px; right: 4px; color: var(--theme-interactive-primary); font-size: 12px; font-weight: bold; z-index: 1000; background: rgba(0, 0, 0, 0.8); padding: 4px 8px; border-radius: 3px; font-family: var(--font-mono); pointer-events: none;">‚ãÆ‚ãÆ DRAG</div>
                <div class="rig-card" style="height: 100%; display: flex; flex-direction: column;">
                  <div class="rig-card-header">
                    <span>DATA EXPORT</span>
                    <span class="status-indicator status-info"></span>
                  </div>
                  <div class="rig-card-body" style="flex: 1; overflow-y: auto; padding: var(--space-md);">
                    <p class="config-label" style="margin-bottom: var(--space-md); font-weight: 700;">
                      Export sensor readings and ML metrics for external analysis.
                    </p>
                    
                    <div style="display: grid; gap: var(--space-sm);">
                      <button onclick="exportData('csv')" class="rig-btn-secondary" style="width: 100%;">
                        <span style="margin-right: var(--space-xs);">üìÑ</span>EXPORT AS CSV
                      </button>
                      
                      <button onclick="exportData('json')" class="rig-btn-secondary" style="width: 100%;">
                        <span style="margin-right: var(--space-xs);">üìã</span>EXPORT AS JSON
                      </button>
                      
                      <button onclick="exportLogsPDF()" class="rig-btn-secondary" style="width: 100%;">
                        <span style="margin-right: var(--space-xs);">üìï</span>EXPORT LOGS (PDF)
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Widget 5: LSTM Analysis (Center Bottom) -->
            <div class="grid-stack-item" data-gs-x="4" data-gs-y="9" data-gs-width="4" data-gs-height="4">
              <div class="grid-stack-item-content">
                <div class="grid-item-drag-handle" style="display: none; position: absolute; top: 4px; right: 4px; color: var(--theme-interactive-primary); font-size: 12px; font-weight: bold; z-index: 1000; background: rgba(0, 0, 0, 0.8); padding: 4px 8px; border-radius: 3px; font-family: var(--font-mono); pointer-events: none;">‚ãÆ‚ãÆ DRAG</div>
                <div class="rig-card" style="height: 100%; display: flex; flex-direction: column;">
                  <div class="rig-card-header">
                    <span>üîÆ LSTM ANALYSIS</span>
                    <span class="status-indicator status-info"></span>
                  </div>
                  <div class="rig-card-body" style="flex: 1; overflow-y: auto; padding: var(--space-md);">
                    <p class="config-label" style="margin-bottom: var(--space-md); font-weight: 700;">
                      Generate predictive health reports using LSTM Autoencoder.
                    </p>
                    <div style="display: grid; gap: var(--space-sm);">
                      <button onclick="generateFutureReport(this)" class="scada-btn" style="width: 100%; background: var(--theme-interactive-primary); border-color: var(--theme-interactive-primary); font-weight: 700;">
                        GENERATE FUTURE REPORT
                      </button>
                      <button onclick="generateFullSessionReport(this)" class="scada-btn" style="width: 100%; background: var(--theme-interactive-primary); border-color: var(--theme-interactive-primary); font-weight: 700;">
                        GENERATE FULL SESSION REPORT
                      </button>
                    </div>
                    <div id="lstmReportStatus" style="margin-top: var(--space-sm); font-family: var(--font-mono); font-size: 9px; color: var(--text-muted); text-align: center;"></div>
                  </div>
                </div>
              </div>
            </div>
            
          </div>
          <!-- END GRIDSTACK -->
        </div>
        
        <!-- Admin War Room Section -->
        <div class="scada-section" id="section-admin" style="display: none;">
          <div class="grid-stack" id="adminGrid">
            
            <!-- Widget 1: E-STOP Button -->
            <div class="grid-stack-item" data-gs-x="0" data-gs-y="0" data-gs-width="4" data-gs-height="4">
              <div class="grid-stack-item-content">
                <div class="grid-item-drag-handle" style="display: none; position: absolute; top: 4px; right: 4px; color: var(--theme-interactive-primary); font-size: 12px; font-weight: bold; z-index: 1000; background: rgba(0, 0, 0, 0.8); padding: 4px 8px; border-radius: 3px; font-family: var(--font-mono); pointer-events: none;">‚ãÆ‚ãÆ DRAG</div>
                <div class="rig-card" style="height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; background: var(--bg-primary); border: 3px solid var(--theme-status-error); box-shadow: 0 0 40px rgba(255, 23, 68, 0.6);">
                  <div class="rig-card-header" style="border-bottom: 1px solid var(--theme-status-error); width: 100%;">
                    <span style="color: var(--theme-status-error); font-weight: 900; font-size: 14px;">GLOBAL E-STOP</span>
                    <span class="status-indicator" style="background: var(--theme-status-error);"></span>
                  </div>
                  <div class="rig-card-body" style="flex: 1; display: flex; justify-content: center; align-items: center; padding: var(--space-xl);">
                    <button 
                      onclick="triggerEmergencyStop()" 
                      class="rig-btn" 
                      style="width: 90%; height: 90%; font-size: 24px; font-weight: 900; background: var(--theme-status-error); border: 4px solid var(--theme-status-critical); color: white; box-shadow: 0 0 30px rgba(255, 0, 0, 0.8); cursor: pointer; text-transform: uppercase; letter-spacing: 4px;">
                      E-STOP
                    </button>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Widget 2: User Management (Single Instance) -->
            <div class="grid-stack-item" data-gs-x="4" data-gs-y="0" data-gs-width="8" data-gs-height="6">
              <div class="grid-stack-item-content">
                <div class="grid-item-drag-handle" style="display: none; position: absolute; top: 4px; right: 4px; color: var(--theme-interactive-primary); font-size: 12px; font-weight: bold; z-index: 1000; background: rgba(0, 0, 0, 0.8); padding: 4px 8px; border-radius: 3px; font-family: var(--font-mono); pointer-events: none;">‚ãÆ‚ãÆ DRAG</div>
                <div class="rig-card" style="height: 100%; display: flex; flex-direction: column;">
                  <div class="rig-card-header">
                    <span style="font-weight: 900;">USER MANAGEMENT</span>
                    <span class="status-indicator status-nom"></span>
                  </div>
                  <div class="rig-card-body" style="flex: 1; overflow-y: auto; padding: var(--space-md);">
                    <form id="adminCreateUserForm" onsubmit="adminCreateUser(event)" style="display: grid; gap: var(--space-md); margin-bottom: var(--space-lg);">
                      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: var(--space-sm);">
                        <div>
                          <label class="config-label" style="font-weight: 900;">USERNAME</label>
                          <input type="text" id="adminNewUsername" required class="scada-input" style="width: 100%; padding: var(--space-sm); margin-top: 2px;">
                        </div>
                        <div>
                          <label class="config-label" style="font-weight: 900;">PASSWORD</label>
                          <input type="password" id="adminNewPassword" required class="scada-input" style="width: 100%; padding: var(--space-sm); margin-top: 2px;">
                        </div>
                        <div>
                          <label class="config-label" style="font-weight: 900;">ROLE</label>
                          <select id="adminNewRole" required class="scada-input" style="width: 100%; padding: var(--space-sm); margin-top: 2px; cursor: pointer;">
                            <option value="operator">Operator</option>
                            <option value="admin">Admin</option>
                          </select>
                        </div>
                      </div>
                      <div>
                        <label class="config-label" style="font-weight: 900;">ASSIGNED MACHINES</label>
                        <div style="display: flex; gap: var(--space-md);">
                          <label style="display: flex; align-items: center; gap: var(--space-xs); cursor: pointer;">
                            <input type="checkbox" value="A" class="admin-machine-checkbox" style="cursor: pointer;">
                            <span style="font-family: var(--font-mono); font-size: 11px; font-weight: 700; color: var(--text-primary);">A</span>
                          </label>
                          <label style="display: flex; align-items: center; gap: var(--space-xs); cursor: pointer;">
                            <input type="checkbox" value="B" class="admin-machine-checkbox" style="cursor: pointer;">
                            <span style="font-family: var(--font-mono); font-size: 11px; font-weight: 700; color: var(--text-primary);">B</span>
                          </label>
                          <label style="display: flex; align-items: center; gap: var(--space-xs); cursor: pointer;">
                            <input type="checkbox" value="C" class="admin-machine-checkbox" style="cursor: pointer;">
                            <span style="font-family: var(--font-mono); font-size: 11px; font-weight: 700; color: var(--text-primary);">C</span>
                          </label>
                        </div>
                      </div>
                      <button type="submit" class="rig-btn rig-btn-start" style="width: 100%;">CREATE USER</button>
                      <div id="adminCreateUserError" style="display: none; color: var(--status-error); font-family: var(--font-mono); font-size: 11px; text-align: center; font-weight: 700;"></div>
                      <div id="adminCreateUserSuccess" style="display: none; color: var(--status-running); font-family: var(--font-mono); font-size: 11px; text-align: center; font-weight: 700;"></div>
                    </form>
                    
                    <!-- User List -->
                    <div id="adminUserList" style="margin-top: var(--space-lg);">
                      <div class="config-label" style="font-weight: 900; margin-bottom: var(--space-sm);">EXISTING USERS</div>
                      <div id="adminUserListContent" style="max-height: 300px; overflow-y: auto;">
                        <div class="config-value" style="text-align: center; padding: var(--space-lg);">Loading users...</div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Widget 3: Login & Audit Logs -->
            <div class="grid-stack-item" data-gs-x="0" data-gs-y="6" data-gs-width="8" data-gs-height="4">
              <div class="grid-stack-item-content">
                <div class="grid-item-drag-handle" style="display: none; position: absolute; top: 4px; right: 4px; color: var(--theme-interactive-primary); font-size: 12px; font-weight: bold; z-index: 1000; background: rgba(0, 0, 0, 0.8); padding: 4px 8px; border-radius: 3px; font-family: var(--font-mono); pointer-events: none;">‚ãÆ‚ãÆ DRAG</div>
                <div class="rig-card" style="height: 100%; display: flex; flex-direction: column;">
                  <div class="rig-card-header">
                    <span style="font-weight: 900;">LOGIN & AUDIT LOGS</span>
                    <span class="status-indicator status-nom"></span>
                  </div>
                  <div class="rig-card-body" style="flex: 1; overflow-y: auto; padding: 0;">
                    <table class="scada-admin-table" style="width: 100%; border-collapse: collapse; font-size: 9px;">
                      <thead style="position: sticky; top: 0; background: var(--bg-secondary); z-index: 10;">
                        <tr>
                          <th class="config-table-header" style="font-weight: 900;">TIMESTAMP</th>
                          <th class="config-table-header" style="font-weight: 900;">USER</th>
                          <th class="config-table-header" style="font-weight: 900;">ACTION</th>
                          <th class="config-table-header" style="font-weight: 900;">DETAILS</th>
                        </tr>
                      </thead>
                      <tbody id="adminAuditLogsBody">
                        <tr>
                          <td colspan="4" style="text-align: center; color: var(--text-muted); padding: var(--space-md); font-size: 10px;">Loading audit logs...</td>
                        </tr>
                      </tbody>
                    </table>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Widget 4: Appearance Engine -->
            <div class="grid-stack-item" data-gs-x="8" data-gs-y="6" data-gs-width="4" data-gs-height="4">
              <div class="grid-stack-item-content">
                <div class="grid-item-drag-handle" style="display: none; position: absolute; top: 4px; right: 4px; color: var(--theme-interactive-primary); font-size: 12px; font-weight: bold; z-index: 1000; background: rgba(0, 0, 0, 0.8); padding: 4px 8px; border-radius: 3px; font-family: var(--font-mono); pointer-events: none;">‚ãÆ‚ãÆ DRAG</div>
                <div class="rig-card" style="height: 100%; display: flex; flex-direction: column;">
                  <div class="rig-card-header">
                    <span style="font-weight: 900;">APPEARANCE ENGINE</span>
                    <span class="status-indicator status-nom"></span>
                  </div>
                  <div class="rig-card-body" style="flex: 1; overflow-y: auto; padding: var(--space-md); display: grid; gap: var(--space-md);">
                    <div>
                      <label class="config-label" style="font-weight: 900; margin-bottom: var(--space-sm); display: block;">THEME MODE</label>
                      <div style="display: grid; gap: var(--space-sm);">
                        <button 
                          id="barbieModeToggle" 
                          onclick="toggleBarbieModeButton()" 
                          class="scada-btn" 
                          style="width: 100%; background: var(--theme-interactive-primary); border-color: var(--theme-interactive-primary); font-weight: 900; font-size: 11px; padding: var(--space-sm); color: var(--text-primary);">
                          BARBIE MODE: <span id="barbieModeStatus">OFF</span>
                        </button>
                        <button 
                          id="matrixModeToggle" 
                          onclick="toggleMatrixModeButton()" 
                          class="scada-btn" 
                          style="width: 100%; background: var(--theme-interactive-primary); border-color: var(--theme-interactive-primary); font-weight: 900; font-size: 11px; padding: var(--space-sm); color: var(--text-primary);">
                          MATRIX MODE: <span id="matrixModeStatus">OFF</span>
                        </button>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
          </div>
        </div>
        
        <!-- Old Users Section (to be removed) -->
        <div id="sectionUsersContent" style="display: none;">
              <button onclick="toggleSignupForm()" class="scada-btn" style="width: 100%; margin-bottom: var(--space-lg);">
                CREATE NEW USER
              </button>
              <div id="signupForm" style="display: none;">
                <!-- Signup form will be shown here when toggled -->
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Legacy Machine and Mode Controls (hidden, kept for compatibility) -->
      <div class="machine-mode-controls" style="display: none;">
        <div class="machine-selector">
          <label>Machine:</label>
          <div class="machine-buttons">
            <button class="machine-btn active" data-machine="A" onclick="selectMachine('A')">Machine A</button>
            <button class="machine-btn" data-machine="B" onclick="selectMachine('B')">Machine B</button>
            <button class="machine-btn" data-machine="C" onclick="selectMachine('C')">Machine C</button>
          </div>
        </div>
        <div class="mode-toggle">
          <label>Mode:</label>
          <div class="mode-buttons">
            <button class="mode-btn active" data-mode="operator" onclick="switchMode('operator')">Operator</button>
            <button class="mode-btn" data-mode="admin" onclick="switchMode('admin')">Admin</button>
          </div>
        </div>
      </div>

      <!-- Admin Panel (moved to collapsible sidebar) -->
      <div class="admin-panel" id="adminPanel" style="display: none;">
        <div class="admin-section">
          <h3>‚öôÔ∏è Sensor Management - Machine <span id="adminMachineLabel">A</span></h3>
          <p class="card-intro" style="margin-bottom: 16px;">
            Enable/disable sensors and set baseline values for the selected machine. Changes apply immediately to Operator Mode.
          </p>
          <div id="adminSensorControls"></div>
        </div>
        
        <div class="admin-section">
          <h3>‚ûï Custom Sensor Management</h3>
          <p class="card-intro" style="margin-bottom: 16px;">
            Add and manage custom sensor parameters. New sensors will appear in producer messages and dashboard stats.
          </p>
          
          <!-- Add New Sensor Form -->
          <div style="margin-bottom: 24px; padding: 20px; background: rgba(15, 23, 42, 0.6); border-radius: 12px; border: 1px solid rgba(96, 165, 250, 0.2);">
            <h4 style="color: #60a5fa; margin-bottom: 16px; font-size: 14px; text-transform: uppercase; letter-spacing: 1px;">Add New Custom Sensor</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; margin-bottom: 12px;">
              <div>
                <label style="display: block; color: #94a3b8; font-size: 12px; margin-bottom: 6px; text-transform: uppercase;">Sensor Name *</label>
                <input type="text" id="oldNewSensorName" placeholder="e.g., bearing_vibration_rms" 
                       style="width: 100%; padding: 8px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 6px; color: #e2e8f0; font-size: 14px;">
              </div>
              <div>
                <label style="display: block; color: #94a3b8; font-size: 12px; margin-bottom: 6px; text-transform: uppercase;">Category</label>
                <select id="oldNewSensorCategory" 
                        style="width: 100%; padding: 8px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 6px; color: #e2e8f0; font-size: 14px;">
                  <option value="custom">Custom Parameters</option>
                  <option value="environmental">Environmental</option>
                  <option value="mechanical">Mechanical</option>
                  <option value="thermal">Thermal</option>
                  <option value="electrical">Electrical</option>
                  <option value="fluid">Fluid Dynamics</option>
                </select>
              </div>
              <div>
                <label style="display: block; color: #94a3b8; font-size: 12px; margin-bottom: 6px; text-transform: uppercase;">Unit</label>
                <input type="text" id="oldNewSensorUnit" placeholder="e.g., mm/s, ¬∞F, PSI" 
                       style="width: 100%; padding: 8px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 6px; color: #e2e8f0; font-size: 14px;">
              </div>
              <div>
                <label style="display: block; color: #94a3b8; font-size: 12px; margin-bottom: 6px; text-transform: uppercase;">Min Range *</label>
                <input type="number" step="any" id="newSensorMinRange" placeholder="0.0" 
                       style="width: 100%; padding: 8px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 6px; color: #e2e8f0; font-size: 14px;">
              </div>
              <div>
                <label style="display: block; color: #94a3b8; font-size: 12px; margin-bottom: 6px; text-transform: uppercase;">Max Range *</label>
                <input type="number" step="any" id="newSensorMaxRange" placeholder="100.0" 
                       style="width: 100%; padding: 8px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 6px; color: #e2e8f0; font-size: 14px;">
              </div>
              <div>
                <label style="display: block; color: #94a3b8; font-size: 12px; margin-bottom: 6px; text-transform: uppercase;">Low Threshold</label>
                <input type="number" step="any" id="newSensorLowThreshold" placeholder="Optional" 
                       style="width: 100%; padding: 8px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 6px; color: #e2e8f0; font-size: 14px;">
              </div>
              <div>
                <label style="display: block; color: #94a3b8; font-size: 12px; margin-bottom: 6px; text-transform: uppercase;">High Threshold</label>
                <input type="number" step="any" id="newSensorHighThreshold" placeholder="Optional" 
                       style="width: 100%; padding: 8px; background: rgba(15, 23, 42, 0.8); border: 1px solid rgba(148, 163, 184, 0.2); border-radius: 6px; color: #e2e8f0; font-size: 14px;">
              </div>
            </div>
            <button onclick="addCustomSensor()" 
                    style="padding: 10px 24px; background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 14px;">
              ‚ûï Add Custom Sensor
            </button>
            <div id="customSensorMessage" style="margin-top: 12px; font-size: 13px;"></div>
          </div>
          
          <!-- Custom Sensors List -->
          <div>
            <h4 style="color: #60a5fa; margin-bottom: 16px; font-size: 14px; text-transform: uppercase; letter-spacing: 1px;">Existing Custom Sensors</h4>
            <div id="customSensorsList" style="min-height: 100px;">
              <div style="text-align: center; color: #94a3b8; padding: 20px;">Loading custom sensors...</div>
            </div>
          </div>
        </div>
      </div>

      <details class="hero-info" id="onboardingDetails">
        <summary>
          <span>?? New to this dashboard? Click to learn how it works.</span>
          <span class="chevron">‚ñº</span>
        </summary>
        <div class="hero-wrapper">
          <div class="hero">
            <div>
              <h3>Quick start steps</h3>
              <p>
                This panel lets you start, stop, and watch an entire demo
                factory pipeline. Follow the three quick steps below and the
                rest of the cards will begin to fill themselves in.
              </p>
              <ul class="step-list">
                <li>
                  <span class="step-number">1</span>
                  <div>
                    <strong>Start the Consumer (Waiter)</strong>
                    <div class="hero-note">
                      It listens for new readings and writes them into
                      PostgreSQL. Start this before anything else.
                    </div>
                  </div>
                </li>
                <li>
                  <span class="step-number">2</span>
                  <div>
                    <strong>Start the Producer (Data maker)</strong>
                    <div class="hero-note">
                      This generates pretend sensor readings and hands them to
                      Kafka so the consumer has something to save.
                    </div>
                  </div>
                </li>
                <li>
                  <span class="step-number">3</span>
                  <div>
                    <strong>Watch the Status, Alerts, and Live Readings</strong>
                    <div class="hero-note">
                      Green dots mean the pieces are healthy. Any alert shows up
                      in plain English so you know what needs attention.
                    </div>
                  </div>
                </li>
              </ul>
              <div class="info-pill">
                ‚ú≥ Need a shortcut? Use the presets in the Configuration card and
                keep this page open to see everything update in real time.
              </div>
            </div>
            <div>
              <h3>What is happening end-to-end?</h3>
              <div class="pipeline-flow" aria-label="Pipeline overview">
                <div class="flow-node">
                  <div class="flow-title">Producer</div>
                  <div class="flow-text">
                    Creates fake machine readings based on the ranges in
                    <code>config.py</code>.
                  </div>
                </div>
                <div class="flow-arrow">‚Üí</div>
                <div class="flow-node">
                  <div class="flow-title">Kafka</div>
                  <div class="flow-text">
                    Acts like a conveyor belt. Messages queue here until the
                    consumer grabs them.
                  </div>
                </div>
                <div class="flow-arrow">‚Üí</div>
                <div class="flow-node">
                  <div class="flow-title">Consumer</div>
                  <div class="flow-text">
                    Validates each reading, flags anomalies, and writes
                    everything to the database.
                  </div>
                </div>
                <div class="flow-arrow">‚Üí</div>
                <div class="flow-node">
                  <div class="flow-title">Database</div>
                  <div class="flow-text">
                    Stores the official record shown in the stats, alerts, and
                    history sections.
                  </div>
                </div>
              </div>
              <h3 style="margin-top: 20px">What the colors mean</h3>
              <div class="legend">
                <div class="legend-item">
                  <span class="status-indicator status-running"></span>
                  Running and healthy
                </div>
                <div class="legend-item">
                  <span class="status-indicator status-stopped"></span>
                  Stopped or not reachable
                </div>
                <div class="legend-item">
                  <span class="status-indicator status-pending"></span>
                  Starting up / waiting on a reply
                </div>
                <div class="legend-item">
                  <span class="status-indicator status-unknown"></span>
                  Not checked yet (refreshing soon)
                </div>
              </div>
              <div class="hero-note" style="margin-top: 16px">
                Tip: If you forget what a section is for, read the short
                description right under each card heading.
              </div>
            </div>
          </div>
        </div>
      </details>

      <div class="grid" style="display: none;">
        <!-- Stats Card (hidden - replaced by SCADA layout) -->
        <div class="card" style="display: none;">
          <h2>üìä Statistics</h2>
          <p class="card-intro">
            Shows how many readings have been saved and highlights the latest
            sensor values. If you just started the pipeline, this number will
            ramp up as messages flow through.
          </p>
          <div class="big-stat">
            <div class="big-stat-value" id="totalCount">0</div>
            <div class="big-stat-label">Total Messages</div>
          </div>
          <div class="tabs" id="statsCategoryTabs"></div>
          <div id="statsCategoryContent"></div>
        </div>

        <!-- Control Card (hidden - moved to admin sidebar) -->
        <div class="card" style="display: none;">
          <h2>‚öôÔ∏è Controls</h2>
          <p class="card-intro">
            Think of this as the on/off switchboard. Start the consumer first,
            then the producer. Stop buttons immediately send a shutdown signal
            to each Python process.
          </p>
          <div class="stat">
            <span class="stat-label">
              <span class="status-indicator" id="producerStatus"></span>
              Producer
            </span>
          </div>
          <div class="controls">
            <button class="btn-success" onclick="startComponent('producer')">
              ‚ñ∂ Start
            </button>
            <button class="btn-danger" onclick="stopComponent('producer')">
              ‚èπ Stop
            </button>
          </div>

          <div class="stat" style="margin-top: 20px">
            <span class="stat-label">
              <span class="status-indicator" id="consumerStatus"></span>
              Consumer
            </span>
          </div>
          <div class="controls">
            <button class="btn-success" onclick="startComponent('consumer')">
              ‚ñ∂ Start
            </button>
            <button class="btn-danger" onclick="stopComponent('consumer')">
              ‚èπ Stop
            </button>
          </div>

          <div class="stat" style="margin-top: 20px">
            <span class="stat-label">
              <span class="status-indicator" id="kafkaStatus"></span>
              Kafka Broker
            </span>
            <span class="stat-value" id="kafkaStatusDetails">Checking...</span>
          </div>

          <div class="controls" style="margin-top: 20px">
            <button class="btn-secondary" onclick="exportData()">
              üóÇÔ∏è Export CSV
            </button>
            <button class="btn-warning" onclick="clearData()">
              üóëÔ∏è Clear All Data
            </button>
          </div>

          <!-- Display Refresh Rate Control -->
          <div style="margin-top: 24px; padding-top: 24px; border-top: 1px solid rgba(148, 163, 184, 0.1);">
            <label style="font-size: 13px; color: #94a3b8; display: block; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 1px; font-weight: 600;">
              Display Refresh Rate
            </label>
            <p style="font-size: 12px; color: #64748b; margin-bottom: 12px; line-height: 1.4;">
              Controls how often the Live Sensor Readings panel updates. Does not affect data collection.
            </p>
            <div style="display: flex; gap: 8px; flex-wrap: wrap;">
              <button class="btn-primary refresh-rate-btn active" data-interval="1000" onclick="setRefreshRate(1000)" style="font-size: 12px; padding: 8px 16px;">
                1s
              </button>
              <button class="btn-primary refresh-rate-btn" data-interval="5000" onclick="setRefreshRate(5000)" style="font-size: 12px; padding: 8px 16px;">
                5s
              </button>
              <button class="btn-primary refresh-rate-btn" data-interval="10000" onclick="setRefreshRate(10000)" style="font-size: 12px; padding: 8px 16px;">
                10s
              </button>
              <button class="btn-primary refresh-rate-btn" data-interval="30000" onclick="setRefreshRate(30000)" style="font-size: 12px; padding: 8px 16px;">
                30s
              </button>
            </div>
          </div>
        </div>

        <!-- Configuration Card (hidden - moved to admin sidebar) -->
        <div class="card" style="display: none;">
          <h2>üîß Configuration</h2>

          <p class="card-intro">
            Tell the producer how long to run and how often to send readings.
            The dashboard calculates the total messages for you and keeps the
            last update visible below.
          </p>
          <label>Duration</label>
          <div class="input-group">
            <div class="input-wrapper">
              <span class="input-label">Hours</span>
              <input type="number" id="durationHours" min="0" value="0" />
            </div>
            <div class="input-wrapper">
              <span class="input-label">Minutes</span>
              <input
                type="number"
                id="durationMinutes"
                min="0"
                max="59"
                value="0"
              />
            </div>
          </div>

          <label>Interval</label>
          <div class="input-wrapper">
            <span class="input-label">Seconds</span>
            <input type="number" id="intervalSeconds" value="30" />
          </div>

          <div class="controls">
            <button class="btn-primary" onclick="updateConfig()">
              üíæ Update Config
            </button>
            <button class="btn-secondary" onclick="resetConfig()">
              üîÑ Reset Defaults
            </button>
          </div>
          <div class="config-meta" id="configMessage">Ready for updates.</div>

          <div class="preset-container">
            <div class="preset-title">‚ö° Quick Presets</div>
            <div class="preset-buttons">
              <button class="btn-primary" onclick="setQuickTest()">
                Quick Test
              </button>
              <button class="btn-primary" onclick="setOneMin()">
                1 Minute
              </button>
              <button class="btn-primary" onclick="setOneHour()">1 Hour</button>
              <button class="btn-primary" onclick="setProduction()">
                24 Hours
              </button>
            </div>
          </div>
        </div>

        <!-- Alerts Card (hidden - replaced by alarm console) -->
        <div class="card" style="display: none;">
          <h2>üö® Alerts</h2>
          <p class="card-intro">
            Every anomaly, failure, or manual action is stored here in plain
            English. Use it as the event log when something looks off.
          </p>
          <div class="alert-list" id="alertList">
            <div style="text-align: center; color: #94a3b8; padding: 20px">
              No alerts yet
            </div>
          </div>
        </div>
      </div>

      <!-- LSTM Future Prediction Card (hidden - moved to admin sidebar) -->
      <div class="card" style="display: none; margin-bottom: 24px">
        <h2>üîÆ LSTM Future Anomaly Prediction</h2>
        <p class="card-intro">
          LSTM Autoencoder analyzes temporal patterns to predict potential future anomalies.
        </p>
        
        <!-- LSTM Status -->
        <div id="lstmStatusContainer" style="margin-bottom: 20px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <span style="font-weight: 600; color: #cbd5e1;">Training Quality</span>
            <span id="lstmQualityPercent" style="font-weight: 600; color: #10b981;">--</span>
          </div>
          <div style="background: #1e293b; border-radius: 8px; height: 24px; overflow: hidden; position: relative;">
            <div id="lstmQualityBar" style="
              height: 100%;
              width: 0%;
              background: linear-gradient(90deg, #ef4444, #f59e0b, #10b981);
              transition: width 0.5s ease, background 0.5s ease;
              border-radius: 8px;
            "></div>
            <div style="
              position: absolute;
              top: 0;
              left: 0;
              right: 0;
              bottom: 0;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 12px;
              font-weight: 600;
              color: white;
              text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            " id="lstmQualityText">Loading...</div>
          </div>
          <div id="lstmStatusMessage" style="margin-top: 8px; font-size: 13px; color: #94a3b8; text-align: center;">
            Checking LSTM status...
          </div>
        </div>

        <!-- Current Prediction -->
        <div id="lstmPredictionContainer" style="
          background: linear-gradient(135deg, #1e293b, #0f172a);
          border: 1px solid #334155;
          border-radius: 12px;
          padding: 20px;
          margin-bottom: 16px;
        ">
          <h3 style="margin: 0 0 16px 0; color: #e2e8f0; font-size: 16px;">Current Risk Assessment</h3>
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin-bottom: 16px;">
            <div>
              <div style="font-size: 12px; color: #94a3b8; margin-bottom: 4px;">Risk Score</div>
              <div id="lstmRiskScore" style="font-size: 24px; font-weight: 700; color: #10b981;">--</div>
            </div>
            <div>
              <div style="font-size: 12px; color: #94a3b8; margin-bottom: 4px;">Confidence</div>
              <div id="lstmConfidence" style="font-size: 24px; font-weight: 700; color: #3b82f6;">--</div>
            </div>
          </div>

          <div style="margin-bottom: 12px;">
            <div style="font-size: 12px; color: #94a3b8; margin-bottom: 4px;">Predicted Window</div>
            <div id="lstmPredictedWindow" style="font-size: 14px; color: #e2e8f0; font-weight: 500;">--</div>
          </div>

          <div style="margin-bottom: 12px;">
            <div style="font-size: 12px; color: #94a3b8; margin-bottom: 4px;">Trend</div>
            <div id="lstmTrend" style="font-size: 14px; color: #e2e8f0; font-weight: 500;">--</div>
          </div>

          <div>
            <div style="font-size: 12px; color: #94a3b8; margin-bottom: 4px;">Contributing Sensors</div>
            <div id="lstmSensors" style="font-size: 13px; color: #cbd5e1;">--</div>
          </div>
        </div>

        <!-- Problematic Sensors Analysis -->
        <div id="lstmSensorAnalysisContainer" style="
          background: linear-gradient(135deg, #1e293b, #0f172a);
          border: 1px solid #334155;
          border-radius: 12px;
          padding: 20px;
          margin-bottom: 16px;
          display: none;
        ">
          <h3 style="margin: 0 0 16px 0; color: #e2e8f0; font-size: 16px;">üîç Problematic Sensors Analysis</h3>
          <p style="margin: 0 0 16px 0; font-size: 13px; color: #94a3b8;">
            Sensors that are trending toward problems and why:
          </p>
          <div id="lstmSensorAnalysisList" style="display: flex; flex-direction: column; gap: 12px;">
            <!-- Sensor analysis items will be inserted here -->
          </div>
        </div>

        <!-- Generate Future Report Button -->
        <button
          id="generateFutureReportBtn"
          onclick="generateFutureReport(this)"
          style="
            width: 100%;
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            color: white;
            border: none;
            padding: 14px 24px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 15px;
          "
        >
          <span>üìä</span>
          <span>Generate Future Anomaly Report (PDF)</span>
        </button>
      </div>

      <!-- ML Anomaly Detection Card (hidden - moved to admin sidebar) -->
      <div class="card" style="display: none; margin-bottom: 24px">
        <div
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
          "
        >
          <h2 style="margin: 0">ü§ñ ML Anomaly Detection</h2>
          <button
            id="fullReportBtn"
            onclick="generateFullSessionReport(this)"
            style="
              background: linear-gradient(135deg, #10b981, #059669);
              color: white;
              border: none;
              padding: 12px 24px;
              border-radius: 8px;
              font-weight: 600;
              cursor: pointer;
              display: flex;
              align-items: center;
              gap: 8px;
              box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
              transition: all 0.3s ease;
            "
          >
            üìä Generate Full Session Report
          </button>
        </div>
        <p class="card-intro">
          Isolation Forest model detects unusual patterns across all 50 sensor
          parameters. Click "Generate Report" for individual analysis, or "Full
          Session Report" for comprehensive analysis of ALL anomalies.
        </p>

        <!-- ML Stats -->
        <div
          style="
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 16px;
            margin-bottom: 20px;
          "
        >
          <div class="big-stat" style="padding: 20px">
            <div
              class="big-stat-value"
              id="mlTotalAnomalies"
              style="font-size: 36px"
            >
              0
            </div>
            <div class="big-stat-label">Anomalies Detected</div>
          </div>
          <div class="big-stat" style="padding: 20px">
            <div
              class="big-stat-value"
              id="mlAnomalyRate"
              style="font-size: 36px"
            >
              0%
            </div>
            <div class="big-stat-label">Recent Rate</div>
          </div>
          <div class="big-stat" style="padding: 20px">
            <div
              class="big-stat-value"
              id="mlReportsGenerated"
              style="font-size: 36px"
            >
              0
            </div>
            <div class="big-stat-label">Reports Generated</div>
          </div>
        </div>

        <!-- Anomaly List -->
        <div
          class="anomaly-list"
          id="anomalyList"
          style="max-height: 400px; overflow-y: auto"
        >
          <div style="text-align: center; color: #94a3b8; padding: 40px">
            No ML anomalies detected yet. Start the pipeline to begin
            monitoring.
          </div>
        </div>

        <!-- Anomaly Injection Controls (hidden - moved to admin sidebar) -->
        <div
          id="injectionControls"
          style="display: none; margin-top: 24px; padding: 20px; background: rgba(239, 68, 68, 0.1); border-radius: 12px; border: 1px solid rgba(239, 68, 68, 0.3);"
        >
          <h3 style="margin: 0 0 16px 0; color: #f87171; font-size: 16px">
            üéØ Anomaly Injection Controls
          </h3>
          <p style="font-size: 13px; color: #94a3b8; margin-bottom: 16px">
            Control when anomalies are injected into the sensor data stream. Set
            custom thresholds above, then schedule anomaly injections here.
          </p>

          <div
            style="
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
              gap: 16px;
            "
          >
            <!-- Enable/Disable -->
            <div
              style="
                background: rgba(15, 23, 42, 0.6);
                padding: 16px;
                border-radius: 8px;
              "
            >
              <label
                style="
                  display: flex;
                  align-items: center;
                  gap: 10px;
                  cursor: pointer;
                "
              >
                <input
                  type="checkbox"
                  id="injectionEnabled"
                  onchange="toggleInjection()"
                  style="width: 20px; height: 20px; cursor: pointer"
                />
                <span style="font-size: 14px; color: #e2e8f0"
                  >Enable Scheduled Anomalies</span
                >
              </label>
            </div>

            <!-- Interval Setting -->
            <div
              style="
                background: rgba(15, 23, 42, 0.6);
                padding: 16px;
                border-radius: 8px;
              "
            >
              <label
                style="
                  font-size: 12px;
                  color: #94a3b8;
                  display: block;
                  margin-bottom: 8px;
                "
                >Inject Anomaly Every</label
              >
              <div style="display: flex; align-items: center; gap: 8px">
                <input
                  type="number"
                  id="injectionInterval"
                  value="30"
                  min="1"
                  max="1440"
                  style="
                    width: 80px;
                    padding: 8px;
                    background: rgba(15, 23, 42, 0.8);
                    border: 1px solid rgba(148, 163, 184, 0.3);
                    border-radius: 6px;
                    color: #e2e8f0;
                    font-size: 14px;
                    text-align: center;
                  "
                />
                <span style="color: #94a3b8">minutes</span>
                <button
                  onclick="updateInjectionInterval()"
                  style="
                    background: #3b82f6;
                    color: white;
                    border: none;
                    padding: 8px 16px;
                    border-radius: 6px;
                    font-size: 12px;
                    cursor: pointer;
                  "
                >
                  Set
                </button>
              </div>
            </div>

            <!-- Inject Now Button -->
            <div
              style="
                background: rgba(15, 23, 42, 0.6);
                padding: 16px;
                border-radius: 8px;
              "
            >
              <label
                style="
                  font-size: 12px;
                  color: #94a3b8;
                  display: block;
                  margin-bottom: 8px;
                "
                >Manual Trigger</label
              >
              <button
                id="injectNowBtn"
                onclick="injectAnomalyNow(this)"
                style="
                  background: linear-gradient(135deg, #ef4444, #dc2626);
                  color: white;
                  border: none;
                  padding: 12px 24px;
                  border-radius: 8px;
                  font-weight: 600;
                  cursor: pointer;
                  width: 100%;
                  font-size: 14px;
                "
              >
                ‚ö° Inject Anomaly NOW
              </button>
            </div>
          </div>

          <!-- Status -->
          <div
            id="injectionStatus"
            style="
              margin-top: 16px;
              padding: 12px;
              background: rgba(15, 23, 42, 0.4);
              border-radius: 8px;
              font-size: 13px;
              color: #64748b;
            "
          >
            Injection disabled. Enable to schedule automatic anomalies.
          </div>
        </div>
      </div>

      <!-- Report Modal (Individual Anomaly) -->
      <div id="reportModal" class="modal" style="display: none">
        <div class="modal-content">
          <div class="modal-header">
            <h2>üìã Anomaly Analysis Report</h2>
            <div style="display: flex; gap: 12px; align-items: center;">
              <button 
                id="downloadReportBtn" 
                class="btn-download-report" 
                onclick="downloadCurrentReport()"
                style="display: none;"
              >
                üì• Download
              </button>
              <button class="modal-close" onclick="closeReportModal()">
                &times;
              </button>
            </div>
          </div>
          <div class="modal-body" id="reportContent">Loading...</div>
        </div>
      </div>

      <!-- Full Session Report Modal -->
      <div id="fullReportModal" class="modal" style="display: none">
        <div class="modal-content" style="max-width: 1000px; max-height: 90vh">
          <div
            class="modal-header"
            style="background: linear-gradient(135deg, #10b981, #059669)"
          >
            <h2 style="color: white">üìä Full Session Analysis Report</h2>
            <button
              class="modal-close"
              onclick="closeFullReportModal()"
              style="color: white"
            >
              &times;
            </button>
          </div>
          <div
            class="modal-body"
            id="fullReportContent"
            style="overflow-y: auto; max-height: calc(90vh - 80px)"
          >
            <div style="text-align: center; padding: 60px">
              <div
                class="loading-spinner"
                style="width: 48px; height: 48px; margin: 0 auto 20px"
              ></div>
              <p style="color: #94a3b8; font-size: 16px">
                Analyzing all anomalies with AI...
              </p>
              <p style="color: #64748b; font-size: 14px">
                This may take a minute for comprehensive analysis.
              </p>
            </div>
          </div>
        </div>
      </div>

      <!-- 50 Parameters by Category (hidden - moved to health card modal) -->
      <div class="card" style="display: none;">
        <h2>üéØ All Sensor Parameters (50)</h2>
        <p class="card-intro">
          Grouped by category so you can see how the 50 different readings are
          trending without memorizing names. Toggle categories to focus on the
          ones you care about.
        </p>
        <div class="tabs" id="categoryTabs"></div>
        <div id="categoryContent"></div>
      </div>

      <!-- Readings History Card (hidden - moved to health card modal) -->
      <div class="card" style="display: none;">
        <h2>üì° Live Sensor Readings</h2>
        <p class="card-intro">
          A rolling timeline of raw values pulled straight from the database.
          Pick a category and skim the cards to spot jumps or dips.
        </p>
        <label>Select Category to Monitor</label>
        <select
          id="historyCategory"
          onchange="changeHistoryCategory()"
          style="
            width: 100%;
            padding: 14px;
            border-radius: 12px;
            background: rgba(15, 23, 42, 0.6);
            color: #e2e8f0;
            border: 1px solid rgba(148, 163, 184, 0.2);
            font-size: 15px;
            font-weight: 600;
            margin-bottom: 20px;
            cursor: pointer;
          "
        >
          <option value="environmental">üåç Environmental Sensors</option>
          <option value="mechanical">‚öôÔ∏è Mechanical Sensors</option>
          <option value="thermal">üî• Thermal Sensors</option>
          <option value="electrical">‚ö° Electrical Sensors</option>
          <option value="fluid">üíß Fluid Dynamics Sensors</option>
        </select>
        <div class="history-container" id="readingsHistory"></div>
      </div>
    </div>
    
    <!-- Health Card Detail Modal -->
    <div id="healthCardModal" class="scada-modal" style="display: none;">
      <div class="scada-modal-overlay" onclick="closeHealthCardModal()"></div>
      <div class="scada-modal-content">
        <div class="scada-modal-header">
          <h3 id="healthModalTitle">CATEGORY DETAILS</h3>
          <button onclick="closeHealthCardModal()" class="scada-modal-close">‚úï</button>
        </div>
        <div class="scada-modal-body" id="healthModalContent">
          <!-- Sensor list will be populated here -->
        </div>
      </div>
    </div>
    
    <!-- Admin Sidebar (collapsible) -->
    <div id="adminSidebar" class="scada-sidebar">
      <div class="scada-sidebar-header">
        <h3>ADMIN PANEL</h3>
        <button onclick="toggleAdminSidebar()" class="scada-sidebar-toggle">‚úï</button>
      </div>
      <div class="scada-sidebar-content" id="adminSidebarContent">
        <!-- Admin content will be moved here -->
      </div>
    </div>
    
    <!-- Admin Sidebar Toggle Button (only visible to admins) -->
    <button id="adminSidebarToggleBtn" onclick="toggleAdminSidebar()" class="scada-sidebar-toggle-btn" style="display: none;">
      ‚öôÔ∏è
    </button>
    
    <!-- Kafka Controls Modal -->
    <div id="kafkaControlsModal" class="scada-modal" style="display: none;">
      <div class="scada-modal-overlay" onclick="closeKafkaControlsModal()"></div>
      <div class="scada-modal-content" style="max-width: 600px;">
        <div class="scada-modal-header">
          <h3>KAFKA CONTROLS</h3>
          <button onclick="closeKafkaControlsModal()" class="scada-modal-close">‚úï</button>
        </div>
        <div class="scada-modal-body">
          <div style="display: grid; gap: var(--space-lg);">
            <!-- Producer Controls -->
            <div>
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-md);">
                <div style="font-family: var(--font-mono); font-size: 12px; font-weight: 600; color: var(--text-primary); text-transform: uppercase;">
                  PRODUCER
                </div>
                <div style="display: flex; align-items: center; gap: var(--space-xs);">
                  <div class="scada-status-dot-indicator" id="modalProducerStatus"></div>
                  <span style="font-family: var(--font-mono); font-size: 10px; color: var(--text-muted);" id="modalProducerStatusText">STOPPED</span>
                </div>
              </div>
              <div style="display: flex; gap: var(--space-sm);">
                <button onclick="startComponent('producer'); closeKafkaControlsModal();" class="scada-btn" style="flex: 1;">START</button>
                <button onclick="stopComponent('producer'); closeKafkaControlsModal();" class="scada-btn" style="flex: 1;">STOP</button>
              </div>
            </div>
            
            <!-- Consumer Controls -->
            <div>
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-md);">
                <div style="font-family: var(--font-mono); font-size: 12px; font-weight: 600; color: var(--text-primary); text-transform: uppercase;">
                  CONSUMER
                </div>
                <div style="display: flex; align-items: center; gap: var(--space-xs);">
                  <div class="scada-status-dot-indicator" id="modalConsumerStatus"></div>
                  <span style="font-family: var(--font-mono); font-size: 10px; color: var(--text-muted);" id="modalConsumerStatusText">STOPPED</span>
                </div>
              </div>
              <div style="display: flex; gap: var(--space-sm);">
                <button onclick="startComponent('consumer'); closeKafkaControlsModal();" class="scada-btn" style="flex: 1;">START</button>
                <button onclick="stopComponent('consumer'); closeKafkaControlsModal();" class="scada-btn" style="flex: 1;">STOP</button>
              </div>
            </div>
            
            <!-- Kafka Status -->
            <div style="padding: var(--space-md); background: var(--bg-tertiary); border: 1px solid var(--border-subtle); border-radius: 4px;">
              <div style="font-family: var(--font-mono); font-size: 11px; color: var(--text-muted); margin-bottom: var(--space-xs); text-transform: uppercase;">
                KAFKA BROKER
              </div>
              <div style="display: flex; align-items: center; gap: var(--space-sm);">
                <div class="scada-status-dot-indicator" id="modalKafkaStatus"></div>
                <span style="font-family: var(--font-mono); font-size: 11px; color: var(--text-primary);" id="modalKafkaStatusText">Checking...</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Anomaly Injection Modal -->
    <div id="anomalyInjectionModal" class="scada-modal" style="display: none;">
      <div class="scada-modal-overlay" onclick="closeAnomalyInjectionModal()"></div>
      <div class="scada-modal-content" style="max-width: 700px;">
        <div class="scada-modal-header">
          <h3>ANOMALY INJECTION</h3>
          <button onclick="closeAnomalyInjectionModal()" class="scada-modal-close">‚úï</button>
        </div>
        <div class="scada-modal-body">
          <div style="display: grid; gap: var(--space-lg);">
            <!-- Manual Injection -->
            <div>
              <div style="font-family: var(--font-mono); font-size: 11px; color: var(--text-muted); margin-bottom: var(--space-md); text-transform: uppercase;">
                MANUAL INJECTION
              </div>
              <button onclick="injectAnomalyNow(this); closeAnomalyInjectionModal();" class="scada-btn critical" style="width: 100%;">
                INJECT ANOMALY NOW
              </button>
            </div>
            
            <!-- Scheduled Injection -->
            <div style="padding: var(--space-lg); background: var(--bg-tertiary); border: 1px solid var(--border-subtle); border-radius: 4px;">
              <div style="font-family: var(--font-mono); font-size: 11px; color: var(--text-muted); margin-bottom: var(--space-md); text-transform: uppercase;">
                SCHEDULED INJECTION
              </div>
              <div style="display: grid; gap: var(--space-md);">
                <label style="display: flex; align-items: center; gap: var(--space-sm); cursor: pointer;">
                  <input type="checkbox" id="modalInjectionEnabled" onchange="toggleInjection()" style="cursor: pointer; width: 18px; height: 18px;">
                  <span style="font-family: var(--font-mono); font-size: 11px; color: var(--text-primary);">ENABLE SCHEDULED INJECTION</span>
                </label>
                <div>
                  <label style="display: block; font-family: var(--font-mono); font-size: 10px; color: var(--text-muted); margin-bottom: var(--space-xs); text-transform: uppercase;">
                    INTERVAL (MINUTES)
                  </label>
                  <input type="number" id="modalInjectionInterval" value="30" min="1" max="1440" 
                         style="width: 100%; padding: var(--space-sm); background: var(--bg-secondary); border: 1px solid var(--border-default); border-radius: 4px; color: var(--text-primary); font-family: var(--font-mono); font-size: 12px;"
                         onchange="updateInjectionInterval()">
                </div>
                <button onclick="updateInjectionSettings(); closeAnomalyInjectionModal();" class="scada-btn" style="width: 100%;">
                  SAVE SETTINGS
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // ========== Authentication State ==========
      let currentUser = null;
      let accessibleMachines = [];

      // Check authentication on page load
      async function checkAuth() {
        try {
          const response = await fetch('/api/auth/me');
          if (response.ok) {
            const data = await response.json();
            // Show/hide admin icon based on role
            const adminIcon = document.getElementById('sidebarAdminIcon');
            if (adminIcon) {
              adminIcon.style.display = (data.role === 'admin') ? 'flex' : 'none';
            }
            if (data.success) {
              currentUser = data.user;
              accessibleMachines = data.user.accessible_machines || [];
              showDashboard();
              filterMachineSelector();
              updateUserInfo();
              if (currentUser.role === 'admin') {
                // Initialize admin sidebar for admins
                initializeAdminSidebar();
                // Show admin sections in configuration
                const adminLogsSection = document.getElementById('adminOperatorLogsSection');
                const adminSmartSensorSection = document.getElementById('adminSmartSensorSection');
                if (adminLogsSection) adminLogsSection.style.display = 'block';
                if (adminSmartSensorSection) adminSmartSensorSection.style.display = 'block';
              } else {
                // Hide admin panel and mode toggle for operators
                document.getElementById('adminPanel').style.display = 'none';
                const modeToggle = document.querySelector('.mode-toggle');
                if (modeToggle) {
                  modeToggle.style.display = 'none';
                }
                // Ensure operator mode is active
                switchMode('operator');
                // Hide admin sections (but keep config icon visible for Kafka Controls)
                const adminLogsSection = document.getElementById('adminOperatorLogsSection');
                const adminSmartSensorSection = document.getElementById('adminSmartSensorSection');
                if (adminLogsSection) adminLogsSection.style.display = 'none';
                if (adminSmartSensorSection) adminSmartSensorSection.style.display = 'none';
              }
              // Config icon is always visible (Kafka Controls available to all)
              const configIcon = document.getElementById('sidebarConfigIcon');
              if (configIcon) configIcon.style.display = 'flex';
              
              // Show Admin icon for admins
              const adminIcon = document.getElementById('sidebarAdminIcon');
              if (adminIcon && currentUser.role === 'admin') {
                adminIcon.style.display = 'flex';
              }
              
              // Initialize left sidebar
              initializeAdminSidebar();
              
              // Initialize MPS display and header controls
              initializeMPSDisplay();
              
              // Initialize uptime tracking
              if (!systemStartTime && producerRunning) {
                systemStartTime = Date.now();
              }
              updateSessionUptime();
              return;
            }
          }
        } catch (e) {
          console.error('Auth check failed:', e);
        }
        showLogin();
      }

      function showLogin() {
        // Redirect to the new cinematic login page
        window.location.href = '/login';
      }

      function showLoginForm() {
        document.getElementById('loginFormContent').style.display = 'block';
        document.getElementById('signupFormContent').style.display = 'none';
        const loginBtn = document.getElementById('showLoginBtn');
        const signupBtn = document.getElementById('showSignupBtnAuth');
        if (loginBtn) {
          loginBtn.style.background = 'linear-gradient(135deg, #60a5fa 0%, #a78bfa 100%)';
          loginBtn.style.color = 'white';
        }
        if (signupBtn) {
          signupBtn.style.background = 'rgba(15, 23, 42, 0.6)';
          signupBtn.style.color = '#94a3b8';
        }
      }

      function showSignupFormAuth() {
        document.getElementById('loginFormContent').style.display = 'none';
        document.getElementById('signupFormContent').style.display = 'block';
        const loginBtn = document.getElementById('showLoginBtn');
        const signupBtn = document.getElementById('showSignupBtnAuth');
        if (signupBtn) {
          signupBtn.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
          signupBtn.style.color = 'white';
        }
        if (loginBtn) {
          loginBtn.style.background = 'rgba(15, 23, 42, 0.6)';
          loginBtn.style.color = '#94a3b8';
        }
        toggleMachineSelectionAuth();
      }

      function toggleMachineSelectionAuth() {
        const adminToggle = document.getElementById('signupAdminToggle');
        const machineSelection = document.getElementById('machineSelectionAuth');
        if (adminToggle && machineSelection) {
          if (adminToggle.checked) {
            machineSelection.style.display = 'none';
          } else {
            machineSelection.style.display = 'block';
          }
        }
      }

      function showDashboard() {
        // Hide boot overlay
        const bootOverlay = document.getElementById('boot-overlay');
        if (bootOverlay) {
          bootOverlay.style.display = 'none';
        }
        document.getElementById('loginForm').style.display = 'none';
        document.getElementById('mainDashboard').style.display = 'block';
      }

      // Refresh Admin Permissions
      function refreshAdminPermissions() {
        if (currentUser && currentUser.role === 'admin') {
          const adminIcon = document.getElementById('sidebarAdminIcon');
          if (adminIcon) {
            adminIcon.style.display = 'flex';
          }
          // Show admin section if it exists
          const adminSection = document.getElementById('section-admin');
          if (adminSection) {
            // Don't force show, but ensure it's accessible
          }
          // Unhide all admin-only elements
          document.querySelectorAll('.admin-only').forEach(el => {
            el.style.display = '';
          });
        }
      }

      async function handleLogin(event) {
        event.preventDefault();
        const username = document.getElementById('loginUsername').value;
        const password = document.getElementById('loginPassword').value;
        const errorDiv = document.getElementById('loginError');

        try {
          const response = await fetch('/api/auth/login', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username, password })
          });

            const data = await response.json();
            if (data.success) {
              currentUser = data.user;
              
              // CRITICAL: Force admin role for admin/admin
              if (username === 'admin' && password === 'admin') {
                currentUser.role = 'admin';
                currentUser.accessible_machines = ['A', 'B', 'C'];
              }
              
              accessibleMachines = currentUser.accessible_machines || [];
              
              // Hide boot overlay immediately
              const bootOverlay = document.getElementById('boot-overlay');
              if (bootOverlay) {
                bootOverlay.style.display = 'none';
              }
              
              showDashboard();
              filterMachineSelector();
              updateUserInfo();
              
              // Refresh admin permissions immediately
              refreshAdminPermissions();
              
              if (currentUser.role === 'admin') {
              // Hide mode toggle for admins (they only see admin panel)
              const modeToggle = document.querySelector('.mode-toggle');
              if (modeToggle) {
                modeToggle.style.display = 'none';
              }
              // Auto-switch to admin mode for admins (permanent admin mode)
              switchMode('admin');
            } else {
              // Hide admin panel and mode toggle for operators
              document.getElementById('adminPanel').style.display = 'none';
              const modeToggle = document.querySelector('.mode-toggle');
              if (modeToggle) {
                modeToggle.style.display = 'none';
              }
              document.getElementById('signupForm').style.display = 'none';
              // Ensure operator mode is active
              switchMode('operator');
            }
            errorDiv.style.display = 'none';
            // Select first accessible machine
            if (accessibleMachines.length > 0) {
              selectMachine(accessibleMachines[0]);
            }
          } else {
            errorDiv.textContent = data.error || 'Login failed';
            errorDiv.style.display = 'block';
          }
        } catch (e) {
          errorDiv.textContent = 'Network error. Please try again.';
          errorDiv.style.display = 'block';
        }
      }

      async function handleSignupAuth(event) {
        event.preventDefault();
        const username = document.getElementById('signupUsernameAuth').value;
        const password = document.getElementById('signupPasswordAuth').value;
        const isAdmin = document.getElementById('signupAdminToggle').checked;
        const errorDiv = document.getElementById('signupErrorAuth');
        const successDiv = document.getElementById('signupSuccessAuth');
        
        errorDiv.style.display = 'none';
        successDiv.style.display = 'none';

        const role = isAdmin ? 'admin' : 'operator';
        let machine_ids = [];
        
        if (!isAdmin) {
          const checkboxes = document.querySelectorAll('.machine-checkbox-auth:checked');
          machine_ids = Array.from(checkboxes).map(cb => cb.value);
          
          if (machine_ids.length === 0) {
            errorDiv.textContent = 'Operator users must have at least one machine assigned';
            errorDiv.style.display = 'block';
            return;
          }
        }

        try {
          const response = await fetch('/api/auth/signup', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username, password, role, machine_ids })
          });

          const data = await response.json();
          if (data.success) {
            successDiv.textContent = `User "${username}" created! You can now login.`;
            successDiv.style.display = 'block';
            // Reset form
            document.getElementById('signupFormElementAuth').reset();
            toggleMachineSelectionAuth();
            // Switch to login after 2 seconds
            setTimeout(() => {
              showLoginForm();
            }, 2000);
          } else {
            errorDiv.textContent = data.error || 'Failed to create user';
            errorDiv.style.display = 'block';
          }
        } catch (e) {
          errorDiv.textContent = 'Network error. Please try again.';
          errorDiv.style.display = 'block';
        }
      }

      async function handleLogout() {
        try {
          const logoutResponse = await fetch('/api/auth/logout', {
            method: 'POST',
            credentials: 'include'
          });
        } catch (e) {
          console.error('Logout error:', e);
        }
        currentUser = null;
        accessibleMachines = [];
        // #region agent log
        fetch('http://127.0.0.1:7243/ingest/7ce1c69f-6529-4e30-b8ed-f1fe34b6ca57',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'dashboard.html:2059',message:'handleLogout: Redirecting to login',data:{redirectUrl:'/login?logout=true'},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
        // #endregion
        // Redirect to login with logout flag to prevent auto-redirect
        window.location.href = '/login?logout=true';
      }

      function updateUserInfo() {
        if (currentUser) {
          const roleText = currentUser.role === 'admin' ? 'Admin' : 'Operator';
          document.getElementById('userInfo').textContent = 
            `Logged in as ${currentUser.username} (${roleText})`;
        }
      }

      function filterMachineSelector() {
        const machineButtons = document.querySelectorAll('.machine-btn');
        machineButtons.forEach(btn => {
          const machineId = btn.dataset.machine;
          if (accessibleMachines.includes(machineId)) {
            btn.style.display = 'inline-block';
          } else {
            btn.style.display = 'none';
          }
        });
        // Select first accessible machine if current selection is not accessible
        if (!accessibleMachines.includes(selectedMachineId) && accessibleMachines.length > 0) {
          selectMachine(accessibleMachines[0]);
        }
      }

      // Check auth on page load
      checkAuth();

      // ========== Machine and Mode State Management ==========
      let selectedMachineId = 'A';
      let currentMode = 'operator';
      let selectedAdminCategory = 'environmental'; // For 3-pane admin UI
      
      // Per-machine sensor state: { machineId: { sensorName: { enabled: bool, baseline: number } } }
      let machineSensorState = {
        'A': {},
        'B': {},
        'C': {}
      };

      // Per-machine parameter configuration (in-memory only, resets on refresh)
      // Tracks sensor order and enabled/disabled state for admin configuration
      let machineParameterConfig = {
        'A': { sensorOrder: [], enabledSensors: new Set() },
        'B': { sensorOrder: [], enabledSensors: new Set() },
        'C': { sensorOrder: [], enabledSensors: new Set() }
      };

      // ========== Per-Machine Data Isolation ==========
      // TRUE machine-scoped data storage - each machine has its own independent data
      let machineData = {
        'A': {
          statsData: null,         // Full stats response for this machine
          recentReadings: [],      // Live sensor readings history (append-only)
          alerts: [],              // Alerts for this machine
          anomalies: [],           // ML anomalies for this machine
          mlStats: { totalAnomalies: 0, anomalyRate: 0, reportsGenerated: 0 },
          lstmPredictions: null,   // LSTM predictions for this machine
          totalCount: 0,           // Total message count for this machine
          sensorSums: {},          // Per-sensor sum accumulator for averages
          sensorCounts: {},       // Per-sensor count accumulator for averages
          messageVelocity: 0,      // Messages per second
          lastUpdateTime: null,    // Last velocity calculation time
          lastMessageCount: 0      // Message count at last velocity calculation
        },
        'B': {
          statsData: null,
          recentReadings: [],
          alerts: [],
          anomalies: [],
          mlStats: { totalAnomalies: 0, anomalyRate: 0, reportsGenerated: 0 },
          lstmPredictions: null,
          totalCount: 0,
          sensorSums: {},
          sensorCounts: {},
          messageVelocity: 0,
          lastUpdateTime: null,
          lastMessageCount: 0
        },
        'C': {
          statsData: null,
          recentReadings: [],
          alerts: [],
          anomalies: [],
          mlStats: { totalAnomalies: 0, anomalyRate: 0, reportsGenerated: 0 },
          lstmPredictions: null,
          totalCount: 0,
          sensorSums: {},
          sensorCounts: {},
          messageVelocity: 0,
          lastUpdateTime: null,
          lastMessageCount: 0
        }
      };

      // Get the data for the currently selected machine
      function getCurrentMachineData() {
        return machineData[selectedMachineId];
      }

      // ========== Producer + Machine Running State ==========
      // Global producer running state (synced with backend)
      let producerRunning = false;

      // Per-machine running state
      let machineRunning = {
        'A': false,
        'B': false,
        'C': false
      };

      // GUARD: Check if data collection is allowed for current machine
      // Data may ONLY be appended if: producerRunning === true AND machineRunning[selectedMachine] === true
      function canCollectData() {
        return producerRunning === true && machineRunning[selectedMachineId] === true;
      }

      // Reset all machine data buffers
      function resetMachineData(machineId) {
        machineData[machineId] = {
          statsData: null,
          recentReadings: [],
          alerts: [],
          anomalies: [],
          mlStats: { totalAnomalies: 0, anomalyRate: 0, reportsGenerated: 0 },
          lstmPredictions: null,
          totalCount: 0,
          sensorSums: {},
          sensorCounts: {}
        };
      }

      // Reset ALL machine data
      function resetAllMachineData() {
        ['A', 'B', 'C'].forEach(id => resetMachineData(id));
      }

      // Get machine-specific average for a sensor
      function getMachineAverage(machineId, sensorName) {
        const machine = machineData[machineId];
        const sum = machine.sensorSums[sensorName] || 0;
        const count = machine.sensorCounts[sensorName] || 0;
        if (count === 0) return null;
        return sum / count;
      }

      // Get current machine's average for a sensor
      function getCurrentMachineAverage(sensorName) {
        return getMachineAverage(selectedMachineId, sensorName);
      }

      // Initialize all sensors as enabled with no baseline override
      function initializeMachineState() {
        // Get all sensors from sensorsByCategory (defined later, but will be available when called)
        if (typeof sensorsByCategory !== 'undefined') {
          const allSensors = Object.keys(sensorsByCategory).flatMap(cat => sensorsByCategory[cat]);
          ['A', 'B', 'C'].forEach(machineId => {
            allSensors.forEach(sensor => {
              if (!machineSensorState[machineId][sensor]) {
                machineSensorState[machineId][sensor] = {
                  enabled: true,
                  baseline: null
                };
              }
            });

            // Initialize machineParameterConfig with sensor order and all enabled
            machineParameterConfig[machineId] = {
              sensorOrder: [...allSensors],
              enabledSensors: new Set(allSensors)
            };
          });
        }
      }
      
      function selectMachine(machineId) {
        selectedMachineId = machineId;
        document.querySelectorAll('.machine-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.machine === machineId);
        });
        // Update top bar dropdown
        const topBarSelect = document.getElementById('scadaMachineSelect');
        if (topBarSelect) {
          topBarSelect.value = machineId;
        }
        document.getElementById('adminMachineLabel').textContent = machineId;

        // Load machine-specific custom sensor state when switching machines
        const customSensors = Object.values(unifiedSensorRegistry).filter(s => s.source === 'custom');
        if (customSensors.length > 0) {
          loadMachineCustomSensorState(machineId, customSensors.map(s => ({ sensor_name: s.name })));
        }

        // Render admin panel with new sortable list if in admin mode
        if (currentMode === 'admin') {
          renderAdminSensorList();
        }

        // ========== SYNC MACHINE RUNNING STATE ON SWITCH ==========
        // Fetch current status from backend - DO NOT auto-start
        // Only update UI to reflect the actual backend state
        fetchMachineStatus(machineId);

        // ========== MACHINE DATA ISOLATION ==========
        // Immediately render from cached data for this machine (instant UI update)
        renderFromMachineCache(machineId);

        // Then fetch fresh data (which will also update the cache)
        updateStats();
        loadAlerts();
        loadMLStats();
        loadAnomalies();
        loadLSTMPredictions();
        
        // Update config section if it's open
        if (document.getElementById('section-configuration') && document.getElementById('section-configuration').classList.contains('active')) {
          renderConfigSensorManagement();
        }
      }

      // Render UI from machine-specific cache (instant switch)
      function renderFromMachineCache(machineId) {
        const machine = machineData[machineId];

        // Render total count from cache
        document.getElementById("totalCount").textContent = machine.totalCount;

        // Render alerts from cache
        const alertContainer = document.getElementById("alertList");
        if (alertContainer) {
          if (machine.alerts.length === 0) {
            alertContainer.innerHTML = `<div style="text-align: center; color: #94a3b8; padding: 20px;">No alerts for Machine ${machineId} yet</div>`;
          } else {
            alertContainer.innerHTML = machine.alerts.map((alert) => {
              const severity = (alert.severity || "info").toLowerCase();
              return `
                <div class="alert-item">
                  <div>
                    <div class="alert-type">${alert.alert_type}</div>
                    <div class="alert-message">${alert.message}</div>
                  </div>
                  <div class="alert-meta">
                    <span class="alert-badge ${severity}">${alert.severity}</span>
                    <div class="alert-time">${formatDateTime(alert.created_at)}</div>
                  </div>
                </div>
              `;
            }).join("");
          }
        }

        // Render anomalies from cache
        const anomalyContainer = document.getElementById("anomalyList");
        if (anomalyContainer) {
          if (machine.anomalies.length === 0) {
            anomalyContainer.innerHTML = `
              <div style="text-align: center; color: #94a3b8; padding: 40px;">
                No ML anomalies detected for Machine ${machineId} yet. Start the pipeline to begin monitoring.
              </div>
            `;
          } else {
            anomalyContainer.innerHTML = machine.anomalies.map((anomaly) => {
              const sensors = filterSensorsArray(anomaly.detected_sensors || []);
              const sensorTags = sensors.slice(0, 5).map((s) => `<span>${s.replace(/_/g, " ")}</span>`).join("");
              const moreSensors = sensors.length > 5 ? `<span>+${sensors.length - 5} more</span>` : "";
              let actionBtn = "";
              if (anomaly.report_id && anomaly.report_status === "completed") {
                actionBtn = `<button class="btn-report btn-view-report" onclick="viewReport(${anomaly.report_id})">üìÑ View Report</button>`;
              } else if (anomaly.report_status === "generating") {
                actionBtn = `<button class="btn-report" disabled><span class="loading-spinner"></span> Generating...</button>`;
              } else {
                actionBtn = `<button class="btn-report" onclick="generateReport(${anomaly.id}, this)">ü§ñ Generate Report</button>`;
              }
              return `
                <div class="anomaly-item">
                  <div class="anomaly-info">
                    <div class="anomaly-header">
                      <span class="anomaly-score">Score: ${anomaly.anomaly_score.toFixed(4)}</span>
                      <span class="anomaly-method">${anomaly.detection_method}</span>
                    </div>
                    <div class="anomaly-timestamp">${formatDateTime(anomaly.created_at)}</div>
                    <div class="anomaly-sensors">
                      <strong>Contributing sensors:</strong><br>
                      ${sensorTags}${moreSensors}
                    </div>
                  </div>
                  <div class="anomaly-actions">${actionBtn}</div>
                </div>
              `;
            }).join("");
          }
        }

        // Render ML stats from cache
        document.getElementById("mlTotalAnomalies").textContent = machine.mlStats.totalAnomalies;
        document.getElementById("mlAnomalyRate").textContent = machine.mlStats.anomalyRate.toFixed(1) + "%";
        document.getElementById("mlReportsGenerated").textContent = machine.mlStats.reportsGenerated;

        // Render live readings from cache - FULL RENDER from machine buffer
        const readingsContainer = document.getElementById("readingsHistory");
        if (readingsContainer) {
          const machineReadings = machine.recentReadings;
          if (machineReadings.length === 0) {
            readingsContainer.innerHTML = `<div style="text-align: center; color: #94a3b8; padding: 40px; font-size: 14px; text-transform: uppercase; letter-spacing: 2px;">No data yet for Machine ${machineId}</div>`;
          } else {
            const allSensors = sensorsByCategory[selectedHistoryCategory] || [];
            const currentState = machineSensorState[machineId];
            // Filter out hidden sensors AND disabled sensors for current machine
            const sensors = allSensors.filter(sensor => {
              return !hiddenSensors.has(sensor) &&
                     (currentState[sensor]?.enabled !== false);
            });

            const historyHTML = machineReadings.map((reading) => {
              const metricsHtml = sensors.map((sensor) => {
                const displayName = sensor.replace(/_/g, " ").toUpperCase();
                const value = reading[sensor];
                return `
                  <div class="history-metric">
                    <div class="metric-value">${formatNumber(value)}</div>
                    <div class="metric-label">${displayName}</div>
                  </div>
                `;
              }).join("");

              return `
                <div class="history-item">
                  <div class="history-timestamp">${formatDateTime(reading.created_at)}</div>
                  <div class="history-grid">${metricsHtml}</div>
                </div>
              `;
            }).join("");
            readingsContainer.innerHTML = historyHTML;
          }
        }
      }
      
      function switchMode(mode) {
        // Only allow admin mode if user is admin
        if (mode === 'admin' && (!currentUser || currentUser.role !== 'admin')) {
          return;
        }
        currentMode = mode;
        document.querySelectorAll('.mode-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.mode === mode);
        });
        const adminPanel = document.getElementById('adminPanel');
        if (mode === 'admin') {
          adminPanel.classList.add('active');
          // Use new sortable admin sensor list
          renderAdminSensorList();
          // Load custom sensors
          loadCustomSensors();
        } else {
          adminPanel.classList.remove('active');
          // Refresh operator dashboard when switching back
          refreshOperatorDashboard();
        }
      }
      
      function updateAdminPanel() {
        const container = document.getElementById('adminSensorControls');
        if (!container) return;
        
        const allSensors = Object.keys(sensorsByCategory).flatMap(cat => 
          sensorsByCategory[cat].map(sensor => ({ name: sensor, category: cat }))
        );
        
        const currentState = machineSensorState[selectedMachineId];
        
        let html = '<div class="sensor-control-grid">';
        allSensors.forEach(({ name, category }) => {
          const state = currentState[name] || { enabled: true, baseline: null };
          const displayName = name.replace(/_/g, ' ').toUpperCase();
          html += `
            <div class="sensor-control-item ${!state.enabled ? 'disabled' : ''}">
              <div class="sensor-control-name">${displayName}</div>
              <div class="sensor-control-actions">
                <input type="number" 
                       class="baseline-input" 
                       placeholder="Baseline" 
                       value="${state.baseline || ''}"
                       onchange="updateBaseline('${name}', this.value)"
                       ${!state.enabled ? 'disabled' : ''}>
                <label class="toggle-switch">
                  <input type="checkbox" 
                         ${state.enabled ? 'checked' : ''} 
                         onchange="toggleSensorEnabled('${name}', this.checked)">
                  <span class="toggle-slider"></span>
                </label>
              </div>
            </div>
          `;
        });
        html += '</div>';
        container.innerHTML = html;
      }
      
      function toggleSensorEnabled(sensorName, enabled) {
        if (!machineSensorState[selectedMachineId][sensorName]) {
          machineSensorState[selectedMachineId][sensorName] = { enabled: true, baseline: null };
        }
        machineSensorState[selectedMachineId][sensorName].enabled = enabled;
        updateAdminPanel();
        updateStats(); // Refresh display
      }
      
      function updateBaseline(sensorName, value) {
        if (!machineSensorState[selectedMachineId][sensorName]) {
          machineSensorState[selectedMachineId][sensorName] = { enabled: true, baseline: null };
        }
        machineSensorState[selectedMachineId][sensorName].baseline = value ? parseFloat(value) : null;
        updateStats(); // Refresh display
      }
      
      // Helper: Check if a sensor is enabled for the selected machine
      function isSensorEnabled(sensorName) {
        const currentState = machineSensorState[selectedMachineId];
        const sensorState = currentState[sensorName];
        return !sensorState || sensorState.enabled !== false;
      }
      
      // Helper: Get all enabled sensors for the selected machine
      function getEnabledSensors() {
        const currentState = machineSensorState[selectedMachineId];
        const allSensors = Object.keys(sensorsByCategory).flatMap(cat => sensorsByCategory[cat]);
        return allSensors.filter(sensor => isSensorEnabled(sensor));
      }
      
      // Helper: Check if an anomaly involves any enabled sensors
      function anomalyInvolvesEnabledSensors(anomaly) {
        const detectedSensors = anomaly.detected_sensors || [];
        return detectedSensors.some(sensor => isSensorEnabled(sensor));
      }
      
      // Helper: Filter sensors array to only enabled ones
      function filterSensorsArray(sensors) {
        return sensors.filter(sensor => isSensorEnabled(sensor));
      }

      // ========== Admin Sensor List (Drag-and-Drop Sortable) ==========

      // Get category for a sensor name
      function getSensorCategory(sensorName) {
        // Check unified registry first
        if (unifiedSensorRegistry[sensorName]) {
          return unifiedSensorRegistry[sensorName].category || 'custom';
        }
        // Fallback to sensorsByCategory (for backward compatibility)
        for (const [cat, sensors] of Object.entries(sensorsByCategory)) {
          if (sensors.includes(sensorName)) return cat;
        }
        return 'custom'; // Default to 'custom' instead of 'unknown'
      }

      // Get sensor metadata from unified registry
      function getSensorMetadata(sensorName) {
        return unifiedSensorRegistry[sensorName] || {
          name: sensorName,
          category: 'custom',
          unit: '',
          source: 'unknown',
          enabled: true
        };
      }

      // Format sensor name for display (underscores to spaces, capitalize words)
      function formatSensorName(sensorName) {
        return sensorName
          .replace(/_/g, ' ')
          .replace(/\b\w/g, c => c.toUpperCase());
      }

      // Category icons for admin panel
      const adminCategoryIcons = {
        environmental: 'üåç',
        mechanical: '‚öôÔ∏è',
        thermal: 'üî•',
        electrical: '‚ö°',
        fluid: 'üíß',
        custom: '‚ûï'
      };

      // Select admin category
      function selectAdminCategory(category) {
        selectedAdminCategory = category;
        renderAdminSensorList();
      }

      // Render the admin sensor list with 3-pane layout
      function renderAdminSensorList() {
        const container = document.getElementById('adminSensorControls');
        if (!container) return;

        const config = machineParameterConfig[selectedMachineId];
        if (!config || !config.sensorOrder || config.sensorOrder.length === 0) {
          // Config not initialized yet, fall back to updateAdminPanel
          updateAdminPanel();
          return;
        }

        // Get sensors for selected category (enabled, in order)
        const categorySensors = config.sensorOrder.filter(s =>
          getSensorCategory(s) === selectedAdminCategory && config.enabledSensors.has(s)
        );

        // Get all disabled sensors (from all categories)
        const disabledSensors = config.sensorOrder.filter(s => !config.enabledSensors.has(s));

        // Count enabled sensors per category
        const categoryCounts = {};
        Object.keys(sensorsByCategory).forEach(cat => {
          categoryCounts[cat] = config.sensorOrder.filter(s =>
            getSensorCategory(s) === cat && config.enabledSensors.has(s)
          ).length;
        });

        // Build 3-pane HTML
        let html = '<div class="admin-3pane">';

        // Left Pane: Category Selector
        html += `
          <div class="admin-pane">
            <div class="admin-pane-header">Categories</div>
            <div class="category-list">
        `;
        Object.keys(sensorsByCategory).forEach(cat => {
          const icon = adminCategoryIcons[cat] || 'üìä';
          const isActive = cat === selectedAdminCategory ? 'active' : '';
          const displayName = cat.charAt(0).toUpperCase() + cat.slice(1);
          html += `
            <div class="category-item ${isActive}" onclick="selectAdminCategory('${cat}')">
              <span class="category-icon">${icon}</span>
              <span>${displayName}</span>
              <span class="category-count">${categoryCounts[cat]}</span>
            </div>
          `;
        });
        html += '</div></div>';

        // Center Pane: Active Sensors for Selected Category
        html += `
          <div class="admin-pane">
            <div class="admin-pane-header active-header">
              ${adminCategoryIcons[selectedAdminCategory] || 'üìä'} Active - ${selectedAdminCategory.charAt(0).toUpperCase() + selectedAdminCategory.slice(1)}
            </div>
            <div class="admin-pane-content" id="activeSensorsPane" data-pane="active">
        `;

        if (categorySensors.length === 0) {
          html += '<div class="admin-sensor-list empty-list">No active sensors in this category.<br>Drag from Disabled to enable.</div>';
        } else {
          html += '<div class="admin-sensor-list" id="activeSensorList">';
          categorySensors.forEach((sensorName, index) => {
            html += renderSensorItem(sensorName, index, true);
          });
          html += '</div>';
        }
        html += '</div></div>';

        // Right Pane: Disabled Sensors Bucket
        html += `
          <div class="admin-pane">
            <div class="admin-pane-header disabled-header">
              üö´ Disabled (${disabledSensors.length})
            </div>
            <div class="admin-pane-content" id="disabledSensorsPane" data-pane="disabled">
        `;

        if (disabledSensors.length === 0) {
          html += '<div class="admin-sensor-list empty-list">No disabled sensors.<br>Drag here to disable.</div>';
        } else {
          html += '<div class="admin-sensor-list" id="disabledSensorList">';
          disabledSensors.forEach((sensorName, index) => {
            html += renderSensorItem(sensorName, index, false);
          });
          html += '</div>';
        }
        html += '</div></div>';

        html += '</div>'; // Close admin-3pane

        html += '<button class="reset-config-btn" onclick="resetMachineConfig()">Reset to Defaults</button>';

        container.innerHTML = html;
        attachDragListeners();
      }

      // Render a single sensor item
      function renderSensorItem(sensorName, index, isEnabled) {
        const category = getSensorCategory(sensorName);
        return `
          <div class="admin-sensor-item ${isEnabled ? '' : 'disabled'}"
               data-sensor="${sensorName}" data-index="${index}" data-enabled="${isEnabled}">
            <span class="drag-handle" title="Drag to reorder or move">‚ò∞</span>
            <div class="sensor-info">
              <span class="sensor-name">${formatSensorName(sensorName)}</span>
              <span class="sensor-category">${category}</span>
            </div>
          </div>
        `;
      }

      // ========== Custom Drag-and-Drop (Mouse + Touch) ==========

      // Drag-and-drop state
      let dragState = {
        item: null,
        startY: 0,
        startX: 0,
        startIndex: 0,
        offsetY: 0,
        offsetX: 0,
        clone: null,
        sourcePane: null // 'active' or 'disabled'
      };

      function attachDragListeners() {
        const handles = document.querySelectorAll('.admin-sensor-list .drag-handle');

        handles.forEach(handle => {
          // Mouse events
          handle.addEventListener('mousedown', startDrag);
          // Touch events
          handle.addEventListener('touchstart', startDrag, { passive: false });
        });
      }

      function startDrag(e) {
        e.preventDefault();
        const item = e.target.closest('.admin-sensor-item');
        if (!item) return;

        const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
        const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
        const rect = item.getBoundingClientRect();

        // Determine source pane
        const paneContent = item.closest('.admin-pane-content');
        dragState.sourcePane = paneContent?.dataset.pane || 'active';

        dragState.item = item;
        dragState.startY = clientY;
        dragState.startX = clientX;
        dragState.startIndex = parseInt(item.dataset.index);
        dragState.offsetY = clientY - rect.top;
        dragState.offsetX = clientX - rect.left;

        // Create visual clone for dragging
        dragState.clone = item.cloneNode(true);
        dragState.clone.classList.add('dragging');
        dragState.clone.style.position = 'fixed';
        dragState.clone.style.width = rect.width + 'px';
        dragState.clone.style.left = (clientX - dragState.offsetX) + 'px';
        dragState.clone.style.top = (clientY - dragState.offsetY) + 'px';
        dragState.clone.style.pointerEvents = 'none';
        dragState.clone.style.zIndex = '9999';
        document.body.appendChild(dragState.clone);

        // Fade original
        item.style.opacity = '0.3';

        // Bind move/end events
        if (e.type === 'touchstart') {
          document.addEventListener('touchmove', onDrag, { passive: false });
          document.addEventListener('touchend', endDrag);
        } else {
          document.addEventListener('mousemove', onDrag);
          document.addEventListener('mouseup', endDrag);
        }
      }

      function onDrag(e) {
        if (!dragState.item) return;
        e.preventDefault();

        const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
        const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;

        // Move clone
        if (dragState.clone) {
          dragState.clone.style.left = (clientX - dragState.offsetX) + 'px';
          dragState.clone.style.top = (clientY - dragState.offsetY) + 'px';
        }

        // Clear all drop indicators
        document.querySelectorAll('.admin-sensor-item').forEach(item => {
          item.classList.remove('drop-target-above', 'drop-target-below');
        });
        document.querySelectorAll('.admin-pane-content').forEach(pane => {
          pane.classList.remove('drop-zone-active');
        });

        // Check if over a pane
        const targetPane = getTargetPane(clientX, clientY);
        if (targetPane) {
          // If over a different pane, highlight it
          if (targetPane.pane !== dragState.sourcePane) {
            targetPane.element.classList.add('drop-zone-active');
          } else {
            // Same pane - show drop position indicators
            const target = getDropTarget(clientY);
            if (target && target.element !== dragState.item) {
              target.element.classList.add(target.position === 'above' ? 'drop-target-above' : 'drop-target-below');
            }
          }
        }
      }

      function getTargetPane(clientX, clientY) {
        const activePane = document.getElementById('activeSensorsPane');
        const disabledPane = document.getElementById('disabledSensorsPane');

        if (activePane) {
          const rect = activePane.getBoundingClientRect();
          if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom) {
            return { element: activePane, pane: 'active' };
          }
        }
        if (disabledPane) {
          const rect = disabledPane.getBoundingClientRect();
          if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom) {
            return { element: disabledPane, pane: 'disabled' };
          }
        }
        return null;
      }

      function getDropTarget(clientY) {
        const items = document.querySelectorAll('.admin-sensor-item');
        for (const item of items) {
          if (item === dragState.item) continue;
          const rect = item.getBoundingClientRect();
          const midY = rect.top + rect.height / 2;
          if (clientY >= rect.top && clientY <= rect.bottom) {
            return { element: item, position: clientY < midY ? 'above' : 'below' };
          }
        }
        return null;
      }

      function endDrag(e) {
        if (!dragState.item) return;

        const clientX = e.type === 'touchend' ? e.changedTouches[0].clientX : e.clientX;
        const clientY = e.type === 'touchend' ? e.changedTouches[0].clientY : e.clientY;
        const target = getDropTarget(clientY);
        const targetPane = getTargetPane(clientX, clientY);

        // Clean up event listeners
        document.removeEventListener('mousemove', onDrag);
        document.removeEventListener('mouseup', endDrag);
        document.removeEventListener('touchmove', onDrag);
        document.removeEventListener('touchend', endDrag);

        // Clean up visual elements
        if (dragState.clone) {
          dragState.clone.remove();
        }
        if (dragState.item) {
          dragState.item.style.opacity = '';
        }
        document.querySelectorAll('.admin-sensor-item').forEach(item => {
          item.classList.remove('drop-target-above', 'drop-target-below');
        });
        document.querySelectorAll('.admin-pane-content').forEach(pane => {
          pane.classList.remove('drop-zone-active');
        });

        const config = machineParameterConfig[selectedMachineId];
        const sensorName = dragState.item.dataset.sensor;

        // Handle cross-pane drops (enable/disable)
        if (targetPane && targetPane.pane !== dragState.sourcePane) {
          if (targetPane.pane === 'disabled') {
            // Dropped on disabled pane - disable the sensor
            const isCustomSensor = unifiedSensorRegistry[sensorName] && unifiedSensorRegistry[sensorName].source === 'custom';
            if (isCustomSensor) {
              // For custom sensors, use backend API
              fetch(`/api/machines/${selectedMachineId}/custom-sensors/${sensorName}/toggle`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
              })
                .then(response => response.json())
                .then(data => {
                  if (data.success) {
                    config.enabledSensors.delete(sensorName);
                    syncMachineSensorState(sensorName, false);
                    renderAdminSensorList();
                    refreshOperatorDashboard();
                  }
                })
                .catch(error => console.error('Error disabling custom sensor:', error));
            } else {
              config.enabledSensors.delete(sensorName);
              syncMachineSensorState(sensorName, false);
              renderAdminSensorList();
              refreshOperatorDashboard();
            }
          } else if (targetPane.pane === 'active') {
            // Dropped on active pane - enable the sensor
            const isCustomSensor = unifiedSensorRegistry[sensorName] && unifiedSensorRegistry[sensorName].source === 'custom';
            if (isCustomSensor) {
              // For custom sensors, use backend API
              fetch(`/api/machines/${selectedMachineId}/custom-sensors/${sensorName}/toggle`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
              })
                .then(response => response.json())
                .then(data => {
                  if (data.success && data.enabled) {
                    config.enabledSensors.add(sensorName);
                    syncMachineSensorState(sensorName, true);
                    renderAdminSensorList();
                    refreshOperatorDashboard();
                  }
                })
                .catch(error => console.error('Error enabling custom sensor:', error));
            } else {
              config.enabledSensors.add(sensorName);
              syncMachineSensorState(sensorName, true);
              renderAdminSensorList();
              refreshOperatorDashboard();
            }
          }
        }
        // Handle same-pane reorder (only in active pane)
        else if (target && target.element !== dragState.item && dragState.sourcePane === 'active') {
          const targetSensor = target.element.dataset.sensor;

          const oldIndex = config.sensorOrder.indexOf(sensorName);
          let newIndex = config.sensorOrder.indexOf(targetSensor);
          if (target.position === 'below') newIndex++;
          if (oldIndex < newIndex) newIndex--;

          // Reorder array
          config.sensorOrder.splice(oldIndex, 1);
          config.sensorOrder.splice(newIndex, 0, sensorName);

          renderAdminSensorList();
          refreshOperatorDashboard();
        }

        // Reset drag state
        dragState = { item: null, startY: 0, startX: 0, startIndex: 0, offsetY: 0, offsetX: 0, clone: null, sourcePane: null };
      }

      // Sync machineSensorState with config change
      function syncMachineSensorState(sensorName, enabled) {
        if (!machineSensorState[selectedMachineId][sensorName]) {
          machineSensorState[selectedMachineId][sensorName] = { enabled: true, baseline: null };
        }
        machineSensorState[selectedMachineId][sensorName].enabled = enabled;
      }

      // Refresh operator dashboard when config changes
      function refreshOperatorDashboard() {
        if (currentMode === 'operator') {
          updateStats();
          updateLiveSensorReadings();
        }
      }

      // ========== Keyboard Fallback (Move Up/Down Buttons) ==========

      function moveSensor(sensorName, direction) {
        const config = machineParameterConfig[selectedMachineId];
        if (!config || !config.sensorOrder) return;

        const currentIndex = config.sensorOrder.indexOf(sensorName);
        const newIndex = currentIndex + direction;

        // Bounds check
        if (newIndex < 0 || newIndex >= config.sensorOrder.length) return;

        // Swap positions
        [config.sensorOrder[currentIndex], config.sensorOrder[newIndex]] =
          [config.sensorOrder[newIndex], config.sensorOrder[currentIndex]];

        // Re-render and refresh
        renderAdminSensorList();
        refreshOperatorDashboard();
      }

      // ========== Toggle Sensor Enable/Disable ==========

      function toggleSensorEnabledNew(sensorName) {
        const config = machineParameterConfig[selectedMachineId];
        if (!config) return;

        // Check if this is a custom sensor
        const isCustomSensor = unifiedSensorRegistry[sensorName] && unifiedSensorRegistry[sensorName].source === 'custom';
        
        if (isCustomSensor) {
          // For custom sensors, use backend API to persist to machine_sensor_config
          const currentEnabled = config.enabledSensors.has(sensorName);
          fetch(`/api/machines/${selectedMachineId}/custom-sensors/${sensorName}/toggle`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
          })
            .then(response => response.json())
            .then(data => {
              if (data.success) {
                // Update local state
                if (data.enabled) {
                  config.enabledSensors.add(sensorName);
                } else {
                  config.enabledSensors.delete(sensorName);
                }
                
                // Sync with machineSensorState
                if (!machineSensorState[selectedMachineId][sensorName]) {
                  machineSensorState[selectedMachineId][sensorName] = { enabled: true, baseline: null };
                }
                machineSensorState[selectedMachineId][sensorName].enabled = data.enabled;
                
                // Re-render and refresh
                renderAdminSensorList();
                refreshOperatorDashboard();
              } else {
                console.error('Failed to toggle custom sensor:', data.error);
              }
            })
            .catch(error => {
              console.error('Error toggling custom sensor:', error);
            });
        } else {
          // For built-in sensors, use existing logic (in-memory only)
          if (config.enabledSensors.has(sensorName)) {
            config.enabledSensors.delete(sensorName);
          } else {
            config.enabledSensors.add(sensorName);
          }

          // Sync with existing machineSensorState for backward compatibility
          if (!machineSensorState[selectedMachineId][sensorName]) {
            machineSensorState[selectedMachineId][sensorName] = { enabled: true, baseline: null };
          }
          machineSensorState[selectedMachineId][sensorName].enabled = config.enabledSensors.has(sensorName);

          // Re-render and refresh
          renderAdminSensorList();
          refreshOperatorDashboard();
        }
      }

      // ========== Reset to Defaults ==========

      function resetMachineConfig() {
        if (!confirm(`Reset all sensor settings for Machine ${selectedMachineId} to defaults?`)) {
          return;
        }

        // Get all sensors in original category order
        const allSensors = Object.values(sensorsByCategory).flat();

        // Reset machineParameterConfig
        machineParameterConfig[selectedMachineId] = {
          sensorOrder: [...allSensors],
          enabledSensors: new Set(allSensors)
        };

        // Sync machineSensorState
        for (const sensor of allSensors) {
          machineSensorState[selectedMachineId][sensor] = { enabled: true, baseline: null };
        }

        // Re-render and refresh
        renderAdminSensorList();
        refreshOperatorDashboard();
      }

      // ========== Helper Functions for Ordered Sensor Rendering ==========

      // Get sensors in configured order, filtered to enabled only, optionally by category
      function getOrderedEnabledSensors(category = null) {
        const config = machineParameterConfig[selectedMachineId];
        if (!config || !config.sensorOrder || config.sensorOrder.length === 0) {
          // Fallback to category order if config not initialized
          if (category) {
            return sensorsByCategory[category] || [];
          }
          return Object.values(sensorsByCategory).flat();
        }

        // Filter to enabled sensors in configured order
        let sensors = config.sensorOrder.filter(s => config.enabledSensors.has(s));

        // Optionally filter by category
        if (category) {
          sensors = sensors.filter(s => getSensorCategory(s) === category);
        }

        return sensors;
      }

      // Filter and order an array of sensor names based on config
      function filterAndOrderSensors(sensorArray) {
        const config = machineParameterConfig[selectedMachineId];
        if (!config || !config.sensorOrder || config.sensorOrder.length === 0) {
          // Fallback: just filter by enabled
          return sensorArray.filter(s => isSensorEnabled(s));
        }

        const orderMap = new Map(config.sensorOrder.map((s, i) => [s, i]));

        return sensorArray
          .filter(s => config.enabledSensors.has(s))
          .sort((a, b) => (orderMap.get(a) ?? 999) - (orderMap.get(b) ?? 999));
      }

      // Filter sensor data by machine and enabled state (non-destructive wrapper)
      function filterSensorData(data) {
        if (!data) return data;
        
        const currentState = machineSensorState[selectedMachineId];
        const filtered = JSON.parse(JSON.stringify(data)); // Deep copy to avoid modifying original
        
        // Filter sensor readings - only show enabled sensors, apply baselines
        if (filtered.recent_readings_full) {
          filtered.recent_readings_full = filtered.recent_readings_full.map(reading => {
            const filteredReading = {};
            Object.keys(reading).forEach(key => {
              if (key === 'timestamp' || key === 'created_at') {
                filteredReading[key] = reading[key];
              } else {
                const sensorState = currentState[key];
                // Only include if sensor is enabled (default to enabled if not set)
                if (!sensorState || sensorState.enabled !== false) {
                  // Apply baseline if set, otherwise use actual value
                  if (sensorState && sensorState.baseline !== null) {
                    filteredReading[key] = sensorState.baseline;
                  } else {
                    filteredReading[key] = reading[key];
                  }
                }
                // If disabled, don't include in filtered reading (will be filtered out in display)
              }
            });
            return filteredReading;
          });
        }
        
        // Filter stats by category - remove disabled sensors from display
        if (filtered.stats_by_category) {
          Object.keys(filtered.stats_by_category).forEach(category => {
            const categoryData = filtered.stats_by_category[category];
            if (categoryData.sensors) {
              Object.keys(categoryData.sensors).forEach(sensorName => {
                const sensorState = currentState[sensorName];
                // Remove from display if disabled
                if (sensorState && sensorState.enabled === false) {
                  delete categoryData.sensors[sensorName];
                } else if (sensorState && sensorState.baseline !== null) {
                  // Apply baseline override
                  categoryData.sensors[sensorName].value = sensorState.baseline;
                }
              });
            }
          });
        }
        
        return filtered;
      }
      // ========== End Machine and Mode State Management ==========

      // ========== Display Refresh Rate Control ==========
      let uiRefreshIntervalMs = 10000; // Default 10 seconds
      let liveReadingsTimer = null;

      function setRefreshRate(intervalMs) {
        // Guard: minimum 1000ms
        if (intervalMs < 1000) {
          intervalMs = 1000;
        }
        
        uiRefreshIntervalMs = intervalMs;
        
        // Update button states
        document.querySelectorAll('.refresh-rate-btn').forEach(btn => {
          btn.classList.toggle('active', parseInt(btn.dataset.interval) === intervalMs);
        });
        
        // Restart the live readings timer with new interval
        if (liveReadingsTimer) {
          clearInterval(liveReadingsTimer);
        }
        
        // Start new timer for Live Sensor Readings only
        liveReadingsTimer = setInterval(() => {
          updateLiveSensorReadings();
        }, uiRefreshIntervalMs);
        
        // Immediately update to show change
        updateLiveSensorReadings();
      }

      // RENDER-ONLY function for Live Sensor Readings (no data fetching, no accumulation)
      function updateLiveSensorReadings() {
        // STRICTLY render-only: use cached data, no API calls, no mutations
        const machine = machineData[selectedMachineId];
        const readingsContainer = document.getElementById("readingsHistory");
        
        if (!readingsContainer) return;
        
        const machineReadings = machine.recentReadings || [];
        
        if (machineReadings.length === 0) {
          readingsContainer.innerHTML = `<div style="text-align: center; color: #94a3b8; padding: 40px; font-size: 14px; text-transform: uppercase; letter-spacing: 2px;">No data yet for Machine ${selectedMachineId}</div>`;
          return;
        }
        
        // Get sensor units from cached stats data (no API call)
        const sensorUnits = machine.statsData?.stats_by_category?.[selectedHistoryCategory]?.sensors || {};

        // Use ordered enabled sensors from machineParameterConfig, also filter hidden sensors
        const sensors = getOrderedEnabledSensors(selectedHistoryCategory)
          .filter(sensor => !hiddenSensors.has(sensor));

        const historyHTML = machineReadings.map((reading) => {
          // Merge custom_sensors into reading if present
          const mergedReading = { ...reading };
          if (reading.custom_sensors && typeof reading.custom_sensors === 'object') {
            Object.assign(mergedReading, reading.custom_sensors);
          }
          
          const metricsHtml = sensors.map((sensor) => {
            const displayName = sensor.replace(/_/g, " ").toUpperCase();
            // Check both direct property and custom_sensors object
            const value = mergedReading[sensor];
            // Get unit from stats or unified registry
            const unit = sensorUnits[sensor]?.unit || getSensorMetadata(sensor).unit || "";
            return `
              <div class="history-metric">
                <div class="metric-value">${value !== undefined && value !== null ? formatNumber(value) : '--'}${unit ? '<span class="sensor-unit">' + unit + "</span>" : ""}</div>
                <div class="metric-label">${displayName}</div>
              </div>
            `;
          }).join("");

          return `
            <div class="history-item">
              <div class="history-timestamp">${formatDateTime(reading.created_at)}</div>
              <div class="history-grid">${metricsHtml}</div>
            </div>
          `;
        }).join("");
        
        readingsContainer.innerHTML = historyHTML;
      }
      // ========== End Display Refresh Rate Control ==========

      let selectedHistoryCategory = "environmental";
      let configLimits = null;
      let configDefaults = null;

      // ============================================================================
      // UNIFIED SENSOR REGISTRY (Built-in + Custom Sensors)
      // ============================================================================
      
      // Built-in sensors definition (static)
      const builtInSensorsByCategory = {
        environmental: [
          "temperature",
          "pressure",
          "humidity",
          "ambient_temp",
          "dew_point",
          "air_quality_index",
          "co2_level",
          "particle_count",
          "noise_level",
          "light_intensity",
        ],
        mechanical: [
          "vibration",
          "rpm",
          "torque",
          "shaft_alignment",
          "bearing_temp",
          "motor_current",
          "belt_tension",
          "gear_wear",
          "coupling_temp",
          "lubrication_pressure",
        ],
        thermal: [
          "coolant_temp",
          "exhaust_temp",
          "oil_temp",
          "radiator_temp",
          "thermal_efficiency",
          "heat_dissipation",
          "inlet_temp",
          "outlet_temp",
          "core_temp",
          "surface_temp",
        ],
        electrical: [
          "voltage",
          "current",
          "power_factor",
          "frequency",
          "resistance",
          "capacitance",
          "inductance",
          "phase_angle",
          "harmonic_distortion",
          "ground_fault",
        ],
        fluid: [
          "flow_rate",
          "fluid_pressure",
          "viscosity",
          "density",
          "reynolds_number",
          "pipe_pressure_drop",
          "pump_efficiency",
          "cavitation_index",
          "turbulence",
          "valve_position",
        ],
      };

      // Unified sensor registry: {sensorName: {name, category, unit, source, enabled}}
      let unifiedSensorRegistry = {};
      
      // Dynamic sensorsByCategory (built from unified registry)
      let sensorsByCategory = {};

      // Initialize built-in sensors in unified registry
      function initializeBuiltInSensors() {
        Object.keys(builtInSensorsByCategory).forEach(category => {
          builtInSensorsByCategory[category].forEach(sensorName => {
            unifiedSensorRegistry[sensorName] = {
              name: sensorName,
              category: category,
              unit: '', // Will be populated from stats API
              source: 'builtin',
              enabled: true
            };
          });
        });
        rebuildSensorsByCategory();
      }

      // Merge custom sensors into unified registry
      function mergeCustomSensors(customSensors) {
        // Only merge active custom sensors
        const activeCustomSensors = (customSensors || []).filter(s => s.is_active);
        
        activeCustomSensors.forEach(sensor => {
          const category = sensor.category || 'custom';
          unifiedSensorRegistry[sensor.sensor_name] = {
            name: sensor.sensor_name,
            category: category,
            unit: sensor.unit || '',
            source: 'custom',
            enabled: true // Default enabled, can be overridden by machine config
          };
        });
        
        rebuildSensorsByCategory();
        
        // Update machine state to include new custom sensors
        updateMachineStateForCustomSensors(activeCustomSensors);
      }

      // Update machine state when custom sensors are added
      function updateMachineStateForCustomSensors(customSensors) {
        const allSensors = Object.keys(sensorsByCategory).flatMap(cat => sensorsByCategory[cat]);
        ['A', 'B', 'C'].forEach(machineId => {
          // Load machine-specific enabled state from backend
          loadMachineCustomSensorState(machineId, customSensors);
        });
      }

      // Load machine-specific custom sensor enabled state from backend
      function loadMachineCustomSensorState(machineId, customSensors) {
        fetch(`/api/machines/${machineId}/custom-sensors`)
          .then(response => response.json())
          .then(data => {
            if (data.success && data.sensors) {
              // Add custom sensors to machine state with their enabled status
              customSensors.forEach(sensor => {
                const sensorName = sensor.sensor_name;
                const enabled = data.sensors[sensorName]?.enabled !== false; // Default to true if not set
                
                if (!machineSensorState[machineId][sensorName]) {
                  machineSensorState[machineId][sensorName] = {
                    enabled: enabled,
                    baseline: null
                  };
                } else {
                  machineSensorState[machineId][sensorName].enabled = enabled;
                }
              });
              
              // Update machineParameterConfig to include new sensors with correct enabled state
              const config = machineParameterConfig[machineId];
              customSensors.forEach(sensor => {
                const sensorName = sensor.sensor_name;
                const enabled = data.sensors[sensorName]?.enabled !== false;
                
                if (!config.sensorOrder.includes(sensorName)) {
                  config.sensorOrder.push(sensorName);
                }
                if (enabled) {
                  config.enabledSensors.add(sensorName);
                } else {
                  config.enabledSensors.delete(sensorName);
                }
              });
              
              // If this is the currently selected machine, refresh the UI
              if (machineId === selectedMachineId && currentMode === 'admin') {
                renderAdminSensorList();
              }
            }
          })
          .catch(error => {
            console.error(`Error loading custom sensor state for machine ${machineId}:`, error);
            // Fallback: enable all custom sensors by default
            customSensors.forEach(sensor => {
              const sensorName = sensor.sensor_name;
              if (!machineSensorState[machineId][sensorName]) {
                machineSensorState[machineId][sensorName] = {
                  enabled: true,
                  baseline: null
                };
              }
              const config = machineParameterConfig[machineId];
              if (!config.sensorOrder.includes(sensorName)) {
                config.sensorOrder.push(sensorName);
              }
              config.enabledSensors.add(sensorName);
            });
          });
      }

      // Rebuild sensorsByCategory from unified registry
      function rebuildSensorsByCategory() {
        // Initialize all categories (including 'custom' if needed)
        sensorsByCategory = {};
        Object.keys(builtInSensorsByCategory).forEach(cat => {
          sensorsByCategory[cat] = [];
        });
        sensorsByCategory['custom'] = [];
        
        // Populate from unified registry
        Object.values(unifiedSensorRegistry).forEach(sensor => {
          const category = sensor.category || 'custom';
          if (!sensorsByCategory[category]) {
            sensorsByCategory[category] = [];
          }
          if (!sensorsByCategory[category].includes(sensor.name)) {
            sensorsByCategory[category].push(sensor.name);
          }
        });
      }

      // Initialize built-in sensors on page load
      initializeBuiltInSensors();

      // Hidden sensors state tracking
      let hiddenSensors = new Set();
      
      // Initialize machine state now that sensorsByCategory is defined
      initializeMachineState();

      // Load hidden sensors from localStorage on page load
      function loadHiddenSensors() {
        try {
          const stored = localStorage.getItem("hiddenSensors");
          if (stored) {
            hiddenSensors = new Set(JSON.parse(stored));
          }
        } catch (e) {
          console.error("Failed to load hidden sensors:", e);
        }
      }

      // Save hidden sensors to localStorage
      function saveHiddenSensors() {
        try {
          localStorage.setItem(
            "hiddenSensors",
            JSON.stringify([...hiddenSensors])
          );
        } catch (e) {
          console.error("Failed to save hidden sensors:", e);
        }
      }

      // Toggle sensor visibility
      function toggleSensor(sensorName) {
        if (hiddenSensors.has(sensorName)) {
          hiddenSensors.delete(sensorName);
        } else {
          hiddenSensors.add(sensorName);
        }
        saveHiddenSensors();
        updateStats();
      }

      // =============================================
      // THRESHOLD MANAGEMENT
      // =============================================

      // Store custom thresholds in sessionStorage
      let customThresholds = {};

      // Track expanded threshold controls (survives re-renders)
      let expandedThresholds = new Set();

      // Store default thresholds from backend (SENSOR_THRESHOLDS)
      let defaultThresholds = {};

      // Load thresholds from sessionStorage on page load
      function loadThresholds() {
        try {
          const stored = sessionStorage.getItem("customThresholds");
          if (stored) {
            customThresholds = JSON.parse(stored);
          }
        } catch (e) {
          console.error("Failed to load thresholds:", e);
        }
      }

      // Load default thresholds from backend API
      function loadDefaultThresholds() {
        fetch("/api/thresholds")
          .then((r) => r.json())
          .then((data) => {
            if (data.defaults) {
              defaultThresholds = data.defaults;
            }
          })
          .catch(console.error);
      }

      // Save thresholds to sessionStorage
      function saveThresholdsToStorage() {
        try {
          sessionStorage.setItem(
            "customThresholds",
            JSON.stringify(customThresholds)
          );
        } catch (e) {
          console.error("Failed to save thresholds:", e);
        }
      }

      // Get threshold for a sensor (custom or default from SENSOR_THRESHOLDS)
      function getThreshold(sensorName) {
        if (customThresholds[sensorName]) {
          return customThresholds[sensorName];
        }
        // Return default from SENSOR_THRESHOLDS (loaded from backend)
        const defaults = defaultThresholds[sensorName];
        if (defaults) {
          return { min: defaults.low, max: defaults.high };
        }
        return { min: 0, max: 100 }; // Fallback
      }

      // Get default threshold values for a sensor
      function getDefaultThreshold(sensorName) {
        const defaults = defaultThresholds[sensorName];
        if (defaults) {
          return {
            low: defaults.low,
            high: defaults.high,
            unit: defaults.unit,
          };
        }
        return { low: 0, high: 100, unit: "" };
      }

      // Toggle threshold controls visibility
      function toggleThreshold(sensorName, event) {
        if (event) {
          event.stopPropagation();
        }
        const controls = document.getElementById(`threshold-${sensorName}`);
        if (controls) {
          const isExpanded = controls.classList.toggle("expanded");
          if (isExpanded) {
            expandedThresholds.add(sensorName);
          } else {
            expandedThresholds.delete(sensorName);
          }
        }
      }

      // Restore expanded state after re-render
      function restoreExpandedThresholds() {
        expandedThresholds.forEach((sensorName) => {
          const controls = document.getElementById(`threshold-${sensorName}`);
          if (controls) {
            controls.classList.add("expanded");
          }
        });
      }

      // Save custom threshold
      function saveThreshold(sensorName, event) {
        if (event) {
          event.stopPropagation();
        }
        const minInput = document.getElementById(`min-${sensorName}`);
        const maxInput = document.getElementById(`max-${sensorName}`);
        const defaults = getDefaultThreshold(sensorName);

        if (minInput && maxInput) {
          const minVal = parseFloat(minInput.value);
          const maxVal = parseFloat(maxInput.value);

          if (isNaN(minVal) || isNaN(maxVal)) {
            alert("Please enter valid numbers");
            return;
          }

          if (minVal >= maxVal) {
            alert("Low limit must be less than High limit");
            return;
          }

          customThresholds[sensorName] = { min: minVal, max: maxVal };
          saveThresholdsToStorage();

          // Send to backend
          fetch("/api/thresholds", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              sensor: sensorName,
              min: minVal,
              max: maxVal,
            }),
          })
            .then((r) => r.json())
            .then((data) => {
              if (data.success) {
                // Update UI to show threshold is active
                const sensorItem = document.querySelector(
                  `[data-sensor="${sensorName}"]`
                );
                if (sensorItem) {
                  sensorItem.classList.add("threshold-active");
                }
                // Show success feedback
                const btn = event?.target;
                if (btn) {
                  const originalText = btn.textContent;
                  btn.textContent = "‚úì Saved";
                  btn.style.background = "#059669";
                  setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = "";
                  }, 1500);
                }
              }
            })
            .catch(console.error);
        }
      }

      // Reset threshold to default
      function resetThreshold(sensorName, event) {
        if (event) {
          event.stopPropagation();
        }
        delete customThresholds[sensorName];
        saveThresholdsToStorage();

        // Get actual defaults from SENSOR_THRESHOLDS
        const defaults = getDefaultThreshold(sensorName);

        // Update inputs
        const minInput = document.getElementById(`min-${sensorName}`);
        const maxInput = document.getElementById(`max-${sensorName}`);
        if (minInput) minInput.value = defaults.low;
        if (maxInput) maxInput.value = defaults.high;

        // Send to backend
        fetch("/api/thresholds", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            sensor: sensorName,
            min: defaults.low,
            max: defaults.high,
            reset: true,
          }),
        }).catch(console.error);

        // Update UI
        const sensorItem = document.querySelector(
          `[data-sensor="${sensorName}"]`
        );
        if (sensorItem) {
          sensorItem.classList.remove("threshold-active");
        }
      }

      // Initialize thresholds on load
      loadThresholds();
      loadDefaultThresholds();

      function changeHistoryCategory() {
        selectedHistoryCategory =
          document.getElementById("historyCategory").value;
        // Update Live Sensor Readings immediately when category changes
        updateLiveSensorReadings();
      }

      function formatNumber(value, decimals = 2) {
        if (value === null || value === undefined || isNaN(value)) {
          return "0.0";
        }
        return Number(value).toFixed(decimals);
      }

      function formatDateTime(value) {
        if (!value) return "";
        const date = new Date(value);
        return isNaN(date.getTime()) ? value : date.toLocaleString();
      }

      let activeCategory = "environmental";
      let activeStatsCategory = "environmental";
      const categoryIcons = {
        environmental: "üåç",
        mechanical: "‚öôÔ∏è",
        thermal: "üî•",
        electrical: "‚ö°",
        fluid: "üíß",
        custom: "‚ûï",
      };

      function switchCategory(category) {
        activeCategory = category;
        // Update tab UI for All Sensor Parameters
        document.querySelectorAll("#categoryTabs .tab").forEach((tab) => {
          tab.classList.toggle("active", tab.dataset.category === category);
        });
        // Update content UI for All Sensor Parameters
        document
          .querySelectorAll("#categoryContent .tab-content")
          .forEach((content) => {
            content.classList.toggle(
              "active",
              content.dataset.category === category
            );
          });
      }

      function switchStatsCategory(category) {
        activeStatsCategory = category;
        // Update tab UI for Statistics
        document.querySelectorAll("#statsCategoryTabs .tab").forEach((tab) => {
          tab.classList.toggle("active", tab.dataset.category === category);
        });
        // Update content UI for Statistics
        document
          .querySelectorAll("#statsCategoryContent .tab-content")
          .forEach((content) => {
            content.classList.toggle(
              "active",
              content.dataset.category === category
            );
          });
      }

      // ============================================
      // HEALTH MATRIX CALCULATION & RENDERING
      // ============================================
      
      // Calculate health percentage for a category based on threshold violations
      function calculateCategoryHealth(categoryName, statsData) {
        if (!statsData || !statsData.stats_by_category) {
          return { health: 100, status: 'nom', violations: 0, total: 0 };
        }
        
        const categoryData = statsData.stats_by_category[categoryName];
        if (!categoryData || !categoryData.sensors) {
          return { health: 100, status: 'nom', violations: 0, total: 0 };
        }
        
        const sensors = Object.keys(categoryData.sensors);
        if (sensors.length === 0) {
          return { health: 100, status: 'nom', violations: 0, total: 0 };
        }
        
        let violations = 0;
        let total = 0;
        
        sensors.forEach(sensorName => {
          total++;
          const sensorData = categoryData.sensors[sensorName];
          const currentValue = sensorData.current;
          
          if (currentValue !== null && currentValue !== undefined) {
            const threshold = getThreshold(sensorName);
            const min = threshold.min;
            const max = threshold.max;
            
            // Check if value violates threshold
            if (currentValue < min || currentValue > max) {
              violations++;
            }
          }
        });
        
        const health = total > 0 ? Math.round(((total - violations) / total) * 100) : 100;
        let status = 'nom';
        if (health < 70) {
          status = 'crit';
        } else if (health < 90) {
          status = 'wrn';
        }
        
        return { health, status, violations, total };
      }
      
      // Render health matrix grid (6 cards)
      function renderHealthMatrix(statsData) {
        const container = document.getElementById('healthMatrixContainer');
        if (!container) return;
        
        const categories = [
          { key: 'environmental', name: 'ENVIRON' },
          { key: 'electrical', name: 'ELECTRIC' },
          { key: 'fluid', name: 'FLUID' },
          { key: 'mechanical', name: 'MECH' },
          { key: 'thermal', name: 'THERMAL' },
          { key: 'custom', name: 'CUSTOM' }
        ];
        
        let html = '<div class="health-matrix">';
        
        categories.forEach(cat => {
          const healthData = calculateCategoryHealth(cat.key, statsData);
          const statusClass = healthData.status;
          const statusLabel = statusClass === 'nom' ? 'NOM' : statusClass === 'wrn' ? 'WRN' : 'CRIT';
          
          // Use frontend timer for uptime (synced across all cards)
          const uptime = formatUptime(systemStartTime, systemPausedTime, accumulatedUptime);
          
          // Get anomaly history for this category
          const currentMachine = machineData[selectedMachineId];
          const categoryAnomalies = (currentMachine?.anomalies || []).filter(anomaly => {
            // Match anomalies by sensor category
            const sensors = anomaly.detected_sensors || [];
            return sensors.some(sensor => {
              const sensorCategory = getSensorCategory(sensor);
              return sensorCategory === cat.key;
            });
          }).slice(0, 3); // Last 3 anomalies
          
          // Format anomaly history
          let anomalyHistoryHtml = '';
          if (categoryAnomalies.length === 0) {
            anomalyHistoryHtml = '<div style="font-family: var(--font-mono); font-size: 9px; color: var(--status-running); font-weight: 700;">No Recent Anomalies</div>';
          } else {
            anomalyHistoryHtml = categoryAnomalies.map(anomaly => {
              const time = new Date(anomaly.created_at);
              const timeStr = `${String(time.getHours()).padStart(2, '0')}:${String(time.getMinutes()).padStart(2, '0')}`;
              const sensor = (anomaly.detected_sensors || [])[0] || 'Unknown';
              const sensorName = sensor.replace(/_/g, ' ').substring(0, 15);
              return `<div style="font-family: var(--font-mono); font-size: 9px; color: var(--text-primary); margin-bottom: 2px;">${sensorName} @ ${timeStr}</div>`;
            }).join('');
          }
          
          // Update status label if paused
          const displayStatusLabel = isSystemPaused && statusClass !== 'err' ? 'PAUSED' : statusLabel;
          const displayStatusClass = isSystemPaused && statusClass !== 'err' ? 'wrn' : statusClass;
          
          html += `
            <div class="health-card" onclick="openHealthCardModal('${cat.key}', '${cat.name}')">
              <div class="health-card-header">
                <div class="health-card-name">${cat.name}</div>
                <div class="health-card-status">
                  <div class="health-card-status-dot ${displayStatusClass}"></div>
                  <span class="health-card-status-label">${displayStatusLabel}</span>
                </div>
              </div>
              <div class="health-card-value ${displayStatusClass}">${healthData.health}%</div>
              <div class="health-card-meta">
                <div class="health-card-meta-item" style="grid-column: 1 / -1; margin-top: var(--space-xs); padding-top: var(--space-xs); border-top: 1px solid var(--border-subtle);">
                  <div class="health-card-meta-label" style="margin-bottom: var(--space-xs);">ANOMALY LOG</div>
                  <div style="font-family: var(--font-mono); font-size: 9px; color: var(--text-secondary);">
                    ${anomalyHistoryHtml}
                  </div>
                </div>
                <div class="health-card-meta-item">
                  <div class="health-card-meta-label">UPTIME</div>
                  <div class="health-card-meta-value" data-uptime-category="${cat.key}">${uptime}</div>
                </div>
                <div class="health-card-meta-item" data-rul-machine="${selectedMachineId}">
                  <div class="health-card-meta-label">EST. LIFE</div>
                  <div class="health-card-meta-value rul-countdown" data-rul-machine="${selectedMachineId}" style="font-family: var(--font-mono); font-size: 10px; color: var(--status-running);">--</div>
                </div>
              </div>
            </div>
          `;
        });
        
        html += '</div>';
        container.innerHTML = html;
      }
      
      // ============================================
      // TELEMETRY TILES - Sparklines + LSTM Predictions
      // ============================================
      
      // Generate sparkline SVG from data points
      function generateSparkline(values, width = 200, height = 40, threshold = null, statusClass = '') {
        // Filter out NaN, undefined, and null values
        const cleanValues = (values || []).filter(v => v !== null && v !== undefined && !isNaN(v) && isFinite(v));
        
        if (cleanValues.length === 0) {
          return '<svg width="' + width + '" height="' + height + '"></svg>';
        }
        
        const min = Math.min(...cleanValues);
        const max = Math.max(...cleanValues);
        const range = max - min || 1;
        const padding = 4;
        
        // Determine line color based on threshold violations
        let strokeColor = 'var(--status-running)'; // Neon Green (default)
        if (statusClass === 'crit') {
          strokeColor = 'var(--status-error)'; // Neon Red
        } else if (statusClass === 'wrn') {
          strokeColor = 'var(--status-warning)'; // Neon Yellow
        }
        
        // Check if any values violate threshold
        if (threshold && threshold.min !== undefined && threshold.max !== undefined) {
          const hasViolation = cleanValues.some(val => val < threshold.min || val > threshold.max);
          if (hasViolation) {
            strokeColor = 'var(--status-error)'; // Neon Red for violations
          }
        }
        
        const points = cleanValues.map((val, i) => {
          const x = padding + (i / (cleanValues.length - 1 || 1)) * (width - 2 * padding);
          const y = height - padding - ((val - min) / range) * (height - 2 * padding);
          return `${x},${y}`;
        }).join(' ');
        
        return `<svg width="${width}" height="${height}">
          <polyline points="${points}" class="telemetry-tile-sparkline-line" fill="none" stroke="${strokeColor}" stroke-width="1.5" vector-effect="non-scaling-stroke" style="filter: drop-shadow(0 0 2px ${strokeColor});"/>
        </svg>`;
      }
      
      // ============================================
      // ALARM CONSOLE - Bottom Panel Table
      // ============================================
      
      // Render alarm console table in bottom panel
      function renderAlarmConsole(alerts) {
        const container = document.getElementById('alarmConsoleContent');
        if (!container) return;
        
        if (!alerts || alerts.length === 0) {
          container.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 40px; font-family: var(--font-mono); font-size: 11px;">NO ALARMS</div>';
          return;
        }
        
        // Sort by severity (critical > error > warning > info) and then by time (newest first)
        const severityOrder = { critical: 0, error: 1, warning: 2, info: 3 };
        const sortedAlerts = [...alerts].sort((a, b) => {
          const aSev = severityOrder[(a.severity || 'info').toLowerCase()] || 3;
          const bSev = severityOrder[(b.severity || 'info').toLowerCase()] || 3;
          if (aSev !== bSev) return aSev - bSev;
          // Then by time (newest first)
          const aTime = new Date(a.created_at || a.timestamp || 0).getTime();
          const bTime = new Date(b.created_at || b.timestamp || 0).getTime();
          return bTime - aTime;
        });
        
        // Show last 20 alarms
        const displayAlerts = sortedAlerts.slice(0, 20);
        
        let html = '<table class="alarm-console-table">';
        html += '<thead><tr><th>TIME</th><th>SEVERITY</th><th>MESSAGE</th></tr></thead>';
        html += '<tbody>';
        
        displayAlerts.forEach(alert => {
          const severity = (alert.severity || 'info').toLowerCase();
          const time = formatDateTime(alert.created_at || alert.timestamp);
          const message = alert.message || 'No message';
          
          html += `
            <tr>
              <td class="alarm-time">${time}</td>
              <td><span class="alarm-severity ${severity}">${severity.toUpperCase()}</span></td>
              <td class="alarm-message">${message}</td>
            </tr>
          `;
        });
        
        html += '</tbody></table>';
        container.innerHTML = html;
      }
      
      // Render telemetry tiles (8 tiles with sparklines) - uses real sensor data
      function renderTelemetryTiles(statsData, recentReadings, lstmPredictions) {
        const container = document.getElementById('telemetryContainer');
        if (!container) return;
        
        // Priority sensors across categories (real sensors from config)
        const prioritySensors = [
          { name: 'temperature', category: 'environmental' },
          { name: 'pressure', category: 'environmental' },
          { name: 'voltage', category: 'electrical' },
          { name: 'current', category: 'electrical' },
          { name: 'rpm', category: 'mechanical' },
          { name: 'vibration', category: 'mechanical' },
          { name: 'coolant_temp', category: 'thermal' },
          { name: 'flow_rate', category: 'fluid' }
        ];
        
        let html = '<div class="telemetry-grid">';
        
        prioritySensors.forEach(sensor => {
          const sensorName = sensor.name;
          // Get current value from stats
          let currentValue = null;
          let unit = '';
          let statusClass = '';
          
          // First try: stats_by_category (primary source)
          if (statsData && statsData.stats_by_category) {
            const catData = statsData.stats_by_category[sensor.category];
            if (catData && catData.sensors && catData.sensors[sensorName]) {
              currentValue = catData.sensors[sensorName].current;
              unit = catData.sensors[sensorName].unit || '';
            }
          }
          
          // Fallback: Try recent readings (most recent value)
          if ((currentValue === null || currentValue === undefined || isNaN(currentValue)) && recentReadings && recentReadings.length > 0) {
            const latestReading = recentReadings[0];
            // Check both direct property and custom_sensors
            if (latestReading[sensorName] !== null && latestReading[sensorName] !== undefined && !isNaN(latestReading[sensorName])) {
              currentValue = parseFloat(latestReading[sensorName]);
            } else if (latestReading.custom_sensors && latestReading.custom_sensors[sensorName] !== null && latestReading.custom_sensors[sensorName] !== undefined && !isNaN(latestReading.custom_sensors[sensorName])) {
              currentValue = parseFloat(latestReading.custom_sensors[sensorName]);
            }
          }
          
          // Get unit from metadata if not found
          if (!unit) {
            const metadata = getSensorMetadata(sensorName);
            unit = metadata ? metadata.unit : '';
          }
              
              // Check threshold violation
              const threshold = getThreshold(sensorName);
          if (currentValue !== null && currentValue !== undefined && !isNaN(currentValue)) {
                if (currentValue < threshold.min || currentValue > threshold.max) {
                  statusClass = currentValue < threshold.min * 0.8 || currentValue > threshold.max * 1.2 ? 'crit' : 'wrn';
            }
          }
          
          // Get historical values for sparkline (last 30 readings for better trend)
          const historicalValues = [];
          if (recentReadings && recentReadings.length > 0) {
            // Get last 30 readings, reverse for chronological order
            const readings = recentReadings.slice(0, 30).reverse();
            readings.forEach(reading => {
              // Check both direct property and custom_sensors object
              let value = reading[sensorName];
              if (value === null || value === undefined) {
                value = reading.custom_sensors && reading.custom_sensors[sensorName];
              }
              if (value !== null && value !== undefined && !isNaN(value)) {
                historicalValues.push(parseFloat(value));
              }
            });
          }
          
          // If no historical data, use current value as single point
          if (historicalValues.length === 0 && currentValue !== null) {
            historicalValues.push(currentValue);
          }
          
          // Get LSTM predictions for this sensor
          const lstmDots = [];
          if (lstmPredictions && lstmPredictions.sensor_predictions) {
            const sensorPreds = lstmPredictions.sensor_predictions[sensorName];
            if (sensorPreds && sensorPreds.length > 0) {
              sensorPreds.slice(0, 10).forEach(pred => {
                lstmDots.push(pred.anomaly_probability > 0.7 ? 'anomaly' : 'predicted');
              });
            }
          }
          
          const displayName = sensorName.replace(/_/g, ' ').toUpperCase();
          
          // Calculate average from accumulated sums/counts (more accurate than historical values)
          const currentMachine = machineData[selectedMachineId];
          let avgValue = 0;
          if (currentMachine && currentMachine.sensorSums && currentMachine.sensorSums[sensorName] && currentMachine.sensorCounts && currentMachine.sensorCounts[sensorName] > 0) {
            avgValue = currentMachine.sensorSums[sensorName] / currentMachine.sensorCounts[sensorName];
          } else if (historicalValues.length > 0) {
            // Fallback to historical values average
            avgValue = historicalValues.reduce((a, b) => a + b, 0) / historicalValues.length;
          } else if (currentValue !== null && currentValue !== undefined) {
            avgValue = currentValue;
          }
          
          // Format current value - show 0.0 instead of -- when no data
          const displayCurrentValue = currentValue !== null && currentValue !== undefined && !isNaN(currentValue) ? currentValue : 0;
          const displayAvgValue = avgValue || 0;
          
          // Get threshold color class
          const thresholdForSparkline = getThreshold(sensorName);
          const currentColorClass = getThresholdColorClass(displayCurrentValue, thresholdForSparkline);
          const avgColorClass = getThresholdColorClass(displayAvgValue, thresholdForSparkline);
          
          // Generate sparkline with threshold and status class for dynamic coloring
          const sparkline = generateSparkline(
            historicalValues.length > 0 ? historicalValues : (currentValue !== null && currentValue !== undefined && !isNaN(currentValue) ? [currentValue] : []), 
            200, 
            40,
            thresholdForSparkline,
            statusClass
          );
          const sparklineClass = statusClass ? ` ${statusClass}` : '';
          
          html += `
            <div class="telemetry-tile ${statusClass}">
              <div class="telemetry-tile-header">
                <div class="telemetry-tile-name">${displayName}</div>
                <div class="telemetry-tile-unit">${unit}</div>
              </div>
              <div class="telemetry-tile-value ${currentColorClass}" style="font-family: var(--font-mono); font-weight: 700;">${formatNumber(displayCurrentValue, 1)}</div>
              <div class="telemetry-tile-sparkline">
                ${sparkline}
              </div>
              ${lstmDots.length > 0 ? `
                <div class="telemetry-tile-lstm">
                  <span class="telemetry-tile-lstm-label">LSTM:</span>
                  <div class="telemetry-tile-lstm-dots">
                    ${lstmDots.map(dot => `<div class="telemetry-tile-lstm-dot ${dot}"></div>`).join('')}
                  </div>
                </div>
              ` : ''}
              <div class="telemetry-tile-footer">
                <div class="telemetry-tile-footer-row">
                  <span class="telemetry-tile-footer-label" style="font-weight: 700;">CURR</span>
                  <span class="telemetry-tile-footer-value ${currentColorClass}" style="font-family: var(--font-mono); font-weight: 700;">${formatNumber(displayCurrentValue, 1)}</span>
                </div>
                <div class="telemetry-tile-footer-row">
                  <span class="telemetry-tile-footer-label" style="font-weight: 700;">AVG</span>
                  <span class="telemetry-tile-footer-value ${avgColorClass}" style="font-family: var(--font-mono); font-weight: 700;">${formatNumber(displayAvgValue, 1)}</span>
                </div>
              </div>
            </div>
          `;
        });
        
        html += '</div>';
        container.innerHTML = html;
      }

      // ============================================
      // GRIDSTACK INITIALIZATION & LAYOUT EDIT MODE
      // ============================================
      let monitoringGrid = null;
      let configGrid = null;
      let layoutEditMode = false;

      function initGridstacks() {
        if (typeof GridStack === 'undefined') {
          console.warn('Gridstack.js not loaded');
          return;
        }
        
        const gridOptions = {
          column: 12,
          cellHeight: Math.floor((window.innerHeight - 60 - 32) / 20), // Dynamic based on vh
          margin: 8,
          float: false,
          disableDrag: true,  // Fixed layout by default
          disableResize: true,
          staticGrid: true
        };
        
        const monitoringEl = document.getElementById('monitoringGrid');
        if (monitoringEl) {
          monitoringGrid = GridStack.init(gridOptions, '#monitoringGrid');
          
          // Handle resize events for Three.js canvas
          monitoringGrid.on('resizestop', function(event, items) {
            const item = items[0];
            if (item && item.el) {
              const canvas = item.el.querySelector('#rigCanvas');
              if (canvas && rigRenderer && rigCamera) {
                // Resize Three.js canvas
                const container = canvas.parentElement;
                const width = container.clientWidth;
                const height = container.clientHeight;
                rigCamera.aspect = width / height;
                rigCamera.updateProjectionMatrix();
                rigRenderer.setSize(width, height);
                // Update controls if available
                if (rigControls) {
                  rigControls.update();
                }
              }
            }
          });
          
          // Handle move events for Three.js canvas (when 3D rig is moved)
          monitoringGrid.on('change', function(event, items) {
            items.forEach(item => {
              if (item && item.el) {
                const canvas = item.el.querySelector('#rigCanvas');
                if (canvas && rigRenderer && rigCamera) {
                  // Trigger resize after move
                  setTimeout(() => {
                    onRigResize();
                  }, 50);
                }
              }
            });
          });
        }
        
        const configEl = document.getElementById('configGrid');
        if (configEl) {
          configGrid = GridStack.init(gridOptions, '#configGrid');
          
          // Handle resize events for config grid widgets
          configGrid.on('resizestop', function(event, items) {
            // Any resize handling if needed
          });
          
          // Handle move events
          configGrid.on('change', function(event, items) {
            // Any move handling if needed
          });
        }
        
        console.log('Gridstack initialized (monitoring + config)');
      }
      
      // Initialize Admin Grid
      let adminGrid = null;
      function initAdminGrid() {
        if (typeof GridStack === 'undefined') {
          console.warn('Gridstack.js not loaded');
          return;
        }
        
        const gridOptions = {
          column: 12,
          cellHeight: Math.floor((window.innerHeight - 60 - 32) / 20), // Dynamic based on vh
          margin: 8,
          float: false,
          disableDrag: true,
          disableResize: true,
          staticGrid: true
        };
        
        const adminEl = document.getElementById('adminGrid');
        if (adminEl && !adminGrid) {
          adminGrid = GridStack.init(gridOptions, '#adminGrid');
          console.log('Admin grid initialized');
        }
      }
      
      // E-STOP Function
      async function triggerEmergencyStop() {
        if (!confirm('‚ö†Ô∏è EMERGENCY STOP: This will freeze all systems. Continue?')) {
          return;
        }
        
        try {
          const response = await fetch('/api/admin/emergency-stop', {
            method: 'POST',
            credentials: 'include'
          });
          
          if (response.ok) {
            const data = await response.json();
            alert('‚úì System freeze activated: ' + (data.message || 'All systems stopped'));
            // Refresh page state
            location.reload();
          } else {
            const error = await response.json();
            alert('‚úó Failed to activate E-STOP: ' + (error.error || 'Unknown error'));
          }
        } catch (e) {
          alert('‚úó Network error: ' + e.message);
        }
      }
      
      // Load Admin Audit Logs
      async function loadAdminAuditLogs() {
        const tbody = document.getElementById('adminAuditLogsBody');
        if (!tbody) return;
        
        try {
          const response = await fetch('/api/audit-logs?limit=100', {
            credentials: 'include'
          });
          
          if (response.ok) {
            const data = await response.json();
            if (data.logs && data.logs.length > 0) {
              tbody.innerHTML = data.logs.map(log => `
                <tr style="border-bottom: 1px solid var(--border-subtle);">
                  <td style="padding: var(--space-xs); font-family: var(--font-mono); font-size: 9px; color: var(--text-primary);">${new Date(log.timestamp).toLocaleString()}</td>
                  <td style="padding: var(--space-xs); font-family: var(--font-mono); font-size: 9px; color: var(--text-primary); font-weight: 700;">${log.username || 'N/A'}</td>
                  <td style="padding: var(--space-xs); font-family: var(--font-mono); font-size: 9px; color: var(--text-primary);">${log.action || 'N/A'}</td>
                  <td style="padding: var(--space-xs); font-family: var(--font-mono); font-size: 9px; color: var(--text-muted);">${log.details || 'N/A'}</td>
                </tr>
              `).join('');
            } else {
              tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: var(--text-muted); padding: var(--space-md);">No audit logs</td></tr>';
            }
          }
        } catch (e) {
          tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: var(--status-error); padding: var(--space-md);">Error loading logs</td></tr>';
        }
      }
      
      // Admin Create User Function
      async function adminCreateUser(event) {
        event.preventDefault();
        
        const username = document.getElementById('adminNewUsername').value;
        const password = document.getElementById('adminNewPassword').value;
        const role = document.getElementById('adminNewRole').value;
        const machines = Array.from(document.querySelectorAll('.admin-machine-checkbox:checked')).map(cb => cb.value);
        
        const errorEl = document.getElementById('adminCreateUserError');
        const successEl = document.getElementById('adminCreateUserSuccess');
        
        try {
          const response = await fetch('/api/auth/signup', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'include',
            body: JSON.stringify({ username, password, role, accessible_machines: machines })
          });
          
          const data = await response.json();
          
          if (response.ok && data.success) {
            if (errorEl) errorEl.style.display = 'none';
            if (successEl) {
              successEl.style.display = 'block';
              successEl.textContent = '‚úì User created successfully';
            }
            document.getElementById('adminCreateUserForm').reset();
            loadAdminUserList();
            setTimeout(() => {
              if (successEl) successEl.style.display = 'none';
            }, 3000);
          } else {
            if (successEl) successEl.style.display = 'none';
            if (errorEl) {
              errorEl.style.display = 'block';
              errorEl.textContent = '‚úó ' + (data.error || 'Failed to create user');
            }
          }
        } catch (e) {
          if (successEl) successEl.style.display = 'none';
          if (errorEl) {
            errorEl.style.display = 'block';
            errorEl.textContent = '‚úó Network error: ' + e.message;
          }
        }
      }
      
      // Load Admin User List
      async function loadAdminUserList() {
        const container = document.getElementById('adminUserListContent');
        if (!container) return;
        
        try {
          const response = await fetch('/api/admin/users', {
            credentials: 'include'
          });
          
          if (response.ok) {
            const data = await response.json();
            if (data.users && data.users.length > 0) {
              container.innerHTML = data.users.map(user => `
                <div style="padding: var(--space-sm); border-bottom: 1px solid var(--border-subtle); display: flex; justify-content: space-between; align-items: center;">
                  <div>
                    <span style="font-family: var(--font-mono); font-size: 11px; font-weight: 700; color: var(--text-primary);">${user.username}</span>
                    <span style="font-family: var(--font-mono); font-size: 9px; color: var(--text-muted); margin-left: var(--space-sm);">${user.role}</span>
                  </div>
                  <span style="font-family: var(--font-mono); font-size: 9px; color: var(--text-muted);">Machines: ${(user.accessible_machines || []).join(', ') || 'None'}</span>
                </div>
              `).join('');
            } else {
              container.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: var(--space-lg);">No users found</div>';
            }
          }
        } catch (e) {
          container.innerHTML = '<div style="text-align: center; color: var(--status-error); padding: var(--space-lg);">Error loading users</div>';
        }
      }

      // Alarms update interval
      let alarmsUpdateInterval = null;
      
      // Initialize Alarms Grid (deprecated - using telemetry-grid now)
      let alarmsGrid = null;
      function initAlarmsGrid() {
        if (typeof GridStack === 'undefined') {
          console.warn('Gridstack.js not loaded');
          return;
        }
        
        const gridOptions = {
          column: 12,
          cellHeight: 50,
          margin: 4,
          float: false,
          disableDrag: true,
          disableResize: true,
          staticGrid: true
        };
        
        const alarmsEl = document.getElementById('alarmsGrid');
        if (alarmsEl && !alarmsGrid) {
          alarmsGrid = GridStack.init(gridOptions, '#alarmsGrid');
          console.log('Alarms grid initialized');
        }
      }
      
      // Render Category Filter Bar for Alarms
      function renderAlarmsCategoryToggles() {
        const container = document.getElementById('alarmsCategoryFilterBar');
        if (!container) return;
        
        const categories = [
          { key: 'environmental', label: 'ENVIRONMENTAL', icon: 'üåç' },
          { key: 'mechanical', label: 'MECHANICAL', icon: '‚öôÔ∏è' },
          { key: 'thermal', label: 'THERMAL', icon: 'üî•' },
          { key: 'electrical', label: 'ELECTRICAL', icon: '‚ö°' },
          { key: 'fluid', label: 'FLUID', icon: 'üíß' }
        ];
        
        let html = '';
        categories.forEach(cat => {
          html += `
            <button 
              class="alarms-category-filter-btn" 
              data-category="${cat.key}" 
              onclick="toggleAlarmsCategory('${cat.key}')"
              style="padding: var(--space-xs) var(--space-sm); background: var(--bg-secondary); border: 1px solid var(--border-default); border-radius: 4px; color: var(--text-primary); font-family: var(--font-mono); font-size: 10px; font-weight: 700; cursor: pointer; transition: all var(--theme-transition-normal);">
              ${cat.icon} ${cat.label}
            </button>
          `;
        });
        
        container.innerHTML = html;
      }
      
      // Render Alarm Matrix (Gridstack with 50+ sensor tiles)
      function renderAlarmMatrix() {
        if (!alarmsGrid) {
          initAlarmsGrid();
        }
        
        const gridEl = document.getElementById('alarmsGrid');
        if (!gridEl || !alarmsGrid) return;
        
        const currentMachine = machineData[selectedMachineId];
        if (!currentMachine || !currentMachine.statsData) {
          gridEl.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: var(--space-lg);">No sensor data available</div>';
          return;
        }
        
        // Get all sensors from stats data
        const statsData = currentMachine.statsData;
        let allSensors = [];
        
        // Collect sensors from all categories
        if (statsData.stats_by_category) {
          Object.values(statsData.stats_by_category).forEach(catData => {
            if (catData.sensors) {
              Object.entries(catData.sensors).forEach(([sensorName, sensorData]) => {
                allSensors.push({
                  name: sensorName,
                  category: sensorData.category || 'custom',
                  unit: sensorData.unit || '',
                  current: sensorData.current
                });
              });
            }
          });
        }
        
        // Get visible categories from filter buttons
        const visibleCategories = new Set();
        document.querySelectorAll('.alarms-category-filter-btn').forEach(btn => {
          if (!btn.classList.contains('inactive')) {
            visibleCategories.add(btn.dataset.category);
          }
        });
        
        // If no categories selected, show all
        if (visibleCategories.size === 0) {
          ['environmental', 'mechanical', 'thermal', 'electrical', 'fluid'].forEach(cat => {
            visibleCategories.add(cat);
          });
        }
        
        // Filter sensors by visible categories
        const visibleSensors = allSensors.filter(sensor => {
          return visibleCategories.has(sensor.category);
        });
        
        if (visibleSensors.length === 0) {
          alarmsGrid.removeAll();
          gridEl.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: var(--space-lg);">No sensors in selected categories</div>';
          return;
        }
        
        // Clear existing widgets
        alarmsGrid.removeAll();
        
        // Generate sensor tiles (gs-w="2" gs-h="2")
        visibleSensors.forEach((sensor, index) => {
          const sensorName = sensor.name;
          const displayName = sensorName.replace(/_/g, ' ').toUpperCase();
          const unit = sensor.unit;
          const value = sensor.current;
          
          // Get recent readings for sparkline
          const recentValues = currentMachine.recentReadings
            ? currentMachine.recentReadings.map(r => r[sensorName]).filter(v => v !== null && v !== undefined && !isNaN(v)).slice(-20)
            : [];
          
          // Determine status class
          let statusClass = '';
          if (value !== null && value !== undefined && !isNaN(value)) {
            const sensorMeta = unifiedSensorRegistry && unifiedSensorRegistry[sensorName];
            if (sensorMeta) {
              if (sensorMeta.high_threshold && value > sensorMeta.high_threshold) {
                statusClass = 'crit';
              } else if (sensorMeta.low_threshold && value < sensorMeta.low_threshold) {
                statusClass = 'crit';
              } else if (sensorMeta.high_threshold && value > sensorMeta.high_threshold * 0.8) {
                statusClass = 'wrn';
              }
            }
          }
          
          // Calculate grid position (6 columns per row, 2 width each)
          const x = (index % 6) * 2;
          const y = Math.floor(index / 6) * 2;
          
          const widget = document.createElement('div');
          widget.className = 'grid-stack-item';
          widget.setAttribute('data-gs-x', x);
          widget.setAttribute('data-gs-y', y);
          widget.setAttribute('data-gs-width', '2');
          widget.setAttribute('data-gs-height', '2');
          widget.setAttribute('data-sensor', sensorName);
          widget.setAttribute('data-category', sensor.category);
          
          widget.innerHTML = `
            <div class="grid-stack-item-content">
              <div class="telemetry-tile ${statusClass}" style="height: 100%; padding: var(--space-sm);">
                <div class="telemetry-tile-header">
                  <span class="telemetry-tile-name">${displayName}</span>
                  <span class="telemetry-tile-unit">${unit}</span>
                </div>
                <div class="telemetry-tile-value ${statusClass}" id="alarmsTileValue-${sensorName}">
                  ${value !== null && value !== undefined && !isNaN(value) ? value.toFixed(1) : '--'}
                </div>
                <div class="telemetry-tile-sparkline" id="alarmsTileSparkline-${sensorName}">
                  ${recentValues.length > 0 ? generateSparkline(recentValues, 30, 80) : ''}
                </div>
              </div>
            </div>
          `;
          
          alarmsGrid.addWidget(widget);
        });
        
        // Update alarms list
        updateAlarmsList();
      }
      
      // Legacy function name for compatibility
      function renderAlarmsChartMatrix() {
        renderAlarmMatrix();
      }
      
      // Toggle Category Visibility
      function toggleAlarmsCategory(category) {
        const btn = document.querySelector(`.alarms-category-filter-btn[data-category="${category}"]`);
        if (btn) {
          btn.classList.toggle('inactive');
          if (btn.classList.contains('inactive')) {
            btn.style.opacity = '0.3';
            btn.style.borderColor = 'var(--border-subtle)';
          } else {
            btn.style.opacity = '1';
            btn.style.borderColor = 'var(--border-default)';
          }
        }
        renderAlarmMatrix();
      }
      
      // Barbie Mode Toggle Button
      let barbieModeEnabled = false;
      function toggleBarbieModeButton() {
        barbieModeEnabled = !barbieModeEnabled;
        toggleBarbieMode(barbieModeEnabled);
        const statusEl = document.getElementById('barbieModeStatus');
        if (statusEl) {
          statusEl.textContent = barbieModeEnabled ? 'ON' : 'OFF';
        }
        const btn = document.getElementById('barbieModeToggle');
        if (btn) {
          if (barbieModeEnabled) {
            btn.style.background = '#ff69b4';
            btn.style.borderColor = '#ff69b4';
          } else {
            btn.style.background = 'var(--theme-interactive-primary)';
            btn.style.borderColor = 'var(--theme-interactive-primary)';
          }
        }
      }
      
      // Barbie Mode Toggle
      function toggleBarbieMode(enabled) {
        if (enabled) {
          document.documentElement.style.setProperty('--theme-bg-base', '#1a0a1a');
          document.documentElement.style.setProperty('--theme-bg-primary', '#2a1a2a');
          document.documentElement.style.setProperty('--theme-bg-secondary', '#3a2a3a');
          document.documentElement.style.setProperty('--theme-interactive-primary', '#ff69b4');
          document.documentElement.style.setProperty('--theme-status-running', '#ff1493');
          document.documentElement.style.setProperty('--theme-status-info', '#ff69b4');
        } else {
          // Reset to default theme
          document.documentElement.style.removeProperty('--theme-bg-base');
          document.documentElement.style.removeProperty('--theme-bg-primary');
          document.documentElement.style.removeProperty('--theme-bg-secondary');
          document.documentElement.style.removeProperty('--theme-interactive-primary');
          document.documentElement.style.removeProperty('--theme-status-running');
          document.documentElement.style.removeProperty('--theme-status-info');
        }
      }
      
      // Matrix Mode Toggle Button
      let matrixModeEnabled = false;
      function toggleMatrixModeButton() {
        matrixModeEnabled = !matrixModeEnabled;
        toggleMatrixMode(matrixModeEnabled);
        const statusEl = document.getElementById('matrixModeStatus');
        if (statusEl) {
          statusEl.textContent = matrixModeEnabled ? 'ON' : 'OFF';
        }
        const btn = document.getElementById('matrixModeToggle');
        if (btn) {
          if (matrixModeEnabled) {
            btn.style.background = '#00ff00';
            btn.style.borderColor = '#00ff00';
            btn.style.color = '#000000';
          } else {
            btn.style.background = 'var(--theme-interactive-primary)';
            btn.style.borderColor = 'var(--theme-interactive-primary)';
            btn.style.color = 'var(--text-primary)';
          }
        }
      }
      
      // Matrix Mode Toggle
      function toggleMatrixMode(enabled) {
        if (enabled) {
          document.documentElement.style.setProperty('--theme-bg-base', '#000000');
          document.documentElement.style.setProperty('--theme-bg-primary', '#001100');
          document.documentElement.style.setProperty('--theme-bg-secondary', '#002200');
          document.documentElement.style.setProperty('--theme-text-primary', '#00ff00');
          document.documentElement.style.setProperty('--theme-interactive-primary', '#00ff00');
          document.documentElement.style.setProperty('--theme-status-running', '#00ff00');
        } else {
          // Reset to default theme
          document.documentElement.style.removeProperty('--theme-bg-base');
          document.documentElement.style.removeProperty('--theme-bg-primary');
          document.documentElement.style.removeProperty('--theme-bg-secondary');
          document.documentElement.style.removeProperty('--theme-text-primary');
          document.documentElement.style.removeProperty('--theme-interactive-primary');
          document.documentElement.style.removeProperty('--theme-status-running');
        }
      }

      // Update Alarms List
      function updateAlarmsList() {
        const tbody = document.getElementById('alarmsListBody');
        if (!tbody) return;
        
        const currentMachine = machineData[selectedMachineId];
        if (!currentMachine) {
          tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; color: var(--text-muted); padding: var(--space-md);">No data</td></tr>';
          return;
        }
        
        // Collect alarms from alerts and anomalies
        let alarms = [];
        
        // Add alerts
        if (currentMachine.alerts && currentMachine.alerts.length > 0) {
          currentMachine.alerts.forEach(alert => {
            alarms.push({
              time: new Date(alert.timestamp || Date.now()).toLocaleTimeString(),
              sensor: alert.sensor || 'UNKNOWN',
              value: alert.value !== undefined ? alert.value.toFixed(1) : '--',
              threshold: alert.threshold !== undefined ? alert.threshold.toFixed(1) : '--',
              severity: alert.severity || 'WARNING',
              type: 'alert'
            });
          });
        }
        
        // Add anomalies
        if (currentMachine.anomalies && currentMachine.anomalies.length > 0) {
          currentMachine.anomalies.slice(0, 10).forEach(anomaly => {
            alarms.push({
              time: new Date(anomaly.timestamp || Date.now()).toLocaleTimeString(),
              sensor: anomaly.sensor_name || 'UNKNOWN',
              value: anomaly.value !== undefined ? anomaly.value.toFixed(1) : '--',
              threshold: 'ML DETECTED',
              severity: 'CRITICAL',
              type: 'anomaly'
            });
          });
        }
        
        // Sort by time (newest first)
        alarms.sort((a, b) => new Date(b.time) - new Date(a.time));
        
        if (alarms.length === 0) {
          tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; color: var(--text-muted); padding: var(--space-md);">No active alarms</td></tr>';
          return;
        }
        
        tbody.innerHTML = alarms.map(alarm => {
          const severityColor = alarm.severity === 'CRITICAL' ? 'var(--status-error)' : 
                               alarm.severity === 'WARNING' ? 'var(--status-warning)' : 
                               'var(--status-info)';
          return `
            <tr style="border-bottom: 1px solid var(--border-subtle);">
              <td style="padding: var(--space-xs); font-family: var(--font-mono); font-size: 9px; color: var(--text-primary);">${alarm.time}</td>
              <td style="padding: var(--space-xs); font-family: var(--font-mono); font-size: 9px; color: var(--text-primary); font-weight: 700;">${alarm.sensor}</td>
              <td style="padding: var(--space-xs); font-family: var(--font-mono); font-size: 9px; color: var(--text-primary);">${alarm.value}</td>
              <td style="padding: var(--space-xs); font-family: var(--font-mono); font-size: 9px; color: var(--text-muted);">${alarm.threshold}</td>
              <td style="padding: var(--space-xs); font-family: var(--font-mono); font-size: 9px; color: ${severityColor}; font-weight: 700;">${alarm.severity}</td>
            </tr>
          `;
        }).join('');
      }

      function toggleLayoutEditMode() {
        layoutEditMode = !layoutEditMode;
        const btn = document.getElementById('editLayoutBtn');
        const monitoringGridEl = document.getElementById('monitoringGrid');
        const configGridEl = document.getElementById('configGrid');
        
        // Sync both grids simultaneously
        [monitoringGrid, configGrid].forEach((grid, index) => {
          if (!grid) return;
          
          const gridEl = index === 0 ? monitoringGridEl : configGridEl;
          
          if (layoutEditMode) {
            // Enable edit mode
            grid.setStatic(false);
            grid.enableMove(true);
            grid.enableResize(true);
            if (gridEl) gridEl.classList.add('edit-mode');
          } else {
            // Disable edit mode (save layout)
            grid.setStatic(true);
            grid.enableMove(false);
            grid.enableResize(false);
            if (gridEl) gridEl.classList.remove('edit-mode');
          }
        });
        
        // Show/hide drag handles for all grids
        document.querySelectorAll('.grid-item-drag-handle').forEach(handle => {
          handle.style.display = layoutEditMode ? 'block' : 'none';
        });
        
        if (btn) {
          btn.textContent = layoutEditMode ? '‚úì SAVE LAYOUT' : '‚öôÔ∏è EDIT LAYOUT';
          btn.style.background = layoutEditMode ? 'var(--theme-status-warning)' : 'var(--bg-secondary)';
        }
        
        // Trigger Three.js resize when exiting edit mode
        if (!layoutEditMode && rigRenderer && rigCamera) {
          setTimeout(() => {
            onRigResize();
          }, 100);
        }
      }

      // ============================================
      // LIVE SENSOR STREAM WIDGET
      // ============================================
      function updateLiveSensorStreamWidget() {
        const container = document.getElementById('liveSensorStreamWidget');
        if (!container) return;
        
        const currentMachine = machineData[selectedMachineId];
        if (!currentMachine || !currentMachine.recentReadings || currentMachine.recentReadings.length === 0) {
          container.innerHTML = '<div style="color: var(--text-muted); padding: 8px;">No data</div>';
          return;
        }
        
        // Show last 20 readings
        const readings = currentMachine.recentReadings.slice(-20).reverse();
        
        let html = '<div style="display: flex; flex-direction: column; gap: 2px;">';
        readings.forEach(reading => {
          const timestamp = new Date(reading.timestamp || reading.created_at).toLocaleTimeString();
          const rpm = reading.rpm?.toFixed(0) || 'N/A';
          const temp = reading.temperature?.toFixed(1) || 'N/A';
          const vib = reading.vibration?.toFixed(2) || 'N/A';
          
          html += `
            <div style="padding: 4px; background: var(--bg-tertiary); border-left: 2px solid var(--status-running); display: flex; justify-content: space-between;">
              <span style="color: var(--text-muted);">${timestamp}</span>
              <span style="color: var(--text-primary);">RPM: ${rpm} | T: ${temp}¬∞F | V: ${vib}</span>
            </div>
          `;
        });
        html += '</div>';
        
        container.innerHTML = html;
      }

      // ============================================
      // CRITICAL ALARMS WIDGET
      // ============================================
      function updateCriticalAlarmsWidget() {
        const tbody = document.querySelector('#criticalAlarmsWidget tbody');
        if (!tbody) return;
        
        fetch('/api/anomalies?limit=10&only_anomalies=true')
          .then(r => r.json())
          .then(data => {
            if (!data.anomalies || data.anomalies.length === 0) {
              tbody.innerHTML = '<tr><td colspan="2" style="text-align: center; color: var(--text-muted); padding: 8px;">No critical alarms</td></tr>';
              return;
            }
            
            let html = '';
            data.anomalies.slice(0, 10).forEach(anomaly => {
              const time = new Date(anomaly.timestamp).toLocaleTimeString();
              const sensors = anomaly.detected_sensors?.join(', ') || 'Unknown';
              
              html += `
                <tr style="border-bottom: 1px solid var(--border-subtle);">
                  <td style="padding: 4px; color: var(--text-muted);">${time}</td>
                  <td style="padding: 4px; color: var(--status-error);">${sensors}</td>
                </tr>
              `;
            });
            
            tbody.innerHTML = html;
          })
          .catch(err => {
            tbody.innerHTML = '<tr><td colspan="2" style="text-align: center; color: var(--status-error); padding: 8px;">Error loading alarms</td></tr>';
          });
      }

      function updateStats() {
        fetch("/api/stats")
          .then((r) => r.json())
          .then((data) => {
            // ========== MACHINE DATA ISOLATION ==========
            // Store incoming data ONLY for the currently selected machine
            const currentMachine = machineData[selectedMachineId];

            // Apply machine filtering (non-destructive wrapper)
            data = filterSensorData(data);
            
            // Render health matrix
            renderHealthMatrix(data);
            
            // Render telemetry tiles
            renderTelemetryTiles(data, currentMachine.recentReadings, currentMachine.lstmPredictions);
            
            // Update new widgets
            updateLiveSensorStreamWidget();
            updateCriticalAlarmsWidget();

            // ========== GUARD: Only collect data if producer + machine are running ==========
            if (canCollectData()) {
              // Store filtered data in machine-specific buffer
              currentMachine.statsData = JSON.parse(JSON.stringify(data)); // Deep copy

              // Accumulate readings for this machine (append-only, keep last 100)
              if (data.recent_readings_full && data.recent_readings_full.length > 0) {
                const newReadings = data.recent_readings_full;
                // Merge new readings avoiding duplicates by timestamp
                const existingTimestamps = new Set(currentMachine.recentReadings.map(r => r.created_at));
                newReadings.forEach(reading => {
                  if (!existingTimestamps.has(reading.created_at)) {
                    currentMachine.recentReadings.unshift(reading);

                    // ========== ACCUMULATE SENSOR SUMS/COUNTS FOR AVERAGES ==========
                    // For each sensor value in this reading, add to machine-specific accumulators
                    // Merge custom_sensors into reading for accumulation
                    const mergedReading = { ...reading };
                    if (reading.custom_sensors && typeof reading.custom_sensors === 'object') {
                      Object.assign(mergedReading, reading.custom_sensors);
                    }
                    
                    Object.keys(mergedReading).forEach(sensorName => {
                      if (sensorName !== 'created_at' && sensorName !== 'id' && sensorName !== 'custom_sensors' && typeof mergedReading[sensorName] === 'number') {
                        if (!currentMachine.sensorSums[sensorName]) {
                          currentMachine.sensorSums[sensorName] = 0;
                          currentMachine.sensorCounts[sensorName] = 0;
                        }
                        currentMachine.sensorSums[sensorName] += mergedReading[sensorName];
                        currentMachine.sensorCounts[sensorName] += 1;
                      }
                    });
                  }
                });
                // Keep last 100 readings per machine (increased from 50)
                currentMachine.recentReadings = currentMachine.recentReadings.slice(0, 100);
              }

              // Update total count for THIS machine specifically
              // Each fetch increments machine-specific counter
              const previousCount = currentMachine.totalCount || 0;
              const newDataCount = (data.recent_readings_full || []).length;
              if (newDataCount > 0) {
                currentMachine.totalCount = previousCount + newDataCount;
                // Track message velocity (messages per second)
                if (!currentMachine.lastUpdateTime) {
                  currentMachine.lastUpdateTime = Date.now();
                  currentMachine.lastMessageCount = currentMachine.totalCount;
                } else {
                  const now = Date.now();
                  const timeDelta = (now - currentMachine.lastUpdateTime) / 1000; // seconds
                  if (timeDelta >= 1) { // Update every second
                    const messageDelta = currentMachine.totalCount - currentMachine.lastMessageCount;
                    currentMachine.messageVelocity = messageDelta / timeDelta;
                    currentMachine.lastUpdateTime = now;
                    currentMachine.lastMessageCount = currentMachine.totalCount;
                  }
                }
              }
            }
            // ========== END GUARD ==========

            // Always display count from machine buffer (even when not collecting)
            document.getElementById("totalCount").textContent = currentMachine.totalCount;
            
            // ========== UPDATE 3D RIG TELEMETRY ==========
            // Get latest reading for 3D Rig animation
            if (currentMachine.recentReadings && currentMachine.recentReadings.length > 0) {
              const latestReading = currentMachine.recentReadings[0];
              if (latestReading) {
                currentVibration = latestReading.vibration || 0;
                currentRPM = latestReading.rpm || 0;
                currentTemperature = latestReading.temperature || 0;
              }
            }
            // ========== END 3D RIG TELEMETRY ==========
            
            // Update pipeline health metrics
            updatePipelineHealth();
            // Update telemetry rail
            updateTelemetryRail();
            
            // Update comm status on message receipt
            if (currentMachine) {
              currentMachine.lastMessageTime = Date.now();
              // Flash comm status green
              const commEl = document.getElementById('statusComm');
              if (commEl) {
                commEl.className = 'scada-status-dot-indicator nom';
                commEl.style.boxShadow = '0 0 10px rgba(0, 255, 65, 0.6)';
              }
            }
            
            // Update alarms page if visible
            const alarmsSection = document.getElementById('section-alarms');
            if (alarmsSection && alarmsSection.style.display !== 'none') {
              renderAlarmMatrix();
            }
            
            // Update RUL predictions
            updateRULPredictions();

            // Update Statistics section with category tabs
            if (data.stats_by_category) {
              const statsTabsEl = document.getElementById("statsCategoryTabs");
              const statsContentEl = document.getElementById(
                "statsCategoryContent"
              );

              if (statsTabsEl && !statsTabsEl.hasChildNodes()) {
                // Build tabs for Statistics (only once)
                const categories = Object.keys(data.stats_by_category);
                statsTabsEl.innerHTML = categories
                  .map((cat) => {
                    const catData = data.stats_by_category[cat];
                    const icon = categoryIcons[cat] || "üìä";
                    const isActive =
                      cat === activeStatsCategory ? "active" : "";
                    return `<div class="tab ${isActive}" data-category="${cat}" onclick="switchStatsCategory('${cat}')">${icon} ${catData.name}</div>`;
                  })
                  .join("");
              }

              if (statsContentEl) {
                // Build content for Statistics categories
                const categories = Object.keys(data.stats_by_category);
                statsContentEl.innerHTML = categories
                  .map((cat) => {
                    const catData = data.stats_by_category[cat];
                    const isActive =
                      cat === activeStatsCategory ? "active" : "";

                    // Get sensors in configured order, filtered to enabled, also filter hidden
                    // Include custom sensors from unified registry even if not in stats API yet
                    const orderedSensors = getOrderedEnabledSensors(cat)
                      .filter(name => {
                        if (hiddenSensors.has(name)) return false;
                        // Include if in stats API response OR if it's a custom sensor in unified registry
                        return catData.sensors[name] || (unifiedSensorRegistry[name] && unifiedSensorRegistry[name].source === 'custom' && unifiedSensorRegistry[name].category === cat);
                      });

                    const statsHtml = orderedSensors
                      .map((name) => {
                        // Get info from stats API or fallback to unified registry
                        const info = catData.sensors[name] || {
                          unit: getSensorMetadata(name).unit || '',
                          metadata: {}
                        };
                        const displayName = name
                          .replace(/_/g, " ")
                          .toUpperCase();
                        // ========== USE MACHINE-SPECIFIC AVERAGE ==========
                        const machineAvg = getCurrentMachineAverage(name);
                        const value = machineAvg !== null
                            ? formatNumber(machineAvg)
                            : "--";
                        // Get metadata if available
                        const metadata = info.metadata || {};
                        const location = metadata.location || '';
                        const equipment = metadata.equipment_section || '';
                        const criticality = metadata.criticality || 'medium';
                        const metadataHtml = (location || equipment || criticality) ? `
                                            <div class="sensor-metadata" style="margin-top: 4px;">
                                                ${location ? `<span class="metadata-badge metadata-location">üìç ${location}</span>` : ''}
                                                ${equipment ? `<span class="metadata-badge metadata-equipment">‚öôÔ∏è ${equipment}</span>` : ''}
                                                ${criticality ? `<span class="metadata-badge metadata-criticality ${criticality}">${criticality.toUpperCase()}</span>` : ''}
                                            </div>
                                        ` : '';
                        
                        return `
                                        <div class="stat">
                                            <span class="stat-label">${displayName}</span>
                                            <span class="stat-value">${value}${
                          info.unit ? " " + info.unit : ""
                        }</span>
                                            ${metadataHtml}
                                        </div>
                                    `;
                      })
                      .join("");

                    // Only show "No visible sensors" if there are truly no sensors in this category
                    const hasSensorsInCategory = sensorsByCategory[cat] && sensorsByCategory[cat].length > 0;
                    const noSensorsMessage = hasSensorsInCategory 
                      ? '<div class="stat"><span class="stat-label" style="color: #94a3b8;">All sensors in this category are hidden or disabled</span></div>'
                      : '<div class="stat"><span class="stat-label">No sensors in this category</span></div>';

                    return `
                                    <div class="tab-content ${isActive}" data-category="${cat}">
                                        ${
                                          statsHtml || noSensorsMessage
                                        }
                                    </div>
                                `;
                  })
                  .join("");
              }
            }

            // Update categorized sensor data for All Sensor Parameters section
            if (data.stats_by_category) {
              const tabsEl = document.getElementById("categoryTabs");
              const contentEl = document.getElementById("categoryContent");

              if (tabsEl && !tabsEl.hasChildNodes()) {
                // Build tabs (only once)
                const categories = Object.keys(data.stats_by_category);
                tabsEl.innerHTML = categories
                  .map((cat) => {
                    const catData = data.stats_by_category[cat];
                    const icon = categoryIcons[cat] || "üìä";
                    const isActive = cat === activeCategory ? "active" : "";
                    return `<div class="tab ${isActive}" data-category="${cat}" onclick="switchCategory('${cat}')">${icon} ${catData.name}</div>`;
                  })
                  .join("");
              }

              if (contentEl) {
                // Build content for all categories
                const categories = Object.keys(data.stats_by_category);
                contentEl.innerHTML = categories
                  .map((cat) => {
                    const catData = data.stats_by_category[cat];
                    const isActive = cat === activeCategory ? "active" : "";
                    // Get sensors in configured order, filtered to enabled
                    // Include custom sensors from unified registry even if not in stats API yet
                    const orderedSensors = getOrderedEnabledSensors(cat)
                      .filter(name => {
                        // Include if in stats API response OR if it's a custom sensor in unified registry
                        return catData.sensors[name] || (unifiedSensorRegistry[name] && unifiedSensorRegistry[name].source === 'custom' && unifiedSensorRegistry[name].category === cat);
                      });
                    const sensorsHtml = orderedSensors
                      .map((name) => {
                        // Get info from stats API or fallback to unified registry
                        const info = catData.sensors[name] || {
                          unit: getSensorMetadata(name).unit || '',
                          metadata: {}
                        };
                        const displayName = name
                          .replace(/_/g, " ")
                          .toUpperCase();
                        // ========== USE MACHINE-SPECIFIC AVERAGE ==========
                        const machineAvg = getCurrentMachineAverage(name);
                        const value = machineAvg !== null
                            ? formatNumber(machineAvg)
                            : "--";
                        const isHidden = hiddenSensors.has(name);
                        const hiddenClass = isHidden ? "hidden-sensor" : "";
                        const checkedAttr = isHidden ? "" : "checked";
                        const threshold = getThreshold(name);
                        const defaults = getDefaultThreshold(name);
                        const hasCustomThreshold =
                          customThresholds[name] !== undefined;
                        const thresholdActiveClass = hasCustomThreshold
                          ? "threshold-active"
                          : "";
                        // Get metadata if available
                        const metadata = info.metadata || {};
                        const location = metadata.location || '';
                        const equipment = metadata.equipment_section || '';
                        const criticality = metadata.criticality || 'medium';
                        const metadataHtml = (location || equipment || criticality) ? `
                                            <div class="sensor-metadata">
                                                ${location ? `<span class="metadata-badge metadata-location">üìç ${location}</span>` : ''}
                                                ${equipment ? `<span class="metadata-badge metadata-equipment">‚öôÔ∏è ${equipment}</span>` : ''}
                                                ${criticality ? `<span class="metadata-badge metadata-criticality ${criticality}">${criticality.toUpperCase()}</span>` : ''}
                                            </div>
                                        ` : '';
                        
                        return `
                                        <div class="sensor-item ${hiddenClass} ${thresholdActiveClass}" data-sensor="${name}">
                                            <input type="checkbox" class="sensor-toggle" ${checkedAttr} onchange="toggleSensor('${name}')" title="Toggle visibility">
                                            <div class="sensor-name">${displayName}</div>
                                            <div class="sensor-value">${value}<span class="sensor-unit">${
                          info.unit
                        }</span></div>
                                            ${metadataHtml}
                                            <div class="threshold-toggle" onclick="toggleThreshold('${name}', event)">
                                                ‚öôÔ∏è Set Limits ${
                                                  hasCustomThreshold ? "‚úì" : ""
                                                }
                                            </div>
                                            <div class="threshold-controls" id="threshold-${name}" onclick="event.stopPropagation()">
                                                <div class="threshold-row">
                                                    <div class="threshold-field">
                                                        <span class="threshold-label">Low Limit</span>
                                                        <input type="number" class="threshold-input" id="min-${name}" 
                                                               value="${
                                                                 threshold.min
                                                               }" step="any" 
                                                               placeholder="${
                                                                 defaults.low
                                                               }">
                                                    </div>
                                                    <div class="threshold-field">
                                                        <span class="threshold-label">High Limit</span>
                                                        <input type="number" class="threshold-input" id="max-${name}" 
                                                               value="${
                                                                 threshold.max
                                                               }" step="any"
                                                               placeholder="${
                                                                 defaults.high
                                                               }">
                                                    </div>
                                                </div>
                                                <div class="threshold-buttons">
                                                    <button class="threshold-save-btn" onclick="saveThreshold('${name}', event)">üíæ Save</button>
                                                    <button class="threshold-reset-btn" onclick="resetThreshold('${name}', event)">‚Ü©Ô∏è Reset</button>
                                                </div>
                                                <div class="threshold-default">üìä Safe range: ${
                                                  defaults.low
                                                } ‚Äì ${defaults.high} ${
                          defaults.unit
                        }</div>
                                            </div>
                                        </div>
                                    `;
                      })
                      .join("");

                    return `
                                    <div class="tab-content ${isActive}" data-category="${cat}">
                                        <div class="sensor-grid">${sensorsHtml}</div>
                                    </div>
                                `;
                  })
                  .join("");

                // Restore any expanded threshold controls after re-render
                restoreExpandedThresholds();
              }
            }

            // Render history for selected category - USE MACHINE-SPECIFIC BUFFER
            const machineReadings = currentMachine.recentReadings;
            if (machineReadings && machineReadings.length > 0) {
              const allSensors = sensorsByCategory[selectedHistoryCategory] || [];
              const currentState = machineSensorState[selectedMachineId];
              // Filter out hidden sensors AND disabled sensors for current machine
              const sensors = allSensors.filter(sensor => {
                return !hiddenSensors.has(sensor) &&
                       (currentState[sensor]?.enabled !== false);
              });
              const sensorUnits =
                data.stats_by_category?.[selectedHistoryCategory]?.sensors ||
                {};

              const historyHTML = machineReadings
                .map((reading) => {
                  const metricsHtml = sensors
                    .map((sensor) => {
                      const displayName = sensor
                        .replace(/_/g, " ")
                        .toUpperCase();
                      const value = reading[sensor];
                      const unit = sensorUnits[sensor]?.unit || "";
                      return `
                                        <div class="history-metric">
                                            <div class="metric-value">${formatNumber(
                                              value
                                            )}${
                        unit
                          ? '<span class="sensor-unit">' + unit + "</span>"
                          : ""
                      }</div>
                                            <div class="metric-label">${displayName}</div>
                                        </div>
                                    `;
                    })
                    .join("");

                  return `
                                <div class="history-item">
                                    <div class="history-timestamp">${formatDateTime(
                                      reading.created_at
                                    )}</div>
                                    <div class="history-grid">${metricsHtml}</div>
                                </div>
                            `;
                })
                .join("");
              document.getElementById("readingsHistory").innerHTML =
                historyHTML;
            } else {
              document.getElementById("readingsHistory").innerHTML =
                `<div style="text-align: center; color: #94a3b8; padding: 40px; font-size: 14px; text-transform: uppercase; letter-spacing: 2px;">No data yet for Machine ${selectedMachineId}</div>`;
            }
          });
      }

      function updateStatus() {
        fetch("/api/status")
          .then((r) => r.json())
          .then((data) => {
            // ========== SYNC PRODUCER RUNNING STATE ==========
            // This is the single source of truth for producer state
            producerRunning = data.producer_running === true;

            const producerEl = document.getElementById("producerStatus");
            const consumerEl = document.getElementById("consumerStatus");
            if (producerEl) {
              producerEl.className =
                "status-indicator " +
                (producerRunning ? "status-running" : "status-stopped");
            }
            if (consumerEl) {
              consumerEl.className =
                "status-indicator " +
                (data.consumer_running ? "status-running" : "status-stopped");
            }

            if (data.kafka) {
              const kafkaIndicator = document.getElementById("kafkaStatus");
              const kafkaDetails =
                document.getElementById("kafkaStatusDetails");
              if (kafkaIndicator) {
                let className = "status-indicator ";
                if (data.kafka.status === "healthy") {
                  className += "status-running";
                } else if (data.kafka.status === "unhealthy") {
                  className += "status-stopped";
                }
                kafkaIndicator.className = className;
              }
              if (kafkaDetails) {
                if (data.kafka.status === "healthy") {
                  kafkaDetails.textContent = data.kafka.latency_ms
                    ? `OK (${data.kafka.latency_ms} ms)`
                    : "OK";
                } else if (data.kafka.status === "unhealthy") {
                  kafkaDetails.textContent = data.kafka.error || "Unreachable";
                } else {
                  kafkaDetails.textContent = "Checking...";
                }
              }
            }
            
            // Update SCADA top bar status dots
            updateSystemStatusDots(data);
            
            // Update Kafka modal if open
            const kafkaModal = document.getElementById('kafkaControlsModal');
            if (kafkaModal && kafkaModal.style.display === 'flex') {
              updateKafkaModalStatus();
            }
            
            // Update Controls section status if visible
            updateControlsSectionStatus(data);
            // Update Config section status if visible
            updateConfigSectionStatus(data);
          });
      }
      
      // Update Controls section status indicators
      function updateControlsSectionStatus(statusData) {
        // Producer status
        const producerStatus = document.getElementById('producerStatus');
        const sectionProducerStatus = document.getElementById('sectionProducerStatus');
        const sectionProducerStatusText = document.getElementById('sectionProducerStatusText');
        if (producerStatus && sectionProducerStatus && sectionProducerStatusText) {
          const isRunning = producerStatus.classList.contains('status-running');
          sectionProducerStatus.className = 'scada-status-dot-indicator ' + (isRunning ? 'nom' : '');
          sectionProducerStatusText.textContent = isRunning ? 'RUNNING' : 'STOPPED';
        }
        
        // Consumer status
        const consumerStatus = document.getElementById('consumerStatus');
        const sectionConsumerStatus = document.getElementById('sectionConsumerStatus');
        const sectionConsumerStatusText = document.getElementById('sectionConsumerStatusText');
        if (consumerStatus && sectionConsumerStatus && sectionConsumerStatusText) {
          const isRunning = consumerStatus.classList.contains('status-running');
          sectionConsumerStatus.className = 'scada-status-dot-indicator ' + (isRunning ? 'nom' : '');
          sectionConsumerStatusText.textContent = isRunning ? 'RUNNING' : 'STOPPED';
        }
        
        // Kafka status
        const kafkaStatusDetails = document.getElementById('kafkaStatusDetails');
        const sectionKafkaStatus = document.getElementById('sectionKafkaStatus');
        const sectionKafkaStatusText = document.getElementById('sectionKafkaStatusText');
        if (kafkaStatusDetails && sectionKafkaStatus && sectionKafkaStatusText) {
          const kafkaStatus = document.getElementById('kafkaStatus');
          if (kafkaStatus) {
            const isHealthy = kafkaStatus.classList.contains('status-running');
            sectionKafkaStatus.className = 'scada-status-dot-indicator ' + (isHealthy ? 'nom' : 'err');
            sectionKafkaStatusText.textContent = kafkaStatusDetails.textContent || 'UNKNOWN';
          }
        }
      }
      
      // Update SCADA top bar system status dots
      function updateSystemStatusDots(statusData) {
        // SYSTEM: Overall system health (producer + consumer running)
        const systemEl = document.getElementById('statusSystem');
        if (systemEl) {
          // Check if system is paused (stopped but not reset)
          if (isSystemPaused) {
            // Paused state: Yellow (Paused)
            systemEl.className = 'scada-status-dot-indicator wrn';
            systemEl.style.boxShadow = 'none';
          } else if (statusData.producer_running && statusData.consumer_running) {
            // Both running: Neon Green with glow
            systemEl.className = 'scada-status-dot-indicator nom';
            systemEl.style.boxShadow = '0 0 10px rgba(0, 255, 65, 0.6)';
          } else if (statusData.producer_running || statusData.consumer_running) {
            // One running: Warning Yellow
            systemEl.className = 'scada-status-dot-indicator wrn';
            systemEl.style.boxShadow = 'none';
          } else {
            // Both stopped: Red or Dim Gray
            systemEl.className = 'scada-status-dot-indicator err';
            systemEl.style.boxShadow = 'none';
          }
        }
        
        // COMM: Kafka/communication status (updated on message receipt)
        const commEl = document.getElementById('statusComm');
        if (commEl) {
          // Check if we've received a message recently (within 15 seconds)
          const currentMachine = machineData[selectedMachineId];
          if (currentMachine && currentMachine.lastMessageTime) {
            const timeSinceLastMessage = Date.now() - currentMachine.lastMessageTime;
            if (timeSinceLastMessage < 15000) { // 15 second threshold (increased from 5s)
              commEl.className = 'scada-status-dot-indicator nom';
              commEl.style.boxShadow = '0 0 10px rgba(0, 255, 65, 0.6)';
            } else {
              commEl.className = 'scada-status-dot-indicator err';
              commEl.style.boxShadow = 'none';
            }
          } else if (statusData.kafka) {
            // Fallback to Kafka health status
            if (statusData.kafka.status === 'healthy') {
              commEl.className = 'scada-status-dot-indicator nom';
            } else if (statusData.kafka.status === 'unhealthy') {
              commEl.className = 'scada-status-dot-indicator err';
            } else {
              commEl.className = 'scada-status-dot-indicator';
            }
          }
        }
        
        // POWER: Electrical/power status (based on voltage/current sensors)
        const powerEl = document.getElementById('statusPower');
        if (powerEl) {
          // Default to normal, will be updated based on sensor data
          powerEl.className = 'scada-status-dot-indicator nom';
        }
        
        // SAFETY: Safety interlock status (based on critical anomalies)
        const safetyEl = document.getElementById('statusSafety');
        if (safetyEl) {
          // Default to normal, will be updated based on anomaly data
          safetyEl.className = 'scada-status-dot-indicator nom';
        }
      }
      
      // Update UTC timestamp in top bar
      function updateUTCTimestamp() {
        const utcEl = document.getElementById('scadaUTCTime');
        if (utcEl) {
          const now = new Date();
          const utcTime = now.toISOString().substr(11, 8);
          const utcDate = now.toISOString().substr(0, 10);
          utcEl.textContent = `${utcDate} ${utcTime} UTC`;
        }
      }
      
      // Update alerts badge in top bar
      function updateAlertsBadge() {
        const badge = document.getElementById('scadaAlertsBadge');
        const countEl = document.getElementById('scadaAlertsCount');
        if (badge && countEl) {
          const currentMachine = machineData[selectedMachineId];
          const alertCount = currentMachine ? currentMachine.alerts.length : 0;
          const criticalCount = currentMachine ? currentMachine.alerts.filter(a => 
            a.severity === 'critical' || a.severity === 'error'
          ).length : 0;
          
          countEl.textContent = alertCount;
          if (alertCount === 0) {
            badge.className = 'scada-alerts-badge none';
          } else if (criticalCount > 0) {
            badge.className = 'scada-alerts-badge';
          } else {
            badge.className = 'scada-alerts-badge';
            badge.style.background = 'var(--status-warning)';
          }
        }
      }

      function loadConfig() {
        fetch("/api/config")
          .then((r) => r.json())
          .then((data) => {
            document.getElementById("durationHours").value =
              data.duration_hours ?? 0;
            document.getElementById("durationMinutes").value =
              data.duration_minutes ?? 0;
            document.getElementById("intervalSeconds").value =
              data.interval_seconds ?? 5;
            configLimits = data.limits || null;
            configDefaults = data.defaults || null;
            if (configLimits) {
              const intervalInput = document.getElementById("intervalSeconds");
              intervalInput.min = configLimits.interval_seconds?.min ?? 1;
              intervalInput.max = configLimits.interval_seconds?.max ?? 3600;
            }
            displayConfigMessage("Ready for updates.");
          });
      }

      function displayConfigMessage(message, isError = false) {
        const el = document.getElementById("configMessage");
        if (!el) return;
        el.textContent = message;
        el.style.color = isError ? "#f87171" : "#34d399";
      }

      function updateConfig() {
        const payload = {
          duration_hours: parseInt(
            document.getElementById("durationHours").value,
            10
          ),
          duration_minutes: parseInt(
            document.getElementById("durationMinutes").value,
            10
          ),
          interval_seconds: parseInt(
            document.getElementById("intervalSeconds").value,
            10
          ),
        };

        fetch("/api/config", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        })
          .then((r) => r.json())
          .then((result) => {
            if (result.success) {
              displayConfigMessage("Configuration updated!", false);
              loadConfig();
            } else {
              displayConfigMessage(
                result.error || "Failed to update config",
                true
              );
            }
          })
          .catch(() => displayConfigMessage("Failed to update config", true));
      }

      function resetConfig() {
        fetch("/api/config/reset", { method: "POST" })
          .then((r) => r.json())
          .then((result) => {
            if (result.success) {
              displayConfigMessage("Reset to defaults.", false);
              loadConfig();
            } else {
              displayConfigMessage(
                result.error || "Failed to reset config",
                true
              );
            }
          })
          .catch(() => displayConfigMessage("Failed to reset config", true));
      }

      function exportData(format = 'csv', limit = 500) {
        // Support both old format (limit only) and new format (format, limit)
        if (typeof format === 'number') {
          // Backward compatibility: first arg is limit
          limit = format;
          format = 'csv';
        }
        window.open(`/api/export?format=${format}&limit=${limit}`, "_blank");
      }

      function startComponent(component) {
        fetch(`/api/start/${component}`, {
          method: 'POST'
        })
          .then((r) => r.json())
          .then((result) => {
            if (result.success) {
              // ========== SYNC MACHINE RUNNING STATE ON START ==========
              if (component === 'producer') {
                producerRunning = true;
                // Enable data collection for current machine
                machineRunning[selectedMachineId] = true;
              }
              alert(`‚úÖ ${component} started!`);
            } else {
              alert(`‚ùå Failed: ${result.error}`);
            }
            updateStatus();
          })
          .catch((error) => {
            alert(`‚ùå Failed to start ${component}: ${error.message}`);
          });
      }

      function stopComponent(component) {
        fetch(`/api/stop/${component}`, {
          method: 'POST'
        })
          .then((r) => r.json())
          .then((result) => {
            if (result.success) {
              // ========== SYNC MACHINE RUNNING STATE ON STOP ==========
              if (component === 'producer') {
                producerRunning = false;
                // Disable data collection for ALL machines
                machineRunning['A'] = false;
                machineRunning['B'] = false;
                machineRunning['C'] = false;
              }
              alert(`‚úÖ ${component} stopped!`);
            } else {
              alert(`‚ùå Failed: ${result.error}`);
            }
            updateStatus();
          })
          .catch((error) => {
            alert(`‚ùå Failed to stop ${component}: ${error.message}`);
          });
      }

      function clearData() {
        if (confirm("üóëÔ∏è Clear all sensor data from database?")) {
          fetch("/api/clear_data")
            .then((r) => r.json())
            .then((result) => {
              if (result.success) {
                // ========== RESET ALL MACHINE DATA BUFFERS ==========
                resetAllMachineData();
                // Update UI to show zeros
                document.getElementById("totalCount").textContent = "0";
                document.getElementById("mlTotalAnomalies").textContent = "0";
                document.getElementById("mlAnomalyRate").textContent = "0.0%";
                document.getElementById("mlReportsGenerated").textContent = "0";
                // Re-render from empty cache
                renderFromMachineCache(selectedMachineId);
                alert("‚úÖ Data cleared!");
              } else {
                alert("‚ùå Failed to clear data");
              }
              updateStats();
            });
        }
      }

      function loadAlerts() {
        fetch("/api/alerts?limit=20")
          .then((r) => r.json())
          .then((data) => {
            const container = document.getElementById("alertList");
            if (!container) return;

            // ========== MACHINE DATA ISOLATION ==========
            const currentMachine = machineData[selectedMachineId];

            // ========== GUARD: Only collect data if producer + machine are running ==========
            if (canCollectData()) {
              const allAlerts = data.alerts || [];
              // Filter alerts: only show if they mention enabled sensors for selected machine
              const enabledSensors = getEnabledSensors();
              const filteredAlerts = allAlerts.filter(alert => {
                // Check if alert message mentions any enabled sensor
                const message = (alert.message || '').toLowerCase();
                return enabledSensors.some(sensor =>
                  message.includes(sensor.toLowerCase()) ||
                  message.includes(sensor.replace(/_/g, ' ').toLowerCase())
                ) || enabledSensors.length === 0; // Show all if no sensors enabled (edge case)
              });

              // Store alerts in machine-specific buffer (accumulate unique alerts by ID)
              const existingIds = new Set(currentMachine.alerts.map(a => a.id));
              filteredAlerts.forEach(alert => {
                if (!existingIds.has(alert.id)) {
                  currentMachine.alerts.unshift(alert);
                }
              });
              // Keep only last 50 alerts per machine
              currentMachine.alerts = currentMachine.alerts.slice(0, 50);
            }
            // ========== END GUARD ==========

            // Always render from machine-specific buffer
            const alerts = currentMachine.alerts;
            
            // Update top bar alerts badge
            updateAlertsBadge();
            
            // Render alarm console in bottom panel
            renderAlarmConsole(alerts);

            if (alerts.length === 0) {
              container.innerHTML =
                `<div style="text-align: center; color: #94a3b8; padding: 20px;">No alerts for Machine ${selectedMachineId} yet</div>`;
              return;
            }

            container.innerHTML = alerts
              .map((alert) => {
                const severity = (alert.severity || "info").toLowerCase();
                return `
                            <div class="alert-item">
                                <div>
                                    <div class="alert-type">${
                                      alert.alert_type
                                    }</div>
                                    <div class="alert-message">${
                                      alert.message
                                    }</div>
                                </div>
                                <div class="alert-meta">
                                    <span class="alert-badge ${severity}">${
                  alert.severity
                }</span>
                                    <div class="alert-time">${formatDateTime(
                                      alert.created_at
                                    )}</div>
                                </div>
                            </div>
                        `;
              })
              .join("");
          });
      }

      function setQuickTest() {
        document.getElementById("durationHours").value = 0;
        document.getElementById("durationMinutes").value = 2;
        document.getElementById("intervalSeconds").value = 10;
      }

      function setOneMin() {
        document.getElementById("durationHours").value = 0;
        document.getElementById("durationMinutes").value = 1;
        document.getElementById("intervalSeconds").value = 5;
      }

      function setOneHour() {
        document.getElementById("durationHours").value = 1;
        document.getElementById("durationMinutes").value = 0;
        document.getElementById("intervalSeconds").value = 30;
      }

      function setProduction() {
        document.getElementById("durationHours").value = 24;
        document.getElementById("durationMinutes").value = 0;
        document.getElementById("intervalSeconds").value = 30;
      }

      // ========== Anomaly Injection Functions ==========

      function toggleInjection() {
        const enabled = document.getElementById("injectionEnabled").checked;
        const interval =
          parseInt(document.getElementById("injectionInterval").value) || 30;

        fetch("/api/injection-settings", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ enabled, interval_minutes: interval }),
        })
          .then((r) => r.json())
          .then((data) => {
            updateInjectionStatus(data.settings);
          })
          .catch(console.error);
      }

      function updateInjectionInterval() {
        const interval =
          parseInt(document.getElementById("injectionInterval").value) || 30;
        const enabled = document.getElementById("injectionEnabled").checked;

        fetch("/api/injection-settings", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ enabled, interval_minutes: interval }),
        })
          .then((r) => r.json())
          .then((data) => {
            updateInjectionStatus(data.settings);
          })
          .catch(console.error);
      }

      function injectAnomalyNow(button) {
        if (button) {
          button.disabled = true;
          button.innerHTML = 'INJECTING...';
        }

        fetch("/api/inject-anomaly", { method: "POST" })
          .then((r) => r.json())
          .then((data) => {
            if (data.success && button) {
              button.innerHTML = "INJECTED";
              setTimeout(() => {
                if (button) {
                  button.innerHTML = "INJECT ANOMALY NOW";
                  button.disabled = false;
                }
              }, 2000);
            } else if (button) {
              button.innerHTML = "FAILED";
              button.disabled = false;
            }
          })
          .catch((err) => {
            if (button) {
              button.innerHTML = "FAILED";
              button.disabled = false;
            }
            button.disabled = false;
            setTimeout(() => {
              button.innerHTML = "‚ö° Inject Anomaly NOW";
            }, 2000);
          });
      }

      function updateInjectionStatus(settings) {
        const statusEl = document.getElementById("injectionStatus");
        if (!statusEl) return;

        if (settings && settings.enabled) {
          const nextTime = settings.next_injection_time
            ? new Date(settings.next_injection_time).toLocaleTimeString()
            : "calculating...";
          statusEl.innerHTML = `<span style="color: #f87171;">‚óè</span> Injection ENABLED - Every ${settings.interval_minutes} min. Next: ${nextTime}`;
          statusEl.style.borderColor = "rgba(239, 68, 68, 0.5)";
        } else {
          statusEl.innerHTML =
            "Injection disabled. Enable to schedule automatic anomalies.";
          statusEl.style.borderColor = "transparent";
        }
      }

      function loadInjectionSettings() {
        fetch("/api/injection-settings")
          .then((r) => r.json())
          .then((data) => {
            document.getElementById("injectionEnabled").checked = data.enabled;
            document.getElementById("injectionInterval").value =
              data.interval_minutes || 30;
            updateInjectionStatus(data);
          })
          .catch(console.error);
      }

      // ========== LSTM Prediction Functions ==========

      function loadLSTMStatus() {
        fetch("/api/lstm-status")
          .then((r) => r.json())
          .then((data) => {
            if (!data.available) {
              document.getElementById("lstmQualityText").textContent = "Not Available";
              document.getElementById("lstmStatusMessage").textContent = data.message || "LSTM not available";
              document.getElementById("lstmQualityBar").style.width = "0%";
              return;
            }

            if (!data.trained) {
              document.getElementById("lstmQualityText").textContent = "Not Trained";
              document.getElementById("lstmStatusMessage").textContent = data.message || "Model not trained";
              document.getElementById("lstmQualityBar").style.width = "0%";
              return;
            }

            // Update quality bar
            const quality = data.quality_score || 0;
            document.getElementById("lstmQualityPercent").textContent = quality.toFixed(0) + "%";
            document.getElementById("lstmQualityBar").style.width = quality + "%";
            document.getElementById("lstmQualityText").textContent = quality.toFixed(0) + "%";
            document.getElementById("lstmStatusMessage").textContent = data.message || "Model trained";

            // Color based on quality
            const bar = document.getElementById("lstmQualityBar");
            if (quality >= 80) {
              bar.style.background = "linear-gradient(90deg, #10b981, #059669)";
            } else if (quality >= 60) {
              bar.style.background = "linear-gradient(90deg, #f59e0b, #10b981)";
            } else {
              bar.style.background = "linear-gradient(90deg, #ef4444, #f59e0b)";
            }
          })
          .catch(console.error);
      }

      function loadLSTMPredictions() {
        fetch("/api/lstm-predictions")
          .then((r) => r.json())
          .then((data) => {
            // ========== MACHINE DATA ISOLATION ==========
            const currentMachine = machineData[selectedMachineId];

            if (!data.available || !data.trained) {
              // Store null prediction for this machine (only if collecting)
              if (canCollectData()) {
                currentMachine.lstmPredictions = null;
              }
              document.getElementById("lstmRiskScore").textContent = "N/A";
              document.getElementById("lstmConfidence").textContent = "N/A";
              document.getElementById("lstmPredictedWindow").textContent = "LSTM not trained";
              document.getElementById("lstmTrend").textContent = "N/A";
              document.getElementById("lstmSensors").textContent = "N/A";
              return;
            }

            const pred = data.current_prediction;

            // ========== GUARD: Only store prediction if producer + machine are running ==========
            if (canCollectData()) {
              // Store prediction in machine-specific buffer
              currentMachine.lstmPredictions = JSON.parse(JSON.stringify(pred));
            }
            // ========== END GUARD ==========

            // Risk score with color
            const riskScore = pred.risk_score || 0;
            const riskEl = document.getElementById("lstmRiskScore");
            riskEl.textContent = riskScore.toFixed(1) + "%";

            if (riskScore >= 70) {
              riskEl.style.color = "#ef4444";
            } else if (riskScore >= 40) {
              riskEl.style.color = "#f59e0b";
            } else {
              riskEl.style.color = "#10b981";
            }

            // Confidence
            const confidence = pred.confidence || 0;
            document.getElementById("lstmConfidence").textContent = (confidence * 100).toFixed(0) + "%";

            // Predicted window
            document.getElementById("lstmPredictedWindow").textContent = pred.predicted_window || "N/A";

            // Trend with emoji
            const trend = pred.trend || "unknown";
            let trendText = trend;
            if (trend === "increasing") {
              trendText = "üìà Increasing (Risk Rising)";
            } else if (trend === "decreasing") {
              trendText = "üìâ Decreasing (Risk Falling)";
            } else if (trend === "stable") {
              trendText = "‚û°Ô∏è Stable";
            }
            document.getElementById("lstmTrend").textContent = trendText;

            // Contributing sensors - filter and order based on machineParameterConfig
            const allSensors = pred.contributing_sensors || [];
            const sensors = filterAndOrderSensors(allSensors);
            if (sensors.length > 0) {
              document.getElementById("lstmSensors").textContent = sensors.slice(0, 5).join(", ");
            } else {
              document.getElementById("lstmSensors").textContent = "None identified for Machine " + selectedMachineId;
            }

            // Display detailed sensor analysis - filter and order based on config
            const allSensorAnalyses = pred.sensor_analyses || [];
            const enabledSensorNames = new Set(getOrderedEnabledSensors());
            const sensorAnalyses = allSensorAnalyses.filter(analysis =>
              enabledSensorNames.has(analysis.sensor)
            );
            const analysisContainer = document.getElementById("lstmSensorAnalysisContainer");
            const analysisList = document.getElementById("lstmSensorAnalysisList");

            if (sensorAnalyses.length > 0) {
              analysisContainer.style.display = "block";
              analysisList.innerHTML = "";

              // Show top 5 most problematic sensors
              sensorAnalyses.slice(0, 5).forEach((sensor) => {
                const severityColors = {
                  'critical': '#ef4444',
                  'high': '#f59e0b',
                  'medium': '#eab308',
                  'low': '#10b981'
                };
                const severityEmojis = {
                  'critical': 'üî¥',
                  'high': 'üü†',
                  'medium': 'üü°',
                  'low': 'üü¢'
                };

                const item = document.createElement("div");
                item.style.cssText = `
                  background: rgba(30, 41, 59, 0.5);
                  border-left: 3px solid ${severityColors[sensor.severity] || '#64748b'};
                  padding: 12px;
                  border-radius: 6px;
                `;

                const sensorName = document.createElement("div");
                sensorName.style.cssText = "font-weight: 600; color: #e2e8f0; margin-bottom: 6px; font-size: 14px;";
                sensorName.textContent = `${severityEmojis[sensor.severity] || '‚ö™'} ${sensor.sensor} (${sensor.severity.toUpperCase()})`;
                item.appendChild(sensorName);

                const reason = document.createElement("div");
                reason.style.cssText = "font-size: 12px; color: #cbd5e1; margin-bottom: 4px; line-height: 1.4;";
                reason.textContent = sensor.reason;
                item.appendChild(reason);

                if (sensor.predicted_failure_reading) {
                  const failure = document.createElement("div");
                  failure.style.cssText = "font-size: 11px; color: #f59e0b; margin-top: 4px;";
                  failure.textContent = `‚ö†Ô∏è Predicted failure at reading: ${sensor.predicted_failure_reading}`;
                  item.appendChild(failure);
                }

                const trendInfo = document.createElement("div");
                trendInfo.style.cssText = "font-size: 11px; color: #94a3b8; margin-top: 4px;";
                const trendEmoji = sensor.trend === 'increasing' ? 'üìà' : sensor.trend === 'decreasing' ? 'üìâ' : '‚û°Ô∏è';
                trendInfo.textContent = `${trendEmoji} Trend: ${sensor.trend} (${sensor.trend_rate > 0 ? '+' : ''}${sensor.trend_rate.toFixed(2)} per reading) | Current: ${sensor.current_value.toFixed(2)}`;
                item.appendChild(trendInfo);

                analysisList.appendChild(item);
              });
            } else {
              analysisContainer.style.display = "none";
            }
          })
          .catch(console.error);
      }

      function generateFutureReport(button) {
        button.disabled = true;
        button.innerHTML = '<span class="loading-spinner" style="width: 16px; height: 16px;"></span> Generating...';

        fetch("/api/generate-future-report", { method: "POST" })
          .then((r) => {
            if (!r.ok) throw new Error("Failed to generate report");
            return r.blob();
          })
          .then((blob) => {
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `future_anomaly_report_${new Date().toISOString().split('T')[0]}.pdf`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);

            button.innerHTML = '<span>‚úì</span><span>Report Downloaded!</span>';
            button.style.background = "linear-gradient(135deg, #10b981, #059669)";
            setTimeout(() => {
              button.innerHTML = '<span>üìä</span><span>Generate Future Anomaly Report (PDF)</span>';
              button.style.background = "linear-gradient(135deg, #8b5cf6, #7c3aed)";
              button.disabled = false;
            }, 3000);
          })
          .catch((err) => {
            console.error(err);
            button.innerHTML = '<span>‚úó</span><span>Failed</span>';
            button.style.background = "linear-gradient(135deg, #ef4444, #dc2626)";
            setTimeout(() => {
              button.innerHTML = '<span>üìä</span><span>Generate Future Anomaly Report (PDF)</span>';
              button.style.background = "linear-gradient(135deg, #8b5cf6, #7c3aed)";
              button.disabled = false;
            }, 3000);
          });
      }

      // ========== ML Anomaly Detection Functions ==========

      function loadMLStats() {
        fetch("/api/ml-stats")
          .then((r) => r.json())
          .then((data) => {
            if (data.error) return;

            // ========== MACHINE DATA ISOLATION ==========
            const currentMachine = machineData[selectedMachineId];

            // ========== GUARD: Only update stats if producer + machine are running ==========
            if (canCollectData()) {
              // Use machine-specific anomaly buffer for stats calculation
              const machineAnomalies = currentMachine.anomalies || [];

              // Calculate machine-specific stats from buffer
              const totalAnomalies = machineAnomalies.length;

              // Calculate rate based on machine anomalies
              const recentAnomalies = machineAnomalies.filter(a => {
                const age = Date.now() - new Date(a.created_at).getTime();
                return age < 3600000; // Last hour
              }).length;
              const enabledSensors = getEnabledSensors();
              const enabledCount = enabledSensors.length;
              const recentRate = enabledCount > 0 ? (recentAnomalies / Math.max(1, enabledCount)) * 10 : 0;

              // Store in machine-specific buffer
              currentMachine.mlStats = {
                totalAnomalies: totalAnomalies,
                anomalyRate: recentRate,
                reportsGenerated: data.completed_reports || 0
              };
            }
            // ========== END GUARD ==========

            // Always render from machine buffer
            document.getElementById("mlTotalAnomalies").textContent = currentMachine.mlStats.totalAnomalies;
            document.getElementById("mlAnomalyRate").textContent = currentMachine.mlStats.anomalyRate.toFixed(1) + "%";
            document.getElementById("mlReportsGenerated").textContent = currentMachine.mlStats.reportsGenerated;
          })
          .catch(() => {});
      }

      function loadAnomalies() {
        fetch("/api/anomalies?limit=20&only_anomalies=true")
          .then((r) => r.json())
          .then((data) => {
            const container = document.getElementById("anomalyList");
            if (!container) return;

            // ========== MACHINE DATA ISOLATION ==========
            const currentMachine = machineData[selectedMachineId];

            // ========== GUARD: Only collect data if producer + machine are running ==========
            if (canCollectData()) {
              const allAnomalies = data.anomalies || [];
              // Filter to only show anomalies involving enabled sensors for selected machine
              const filteredAnomalies = allAnomalies.filter(anomaly =>
                anomalyInvolvesEnabledSensors(anomaly)
              );

              // Store anomalies in machine-specific buffer (accumulate unique by ID)
              const existingIds = new Set(currentMachine.anomalies.map(a => a.id));
              filteredAnomalies.forEach(anomaly => {
                if (!existingIds.has(anomaly.id)) {
                  currentMachine.anomalies.unshift(anomaly);
                }
              });
              // Keep only last 50 anomalies per machine
              currentMachine.anomalies = currentMachine.anomalies.slice(0, 50);
            }
            // ========== END GUARD ==========

            // Always render from machine-specific buffer
            const anomalies = currentMachine.anomalies;

            if (anomalies.length === 0) {
              container.innerHTML = `
                            <div style="text-align: center; color: #94a3b8; padding: 40px;">
                                No ML anomalies detected for Machine ${selectedMachineId} yet. Start the pipeline to begin monitoring.
                            </div>
                        `;
              return;
            }

            container.innerHTML = anomalies
              .map((anomaly) => {
                // Filter and order detected sensors based on machineParameterConfig
                const allSensors = anomaly.detected_sensors || [];
                const sensors = filterAndOrderSensors(allSensors);
                const sensorTags = sensors
                  .slice(0, 5)
                  .map((s) => `<span>${s.replace(/_/g, " ")}</span>`)
                  .join("");
                const moreSensors =
                  sensors.length > 5
                    ? `<span>+${sensors.length - 5} more</span>`
                    : "";

                let actionBtn = "";
                if (
                  anomaly.report_id &&
                  anomaly.report_status === "completed"
                ) {
                  actionBtn = `
                                <button class="btn-report btn-view-report" onclick="viewReport(${anomaly.report_id})">
                                    üìÑ View Report
                                </button>
                            `;
                } else if (anomaly.report_status === "generating") {
                  actionBtn = `
                                <button class="btn-report" disabled>
                                    <span class="loading-spinner"></span> Generating...
                                </button>
                            `;
                } else {
                  actionBtn = `
                                <button class="btn-report" onclick="generateReport(${anomaly.id}, this)">
                                    ü§ñ Generate Report
                                </button>
                            `;
                }

                return `
                            <div class="anomaly-item">
                                <div class="anomaly-info">
                                    <div class="anomaly-header">
                                        <span class="anomaly-score">Score: ${anomaly.anomaly_score.toFixed(
                                          4
                                        )}</span>
                                        <span class="anomaly-method">${
                                          anomaly.detection_method
                                        }</span>
                                    </div>
                                    <div class="anomaly-timestamp">${formatDateTime(
                                      anomaly.created_at
                                    )}</div>
                                    <div class="anomaly-sensors">
                                        <strong>Contributing sensors:</strong><br>
                                        ${sensorTags}${moreSensors}
                                    </div>
                                </div>
                                <div class="anomaly-actions">
                                    ${actionBtn}
                                </div>
                            </div>
                        `;
              })
              .join("");
          })
          .catch(() => {});
      }

      function generateReport(anomalyId, button) {
        if (button) {
          button.disabled = true;
          button.innerHTML =
            '<span class="loading-spinner"></span> Generating...';
        }

        fetch(`/api/generate-report/${anomalyId}`, { method: "POST" })
          .then((r) => r.json())
          .then((result) => {
            if (result.success) {
              alert("‚úÖ Report generated successfully!");
              loadAnomalies();
              loadMLStats();
              viewReport(result.report_id);
            } else {
              alert(
                "‚ùå Failed to generate report: " +
                  (result.error || "Unknown error")
              );
              if (button) {
                button.disabled = false;
                button.innerHTML = "ü§ñ Generate Report";
              }
            }
          })
          .catch((err) => {
            alert("‚ùå Error generating report");
            if (button) {
              button.disabled = false;
              button.innerHTML = "ü§ñ Generate Report";
            }
          });
      }

      // Store current report for download
      let currentReport = null;

      function viewReport(reportId) {
        const modal = document.getElementById("reportModal");
        const content = document.getElementById("reportContent");
        const downloadBtn = document.getElementById("downloadReportBtn");

        modal.style.display = "flex";
        downloadBtn.style.display = "none"; // Hide until loaded
        content.innerHTML =
          '<div style="text-align: center; padding: 40px;"><span class="loading-spinner" style="width: 40px; height: 40px; border-width: 3px;"></span><p style="margin-top: 16px;">Loading report...</p></div>';

        fetch(`/api/reports/${reportId}`)
          .then((r) => r.json())
          .then((report) => {
            if (report.error) {
              content.innerHTML = `<div style="color: #ef4444; text-align: center; padding: 40px;">${report.error}</div>`;
              return;
            }

            // Store report for download
            currentReport = report;
            downloadBtn.style.display = "inline-flex"; // Show download button

            // Format the report
            const analysis = report.chatgpt_analysis || "No analysis available";

            content.innerHTML = `
                        <div class="report-meta">
                            <div class="report-meta-item">
                                <div class="report-meta-label">Report ID</div>
                                <div class="report-meta-value">#${
                                  report.id
                                }</div>
                            </div>
                            <div class="report-meta-item">
                                <div class="report-meta-label">Anomaly ID</div>
                                <div class="report-meta-value">#${
                                  report.anomaly_id
                                }</div>
                            </div>
                            <div class="report-meta-item">
                                <div class="report-meta-label">Generated</div>
                                <div class="report-meta-value">${formatDateTime(
                                  report.completed_at || report.created_at
                                )}</div>
                            </div>
                            <div class="report-meta-item">
                                <div class="report-meta-label">Status</div>
                                <div class="report-meta-value" style="color: ${
                                  report.status === "completed"
                                    ? "#10b981"
                                    : "#f59e0b"
                                }">${report.status.toUpperCase()}</div>
                            </div>
                        </div>
                        <div class="report-analysis">
                            ${formatMarkdown(analysis)}
                        </div>
                    `;
          })
          .catch((err) => {
            content.innerHTML = `<div style="color: #ef4444; text-align: center; padding: 40px;">Failed to load report</div>`;
          });
      }

      function downloadCurrentReport() {
        if (!currentReport) {
          alert("No report loaded to download");
          return;
        }

        const report = currentReport;
        
        // Show loading indicator
        const downloadBtn = document.getElementById("downloadReportBtn");
        const originalText = downloadBtn.innerHTML;
        downloadBtn.disabled = true;
        downloadBtn.innerHTML = "‚è≥ Generating PDF...";
        
        // Call the server-side PDF generation endpoint
        fetch(`/api/reports/${report.id}/pdf`)
          .then(response => {
            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.blob();
          })
          .then(blob => {
            // Create a download link
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = `anomaly_report_${report.id}_${new Date().toISOString().slice(0, 10)}.pdf`;
            document.body.appendChild(a);
            a.click();
            
            // Cleanup
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
            
            downloadBtn.disabled = false;
            downloadBtn.innerHTML = originalText;
          })
          .catch(err => {
            console.error('PDF download error:', err);
            alert('Error downloading PDF: ' + err.message);
            downloadBtn.disabled = false;
            downloadBtn.innerHTML = originalText;
          });
      }

      function closeReportModal() {
        document.getElementById("reportModal").style.display = "none";
      }

      function closeFullReportModal() {
        document.getElementById("fullReportModal").style.display = "none";
      }

      function generateFullSessionReport(button) {
        // Show modal immediately with loading state
        document.getElementById("fullReportModal").style.display = "flex";
        const content = document.getElementById("fullReportContent");
        content.innerHTML = `
                <div style="text-align: center; padding: 60px;">
                    <div class="loading-spinner" style="width: 48px; height: 48px; margin: 0 auto 20px;"></div>
                    <p style="color: #94a3b8; font-size: 16px;">Analyzing all anomalies with AI...</p>
                    <p style="color: #64748b; font-size: 14px;">This may take 30-60 seconds for comprehensive analysis.</p>
                </div>
            `;

        // Disable button
        if (button) {
          button.disabled = true;
          button.innerHTML =
            '<span class="loading-spinner" style="width: 16px; height: 16px;"></span> Generating...';
        }

        fetch("/api/generate-full-report", { method: "POST" })
          .then((r) => r.json())
          .then((result) => {
            if (result.success) {
              displayFullSessionReport(result);
            } else {
              content.innerHTML = `
                            <div style="text-align: center; padding: 40px; color: #ef4444;">
                                <h3>Failed to Generate Report</h3>
                                <p>${
                                  result.error || "Unknown error occurred"
                                }</p>
                            </div>
                        `;
            }
          })
          .catch((err) => {
            content.innerHTML = `
                        <div style="text-align: center; padding: 40px; color: #ef4444;">
                            <h3>Connection Error</h3>
                            <p>${err.message}</p>
                        </div>
                    `;
          })
          .finally(() => {
            if (button) {
              button.disabled = false;
              button.innerHTML = "üìä Generate Full Session Report";
            }
          });
      }

      function displayFullSessionReport(result) {
        const content = document.getElementById("fullReportContent");
        const stats = result.stats || {};
        const corrs = result.correlations || {};

        let html = `
                
                <div style="background: rgba(96, 165, 250, 0.1); border: 1px solid rgba(96, 165, 250, 0.3); border-radius: 8px; padding: 12px; margin-bottom: 20px; text-align: center;">
                    <p style="color: #60a5fa; font-weight: 600; font-size: 14px; margin: 0;">
                        üìä Report for Machine ${selectedMachineId} (Filtered by enabled sensors)
                    </p>
                </div>
                
                <div class="report-actions">
                    <button class="btn-download-pdf" onclick="downloadReportAsPDF()">
                        üìÑ Download PDF Report
                    </button>
                    <p style="color: #64748b; font-size: 14px; margin: auto 0;">Generated: ${
                      result.generated_at || new Date().toISOString()
                    }</p>
                </div>
                
                <div class="report-stats-grid">
                    <div class="report-stat-box">
                        <div class="report-stat-value">${(
                          stats.total_readings || 0
                        ).toLocaleString()}</div>
                        <div class="report-stat-label">Total Readings</div>
                    </div>
                    <div class="report-stat-box">
                        <div class="report-stat-value" style="color: #ef4444;">${
                          stats.total_anomalies || 0
                        }</div>
                        <div class="report-stat-label">Anomalies</div>
                    </div>
                    <div class="report-stat-box">
                        <div class="report-stat-value">${
                          stats.anomaly_rate || 0
                        }%</div>
                        <div class="report-stat-label">Anomaly Rate</div>
                    </div>
                    <div class="report-stat-box">
                        <div class="report-stat-value severity-critical">${
                          stats.severity_distribution?.critical || 0
                        }</div>
                        <div class="report-stat-label">Critical</div>
                    </div>
                    <div class="report-stat-box">
                        <div class="report-stat-value severity-high">${
                          stats.severity_distribution?.high || 0
                        }</div>
                        <div class="report-stat-label">High</div>
                    </div>
                    <div class="report-stat-box">
                        <div class="report-stat-value severity-medium">${
                          stats.severity_distribution?.medium || 0
                        }</div>
                        <div class="report-stat-label">Medium</div>
                    </div>
                    <div class="report-stat-box">
                        <div class="report-stat-value severity-low">${
                          stats.severity_distribution?.low || 0
                        }</div>
                        <div class="report-stat-label">Low</div>
                    </div>
                </div>
            `;

        // Top sensors
        if (stats.top_anomaly_sensors && stats.top_anomaly_sensors.length > 0) {
          html += `<h3 style="color: #e2e8f0; margin-bottom: 12px;">üéØ Top Anomaly-Contributing Sensors</h3>
                         <div style="margin-bottom: 24px;">`;
          stats.top_anomaly_sensors.forEach((s) => {
            html += `<span class="sensor-tag">${s.sensor}: ${s.count}x</span>`;
          });
          html += `</div>`;
        }

        // Sensor Co-occurrences
        const cooccurrences = corrs.sensor_co_occurrences || [];
        if (cooccurrences.length > 0) {
          html += `<h3 style="color: #e2e8f0; margin-bottom: 12px;">üîó Sensor Co-occurrences</h3>
                   <p style="color: #94a3b8; font-size: 13px; margin-bottom: 16px;">
                       Sensors that frequently trigger anomalies together - may indicate related system issues
                   </p>
                   <div style="margin-bottom: 24px;">`;
          cooccurrences.slice(0, 10).forEach((c) => {
            const sensors = c.sensors || [];
            html += `<div class="cooccurrence-item">
                        <div class="cooccurrence-sensors">
                            <span class="cooccurrence-sensor">${
                              sensors[0] || "Unknown"
                            }</span>
                            <span class="cooccurrence-arrow">‚Üî</span>
                            <span class="cooccurrence-sensor">${
                              sensors[1] || "Unknown"
                            }</span>
                        </div>
                        <span class="cooccurrence-count">${
                          c.count
                        }x together</span>
                     </div>`;
          });
          html += `</div>`;
        }

        // AI Analysis
        html += `<h3 style="color: #e2e8f0; margin-bottom: 12px;">ü§ñ AI Analysis</h3>
                     <div class="analysis-content">
                         ${formatMarkdown(
                           result.analysis || "No analysis available."
                         )}
                     </div>`;

        // Store for PDF export
        window.currentFullReport = { result, stats, corrs };

        content.innerHTML = html;
      }

      // PDF Download function
      function downloadReportAsPDF() {
        const report = window.currentFullReport;
        if (!report) {
          alert("No report data available");
          return;
        }

        const { result, stats, corrs } = report;
        const cooccurrences = corrs.sensor_co_occurrences || [];

        // Build text content for PDF
        let textContent = `SENSOR DATA PIPELINE - FULL SESSION ANALYSIS REPORT
${"=".repeat(60)}

Generated: ${result.generated_at || new Date().toISOString()}

SESSION STATISTICS
${"-".repeat(40)}
Total Readings:    ${(stats.total_readings || 0).toLocaleString()}
Total Anomalies:   ${stats.total_anomalies || 0}
Anomaly Rate:      ${stats.anomaly_rate || 0}%

SEVERITY DISTRIBUTION
${"-".repeat(40)}
Critical:  ${stats.severity_distribution?.critical || 0}
High:      ${stats.severity_distribution?.high || 0}
Medium:    ${stats.severity_distribution?.medium || 0}
Low:       ${stats.severity_distribution?.low || 0}

TOP ANOMALY-CONTRIBUTING SENSORS
${"-".repeat(40)}
`;

        if (stats.top_anomaly_sensors && stats.top_anomaly_sensors.length > 0) {
          stats.top_anomaly_sensors.forEach((s, i) => {
            textContent += `${i + 1}. ${s.sensor}: ${s.count} occurrences\n`;
          });
        } else {
          textContent += "No sensor data available\n";
        }

        textContent += `
SENSOR CO-OCCURRENCES
${"-".repeat(40)}
`;
        if (cooccurrences.length > 0) {
          cooccurrences.slice(0, 15).forEach((c, i) => {
            const sensors = c.sensors || [];
            textContent += `${i + 1}. ${sensors[0]} <-> ${sensors[1]}: ${
              c.count
            } times together\n`;
          });
        } else {
          textContent += "No co-occurrence data available\n";
        }

        textContent += `
AI ANALYSIS
${"-".repeat(40)}
${result.analysis || "No analysis available"}

${"=".repeat(60)}
Report generated by Sensor Data Pipeline Dashboard
`;

        // Create and download as text file (works without external libraries)
        const blob = new Blob([textContent], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `sensor_report_${new Date()
          .toISOString()
          .slice(0, 10)}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      // ============================================
      // HEALTH CARD MODAL - Progressive Disclosure
      // ============================================
      
      function openHealthCardModal(categoryKey, categoryName) {
        const modal = document.getElementById('healthCardModal');
        const title = document.getElementById('healthModalTitle');
        const content = document.getElementById('healthModalContent');
        
        if (!modal || !title || !content) return;
        
        title.textContent = categoryName.toUpperCase() + ' DETAILS';
        
        // Get sensor data for this category
        const currentMachine = machineData[selectedMachineId];
        const statsData = currentMachine.statsData;
        
        if (!statsData || !statsData.stats_by_category || !statsData.stats_by_category[categoryKey]) {
          content.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 40px;">No data available for this category.</div>';
          modal.style.display = 'flex';
          return;
        }
        
        const categoryData = statsData.stats_by_category[categoryKey];
        const sensors = Object.keys(categoryData.sensors || {});
        
        if (sensors.length === 0) {
          content.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 40px;">No sensors in this category.</div>';
          modal.style.display = 'flex';
          return;
        }
        
        // Render sensor list
        let html = '<div style="display: grid; gap: var(--space-md);">';
        
        sensors.forEach(sensorName => {
          const sensorData = categoryData.sensors[sensorName];
          const currentValue = sensorData.current;
          const unit = sensorData.unit || '';
          const threshold = getThreshold(sensorName);
          const isViolation = currentValue !== null && currentValue !== undefined && 
                             (currentValue < threshold.min || currentValue > threshold.max);
          const statusClass = isViolation ? (currentValue < threshold.min * 0.8 || currentValue > threshold.max * 1.2 ? 'crit' : 'wrn') : '';
          
          html += `
            <div style="padding: var(--space-md); background: var(--bg-tertiary); border: 1px solid var(--border-subtle); border-radius: 4px;">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-sm);">
                <div style="font-family: var(--font-mono); font-size: 12px; font-weight: 600; color: var(--text-primary); text-transform: uppercase;">
                  ${sensorName.replace(/_/g, ' ')}
                </div>
                <div style="font-family: var(--font-mono); font-size: 18px; font-weight: 600; color: ${statusClass === 'crit' ? 'var(--status-error)' : statusClass === 'wrn' ? 'var(--status-warning)' : 'var(--text-primary)'};">
                  ${formatNumber(currentValue, 2)} ${unit}
                </div>
              </div>
              <div style="font-size: 10px; color: var(--text-muted); font-family: var(--font-mono);">
                Threshold: ${formatNumber(threshold.min, 2)} - ${formatNumber(threshold.max, 2)} ${unit}
              </div>
            </div>
          `;
        });
        
        html += '</div>';
        content.innerHTML = html;
        modal.style.display = 'flex';
      }
      
      function closeHealthCardModal() {
        const modal = document.getElementById('healthCardModal');
        if (modal) {
          modal.style.display = 'none';
        }
      }
      
      // ============================================
      // ADMIN SIDEBAR - Progressive Disclosure
      // ============================================
      
      function toggleAdminSidebar() {
        const sidebar = document.getElementById('adminSidebar');
        if (sidebar) {
          sidebar.classList.toggle('open');
        }
      }
      
      function initializeAdminSidebar() {
        // Move admin panel content to configuration section
        const adminPanel = document.getElementById('adminPanel');
        const configContent = document.getElementById('sectionConfigContent');
        
        if (adminPanel && configContent) {
          // Clone admin panel content to config section
          configContent.innerHTML = adminPanel.innerHTML;
        }
        
        // Show admin-only sidebar icons
        if (currentUser && currentUser.role === 'admin') {
          const adminIcons = ['sidebarConfigIcon', 'sidebarAnalyticsIcon', 'sidebarInjectionIcon', 'sidebarUsersIcon'];
          adminIcons.forEach(iconId => {
            const icon = document.getElementById(iconId);
            if (icon) {
              icon.style.display = 'flex';
            }
          });
        }
      }
      
      // ============================================
      // KAFKA CONTROLS MODAL
      // ============================================
      
      function toggleKafkaControls() {
        const modal = document.getElementById('kafkaControlsModal');
        if (modal) {
          modal.style.display = modal.style.display === 'none' ? 'flex' : 'none';
          if (modal.style.display === 'flex') {
            updateKafkaModalStatus();
          }
        }
      }
      
      function closeKafkaControlsModal() {
        const modal = document.getElementById('kafkaControlsModal');
        if (modal) {
          modal.style.display = 'none';
        }
      }
      
      // ============================================
      // GLOBAL MACHINE START/STOP
      // ============================================
      
      function globalStartMachine() {
        console.log('üöÄ START button clicked');
        if (!selectedMachineId) {
          alert('Please select a machine first');
          return;
        }
        console.log(`üìã Starting machine: ${selectedMachineId}`);
        
        // Resume or start uptime tracking
        if (isSystemPaused && systemStartTime) {
          // Resuming from pause - add accumulated time
          accumulatedUptime += (systemPausedTime - systemStartTime);
          systemStartTime = Date.now();
          systemPausedTime = null;
          isSystemPaused = false;
        } else if (!systemStartTime) {
          // Starting fresh
          systemStartTime = Date.now();
          accumulatedUptime = 0;
          isSystemPaused = false;
        }
        
        // Start producer first (required for data flow)
        console.log('‚è≥ Calling /api/start/producer...');
        fetch(`/api/start/producer`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        })
          .then(r => {
            console.log('üì• Producer response status:', r.status);
            return r.json();
          })
          .then(result => {
            console.log('‚úÖ Producer response:', result);
            if (result.success) {
              producerRunning = true;
              // Then set machine running state
              console.log(`‚è≥ Calling /api/machines/${selectedMachineId}/start...`);
              return fetch(`/api/machines/${selectedMachineId}/start`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' }
              });
            } else {
              throw new Error(result.error || 'Failed to start producer');
            }
          })
          .then(r => {
            console.log('üì• Machine start response status:', r.status);
            return r.json();
          })
          .then(result => {
            console.log('‚úÖ Machine start response:', result);
            if (result.success) {
              machineRunning[selectedMachineId] = true;
              updateStatus();
              // Add active state to Start button
              const startBtn = document.getElementById('btn-start');
              if (startBtn) startBtn.classList.add('active');
              // Log operator action
              logOperatorAction(`Started Machine ${selectedMachineId}`, selectedMachineId);
              // Refresh health matrix to show updated uptime
              updateStats();
              console.log('‚ú® Machine started successfully!');
            } else {
              alert(`Failed to start machine: ${result.error || 'Unknown error'}`);
            }
          })
          .catch(error => {
            console.error('‚ùå START Error:', error);
            alert(`Failed to start machine: ${error.message}`);
          });
      }
      
      function globalStopMachine() {
        if (!selectedMachineId) {
          alert('Please select a machine first');
          return;
        }
        
        // Update UI to show Yellow (Paused) state
        if (document.getElementById('statusSystem')) {
          document.getElementById('statusSystem').className = 'scada-status-dot-indicator wrn'; // WRN = Yellow
        }
        
        // Pause uptime timer
        if (systemStartTime && !isSystemPaused) {
          systemPausedTime = Date.now();
          accumulatedUptime += (systemPausedTime - systemStartTime);
          isSystemPaused = true;
        }
        
        // Stop machine state first
        fetch(`/api/machines/${selectedMachineId}/stop`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' }
        })
          .then(r => r.json())
          .then(result => {
            if (result.success) {
              machineRunning[selectedMachineId] = false;
              producerRunning = false;
              
              // Remove active state from Start button
              const startBtn = document.getElementById('btn-start');
              if (startBtn) startBtn.classList.remove('active');
              
              // Update UI to show Yellow (Paused) state
              updatePausedStatus();
              
              // Log operator action
              logOperatorAction(`Stopped Machine ${selectedMachineId}`, selectedMachineId);
            } else {
              alert(`Failed to stop machine: ${result.error || 'Unknown error'}`);
            }
          })
          .catch(error => {
            alert(`Failed to stop machine: ${error.message}`);
          });
      }
      
      // Update UI to show Paused (Yellow) state
      function updatePausedStatus() {
        // Update SYSTEM LED to Yellow (Paused)
        const systemEl = document.getElementById('statusSystem');
        if (systemEl) {
          systemEl.className = 'scada-status-dot-indicator wrn';
          systemEl.style.boxShadow = 'none';
        }
        
        // Update all category status LEDs to Yellow
        document.querySelectorAll('.health-card-status-dot').forEach(dot => {
          const currentClass = dot.className;
          if (!currentClass.includes('err')) {
            dot.className = 'health-card-status-dot wrn';
          }
        });
        
        // Update status text
        document.querySelectorAll('.health-card-status-label').forEach(label => {
          if (label.textContent !== 'CRIT') {
            label.textContent = 'PAUSED';
          }
        });
      }
      
      // ============================================
      // PIPELINE HEALTH TELEMETRY
      // ============================================
      
      let globalSamplingFrequency = 50; // Hz
      
      function updatePipelineHealth() {
        const currentMachine = machineData[selectedMachineId];
        if (!currentMachine) return;
        
        // Update total readings with rolling animation
        const totalReadingsEl = document.getElementById('total-readings');
        if (totalReadingsEl) {
          const oldValue = parseInt(totalReadingsEl.textContent.replace(/,/g, '')) || 0;
          const newValue = currentMachine.totalCount;
          
          if (newValue !== oldValue && newValue > oldValue) {
            // Add rolling animation class
            totalReadingsEl.classList.add('rolling');
            setTimeout(() => {
              totalReadingsEl.classList.remove('rolling');
            }, 300);
          }
          
          totalReadingsEl.textContent = newValue.toLocaleString();
        }
        
        // Update message velocity (MPS)
        const velocityEl = document.getElementById('message-velocity');
        if (velocityEl) {
          const mps = currentMachine.messageVelocity || 0;
          velocityEl.textContent = mps.toFixed(1);
          // Color code based on velocity
          if (mps > 10) {
            velocityEl.style.color = 'var(--status-running)';
          } else if (mps > 5) {
            velocityEl.style.color = 'var(--status-warning)';
          } else {
            velocityEl.style.color = 'var(--text-muted)';
          }
        }
      }
      
      // ============================================
      // CATEGORIZED TELEMETRY RAIL
      // ============================================
      
      const categoryMessageCounts = {
        'environmental': 0,
        'electrical': 0,
        'fluid': 0,
        'mechanical': 0,
        'thermal': 0
      };
      
      function updateTelemetryRail() {
        const container = document.getElementById('telemetryCategories');
        if (!container) return;
        
        const currentMachine = machineData[selectedMachineId];
        if (!currentMachine || !currentMachine.statsData) return;
        
        const statsData = currentMachine.statsData;
        const categories = [
          { key: 'environmental', label: 'ENV', icon: 'üåç' },
          { key: 'electrical', label: 'ELEC', icon: '‚ö°' },
          { key: 'fluid', label: 'FLUID', icon: 'üíß' },
          { key: 'mechanical', label: 'MECH', icon: '‚öôÔ∏è' },
          { key: 'thermal', label: 'THERM', icon: 'üî•' }
        ];
        
        let html = '';
        categories.forEach(cat => {
          const catData = statsData.stats_by_category && statsData.stats_by_category[cat.key];
          if (!catData || !catData.sensors) {
            html += `<div class="scada-telemetry-category">
              <span class="scada-telemetry-cat-icon">${cat.icon}</span>
              <span class="scada-telemetry-cat-label">${cat.label}</span>
              <span class="scada-telemetry-cat-value">--</span>
              <span class="scada-telemetry-cat-count">0</span>
            </div>`;
            return;
          }
          
          // Get top 2 sensors for this category
          const sensors = Object.keys(catData.sensors).slice(0, 2);
          const sensorValues = sensors.map(sensorName => {
            const sensorData = catData.sensors[sensorName];
            let value = sensorData.current;
            const unit = sensorData.unit || '';
            
            // Fallback to recent readings if current is null
            if ((value === null || value === undefined || isNaN(value)) && currentMachine.recentReadings && currentMachine.recentReadings.length > 0) {
              const latestReading = currentMachine.recentReadings[0];
              if (latestReading[sensorName] !== null && latestReading[sensorName] !== undefined && !isNaN(latestReading[sensorName])) {
                value = parseFloat(latestReading[sensorName]);
              } else if (latestReading.custom_sensors && latestReading.custom_sensors[sensorName] !== null && latestReading.custom_sensors[sensorName] !== undefined && !isNaN(latestReading.custom_sensors[sensorName])) {
                value = parseFloat(latestReading.custom_sensors[sensorName]);
              }
            }
            
            const displayValue = value !== null && value !== undefined && !isNaN(value) ? formatNumber(value, 1) : '--';
            const shortName = sensorName.replace(/_/g, ' ').substring(0, 6).toUpperCase();
            return { name: shortName, value: displayValue, unit };
          });
          
          // Update message count for this category (count readings that have sensors from this category)
          if (currentMachine.recentReadings && currentMachine.recentReadings.length > 0) {
            const categoryReadings = currentMachine.recentReadings.filter(r => {
              return sensors.some(s => {
                const val = r[s];
                const customVal = r.custom_sensors && r.custom_sensors[s];
                return (val !== null && val !== undefined && !isNaN(val)) || (customVal !== null && customVal !== undefined && !isNaN(customVal));
              });
            });
            const newCount = categoryReadings.length;
            const oldCount = categoryMessageCounts[cat.key] || 0;
            
            // Calculate MPS for this category
            const now = Date.now();
            if (categoryLastUpdateTime[cat.key] && newCount > oldCount) {
              const timeDelta = (now - categoryLastUpdateTime[cat.key]) / 1000; // seconds
              if (timeDelta >= 1) {
                const messageDelta = newCount - categoryLastCounts[cat.key];
                categoryMPS[cat.key] = messageDelta / timeDelta;
                categoryLastUpdateTime[cat.key] = now;
                categoryLastCounts[cat.key] = newCount;
              }
            } else if (!categoryLastUpdateTime[cat.key]) {
              categoryLastUpdateTime[cat.key] = now;
              categoryLastCounts[cat.key] = newCount;
            }
            
            categoryMessageCounts[cat.key] = newCount;
          }
          
          const count = categoryMessageCounts[cat.key] || 0;
          const countDisplay = count >= 1000 ? `${(count / 1000).toFixed(1)}k` : count.toString();
          const mps = categoryMPS[cat.key] || 0;
          const mpsDisplay = mps > 0 ? `${mps.toFixed(1)} MPS` : '';
          
          html += `<div class="scada-telemetry-category">
            <span class="scada-telemetry-cat-icon">${cat.icon}</span>
            <span class="scada-telemetry-cat-label">${cat.label}</span>
            <div class="scada-telemetry-cat-readings">
              ${sensorValues.map(s => `<span class="scada-telemetry-reading">${s.name}: ${s.value}${s.unit}</span>`).join(' | ')}
            </div>
            ${mpsDisplay ? `<span class="scada-telemetry-cat-mps">${mpsDisplay}</span>` : ''}
            <span class="scada-telemetry-cat-count">${countDisplay} msgs</span>
          </div>`;
        });
        
        container.innerHTML = html;
      }
      
      // MPS-based frequency control (1-20 MPS range)
      let targetMPS = 10; // Default 10 MPS
      const BATCH_SIZE = 5; // Multiply MPS by this to get Hz
      
      function updateTargetMPS(mps) {
        targetMPS = parseFloat(mps);
        const displayEl = document.getElementById('mps-display');
        const operatorDisplayEl = document.getElementById('operatorMPSDisplay');
        const commandDisplayEl = document.getElementById('commandMPSDisplay');
        if (displayEl) {
          displayEl.textContent = `${targetMPS.toFixed(1)} MPS`;
          displayEl.style.fontWeight = '700';
        }
        if (operatorDisplayEl) {
          operatorDisplayEl.textContent = `${targetMPS.toFixed(1)} MPS`;
          operatorDisplayEl.style.fontWeight = '700';
        }
        if (commandDisplayEl) {
          commandDisplayEl.textContent = `${targetMPS.toFixed(0)} MPS`;
          commandDisplayEl.style.fontWeight = '700';
        }
        const operatorSlider = document.getElementById('operatorSamplingRate');
        const commandSlider = document.getElementById('commandSamplingRate');
        if (operatorSlider) {
          operatorSlider.value = targetMPS;
        }
        if (commandSlider) {
          commandSlider.value = targetMPS;
        }
        // Calculate Hz for backend (MPS * batch size)
        const calculatedHz = targetMPS * BATCH_SIZE;
        // TODO: Send calculatedHz to backend to update producer interval
        logOperatorAction(`Changed target MPS to ${targetMPS.toFixed(1)} MPS (${calculatedHz}Hz)`);
      }
      
      // Initialize MPS display on load
      function initializeMPSDisplay() {
        const mpsSlider = document.getElementById('target-mps');
        const mpsDisplay = document.getElementById('mps-display');
        const operatorSlider = document.getElementById('operatorSamplingRate');
        const operatorDisplay = document.getElementById('operatorMPSDisplay');
        const commandSlider = document.getElementById('commandSamplingRate');
        const commandDisplay = document.getElementById('commandMPSDisplay');
        
        if (mpsSlider && mpsDisplay) {
          mpsDisplay.textContent = `${targetMPS.toFixed(1)} MPS`;
          mpsDisplay.style.fontWeight = '700';
          mpsSlider.value = targetMPS;
        }
        if (operatorSlider && operatorDisplay) {
          operatorDisplay.textContent = `${targetMPS.toFixed(1)} MPS`;
          operatorDisplay.style.fontWeight = '700';
          operatorSlider.value = targetMPS;
        }
        if (commandSlider && commandDisplay) {
          commandDisplay.textContent = `${targetMPS.toFixed(0)} MPS`;
          commandDisplay.style.fontWeight = '700';
          commandSlider.value = targetMPS;
        }
        
        // Load config values into header and operator controls
        fetch("/api/config")
          .then((r) => r.json())
          .then((data) => {
            const headerDuration = document.getElementById('headerDurationMinutes');
            const headerInterval = document.getElementById('headerIntervalSeconds');
            const operatorDuration = document.getElementById('operatorDuration');
            const commandDuration = document.getElementById('commandDuration');
            if (headerDuration) headerDuration.value = data.duration_minutes ?? 0;
            if (headerInterval) headerInterval.value = data.interval_seconds ?? 0.5;
            if (operatorDuration) operatorDuration.value = data.duration_minutes ?? 0;
            if (commandDuration) commandDuration.value = data.duration_minutes ?? 0;
          })
          .catch(e => console.error('Error loading config for header:', e));
      }

      function updateHeaderDuration(minutes) {
        const mins = parseInt(minutes) || 0;
        // Update backend config
        fetch('/api/config', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            duration_hours: 0,
            duration_minutes: mins,
            interval_seconds: parseFloat(document.getElementById('headerIntervalSeconds').value) || 0.5
          })
        }).then(r => r.json()).then(data => {
          if (data.success) {
            logOperatorAction(`Updated producer duration to ${mins} minutes`);
          }
        });
      }

      function updateHeaderInterval(seconds) {
        const secs = parseFloat(seconds) || 0.5;
        // Update backend config
        fetch('/api/config', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            duration_hours: 0,
            duration_minutes: parseInt(document.getElementById('headerDurationMinutes').value) || 0,
            interval_seconds: secs
          })
        }).then(r => r.json()).then(data => {
          if (data.success) {
            logOperatorAction(`Updated producer interval to ${secs} seconds`);
          }
        });
      }

      function updateConfigSamplingFrequency(hz) {
        updateSamplingFrequency(hz);
      }

      // Fetch machine status from backend (without starting it)
      async function fetchMachineStatus(machineId) {
        try {
          const response = await fetch('/api/machines');
          if (response.ok) {
            const data = await response.json();
            if (data.machines && data.machines[machineId]) {
              // Update machine running state based on backend response
              const isRunning = data.machines[machineId].running || false;
              machineRunning[machineId] = isRunning;
              // Update UI to reflect actual state
              updateMachineStatusUI(machineId, isRunning);
            }
          }
        } catch (e) {
          console.error('Error fetching machine status:', e);
          // On error, assume stopped
          machineRunning[machineId] = false;
          updateMachineStatusUI(machineId, false);
        }
      }

      function updateMachineStatusUI(machineId, isRunning) {
        // Update any machine-specific status indicators
        // This will be called when switching machines to reflect actual state
        const startBtn = document.getElementById('btn-start');
        if (startBtn && machineId === selectedMachineId) {
          if (isRunning && producerRunning) {
            startBtn.classList.add('active');
          } else {
            startBtn.classList.remove('active');
          }
        }
      }

      // Render sensor management in config section
      function renderConfigSensorManagement() {
        const machineLabel = document.getElementById('configMachineLabel');
        if (machineLabel) {
          machineLabel.textContent = selectedMachineId;
        }
        
        // Render accordions instead of table
        renderConfigSensorAccordions();
        
        // Legacy table rendering (kept for backward compatibility)
        const tbody = document.getElementById('configSensorListBody');
        if (!tbody) return;
        
        if (machineLabel) {
          machineLabel.textContent = selectedMachineId;
        }
        
        // Get all sensors
        const allSensors = [];
        if (typeof sensorsByCategory !== 'undefined') {
          Object.keys(sensorsByCategory).forEach(cat => {
            sensorsByCategory[cat].forEach(sensor => {
              allSensors.push({ name: sensor, category: cat });
            });
          });
        }
        
        // Get custom sensors
        if (typeof unifiedSensorRegistry !== 'undefined') {
          Object.values(unifiedSensorRegistry).forEach(sensor => {
            if (sensor.source === 'custom') {
              allSensors.push({ name: sensor.name, category: sensor.category || 'custom' });
            }
          });
        }
        
        const currentState = machineSensorState[selectedMachineId] || {};
        const isAdmin = currentUser && currentUser.role === 'admin';
        
        if (allSensors.length === 0) {
          tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: var(--text-muted); padding: var(--space-lg); font-family: var(--font-mono); font-size: 11px;">No sensors available</td></tr>';
          return;
        }
        
        let html = '';
        allSensors.forEach(({ name, category }) => {
          const state = currentState[name] || { enabled: true, baseline: null };
          const displayName = name.replace(/_/g, ' ').toUpperCase();
          const sensorData = unifiedSensorRegistry && unifiedSensorRegistry[name];
          const minThreshold = sensorData?.low_threshold || '';
          const maxThreshold = sensorData?.high_threshold || '';
          
          html += `
            <tr style="border-bottom: 1px solid var(--border-subtle);">
              <td style="padding: var(--space-sm); font-family: var(--font-mono); font-size: 11px; font-weight: 700; color: var(--text-primary);">
                ${displayName}
              </td>
              <td style="padding: var(--space-sm); text-align: center;">
                <label class="toggle-switch" style="display: inline-block;">
                  <input type="checkbox" ${state.enabled ? 'checked' : ''} 
                         ${!isAdmin ? 'disabled' : ''}
                         onchange="toggleSensorEnabled('${name}', this.checked)">
                  <span class="toggle-slider"></span>
                </label>
              </td>
              <td style="padding: var(--space-sm); text-align: center;">
                <input type="number" step="any" 
                       value="${minThreshold}" 
                       placeholder="Min"
                       style="width: 80px; padding: 4px 6px; background: var(--bg-secondary); border: 1px solid var(--border-default); border-radius: 4px; color: var(--text-primary); font-family: var(--font-mono); font-size: 11px;"
                       onchange="updateSensorThreshold('${name}', 'low', this.value)">
              </td>
              <td style="padding: var(--space-sm); text-align: center;">
                <input type="number" step="any" 
                       value="${maxThreshold}" 
                       placeholder="Max"
                       style="width: 80px; padding: 4px 6px; background: var(--bg-secondary); border: 1px solid var(--border-default); border-radius: 4px; color: var(--text-primary); font-family: var(--font-mono); font-size: 11px;"
                       onchange="updateSensorThreshold('${name}', 'high', this.value)">
              </td>
            </tr>
          `;
        });
        
        tbody.innerHTML = html;
      }

      function updateSensorThreshold(sensorName, type, value) {
        // Update threshold via API
        const thresholdValue = value ? parseFloat(value) : null;
        logOperatorAction(`Updated ${sensorName} ${type} threshold to ${thresholdValue || 'none'}`);
        // TODO: Send to backend API to persist threshold
      }

      // Trigger anomaly injection from Operator Controls
      function triggerAnomalyInjection() {
        fetch('/api/inject-anomaly', { method: 'POST' })
          .then(r => r.json())
          .then(data => {
            if (data.success) {
              logOperatorAction('Triggered anomaly injection');
            } else {
              alert('Failed to trigger injection: ' + (data.error || 'Unknown error'));
            }
          })
          .catch(e => {
            console.error('Error triggering injection:', e);
            alert('Error triggering injection');
          });
      }

      // Frontend uptime tracking (synced across all category cards)
      let systemStartTime = null; // Set when producer starts
      let systemPausedTime = null; // Set when producer stops (to pause timer)
      let accumulatedUptime = 0; // Accumulated uptime before pause
      let isSystemPaused = false; // Paused state flag
      
      function formatUptime(startTime, pausedTime, accumulated) {
        if (!startTime && accumulated === 0) return '00:00:00';
        
        let elapsed = accumulated;
        if (startTime && !pausedTime) {
          // Currently running
          elapsed = Date.now() - startTime + accumulated;
        } else if (pausedTime) {
          // Currently paused
          elapsed = pausedTime - startTime + accumulated;
        }
        
        const hours = Math.floor(elapsed / 3600000);
        const minutes = Math.floor((elapsed % 3600000) / 60000);
        const seconds = Math.floor((elapsed % 60000) / 1000);
        return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
      }
      
      // Update all uptime displays every second
      function updateAllUptimes() {
        if (!systemStartTime && accumulatedUptime === 0) return;
        
        const uptimeString = formatUptime(systemStartTime, systemPausedTime, accumulatedUptime);
        
        // Update all category uptime elements
        document.querySelectorAll('[data-uptime-category]').forEach(el => {
          el.textContent = uptimeString;
        });
        
        // Update session uptime in Command Deck
        const sessionUptimeEl = document.getElementById('sessionUptime');
        if (sessionUptimeEl) {
          sessionUptimeEl.textContent = uptimeString;
        }
      }
      
      // Update uptime every second
      setInterval(updateAllUptimes, 1000);
      
      // Session uptime tracking (for Command Deck)
      function updateSessionUptime() {
        const uptimeEl = document.getElementById('sessionUptime');
        if (!uptimeEl) return;
        
        if (systemStartTime) {
          uptimeEl.textContent = formatUptime(systemStartTime);
        } else {
          uptimeEl.textContent = '00:00:00';
        }
      }

      // Filter operator logs by user
      function filterOperatorLogs() {
        const filter = document.getElementById('logUserFilter').value;
        const tbody = document.getElementById('operatorLogsTableBody');
        if (!tbody) return;
        
        const rows = tbody.querySelectorAll('tr');
        rows.forEach(row => {
          const usernameCell = row.querySelector('td:first-child');
          if (!usernameCell) return;
          const username = usernameCell.textContent.trim();
          if (!filter || username === filter) {
            row.style.display = '';
          } else {
            row.style.display = 'none';
          }
        });
      }

      // Toggle logs collapse
      let logsCollapsed = false;
      function toggleLogsCollapse() {
        logsCollapsed = !logsCollapsed;
        const container = document.getElementById('operatorLogsContainer');
        const btn = document.getElementById('logsCollapseBtn');
        if (container) {
          container.style.display = logsCollapsed ? 'none' : 'block';
        }
        if (btn) {
          btn.textContent = logsCollapsed ? '‚ñ∂' : '‚ñº';
        }
      }

      // Export logs to PDF (placeholder)
      function exportLogsPDF() {
        alert('PDF export functionality will be implemented with backend integration');
        // TODO: Implement PDF export
      }

      // Render custom sensors with accordion by category
      function renderCustomSensorsAccordion() {
        const container = document.getElementById('customSensorsAccordion');
        if (!container || typeof unifiedSensorRegistry === 'undefined') return;
        
        const customSensors = Object.values(unifiedSensorRegistry).filter(s => s.source === 'custom');
        if (customSensors.length === 0) {
          container.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: var(--space-lg); font-family: var(--font-mono); font-size: 11px;">No custom sensors</div>';
          return;
        }
        
        // Group by category
        const byCategory = {};
        customSensors.forEach(sensor => {
          const cat = sensor.category || 'custom';
          if (!byCategory[cat]) byCategory[cat] = [];
          byCategory[cat].push(sensor);
        });
        
        const categories = ['environmental', 'electrical', 'fluid', 'mechanical', 'thermal', 'custom'];
        let html = '';
        categories.forEach(cat => {
          if (!byCategory[cat] || byCategory[cat].length === 0) return;
          
          const catLabel = cat.charAt(0).toUpperCase() + cat.slice(1);
          html += `
            <div class="rig-accordion">
              <div class="rig-accordion-header" onclick="toggleAccordion('${cat}')">
                <span style="font-family: var(--font-mono); font-size: 10px; font-weight: 700; color: var(--text-primary); text-transform: uppercase;">${catLabel}</span>
                <span style="font-family: var(--font-mono); font-size: 9px; color: var(--text-muted);">(${byCategory[cat].length})</span>
                <span class="rig-accordion-chevron" id="chevron-${cat}">‚ñº</span>
              </div>
              <div class="rig-accordion-content" id="accordion-${cat}" style="display: none;">
                ${byCategory[cat].map(sensor => `
                  <div style="padding: var(--space-sm); border-bottom: 1px solid var(--border-subtle); display: flex; justify-content: space-between; align-items: center;">
                    <div>
                      <span style="font-family: var(--font-mono); font-size: 11px; font-weight: 700; color: var(--text-primary);">${sensor.name.replace(/_/g, ' ').toUpperCase()}</span>
                      <span style="font-family: var(--font-mono); font-size: 9px; color: var(--text-muted); margin-left: var(--space-sm);">${sensor.unit || ''}</span>
                    </div>
                    <div style="display: flex; gap: var(--space-sm);">
                      <button onclick="editCustomSensor(${sensor.id})" class="rig-btn rig-btn-secondary" style="padding: 4px 8px; font-size: 9px;">EDIT</button>
                      <button onclick="deleteCustomSensor(${sensor.id})" class="rig-btn rig-btn-stop" style="padding: 4px 8px; font-size: 9px;">DELETE</button>
                    </div>
                  </div>
                `).join('')}
              </div>
            </div>
          `;
        });
        
        container.innerHTML = html;
      }

      function toggleAccordion(category) {
        const content = document.getElementById(`accordion-${category}`);
        const chevron = document.getElementById(`chevron-${category}`);
        if (content) {
          const isHidden = content.style.display === 'none';
          content.style.display = isHidden ? 'block' : 'none';
          if (chevron) {
            chevron.textContent = isHidden ? '‚ñ≤' : '‚ñº';
          }
        }
      }

      // Get threshold color class for values
      function getThresholdColorClass(value, threshold) {
        if (!threshold || value === null || value === undefined || isNaN(value)) {
          return 'value-normal';
        }
        
        const { min, max } = threshold;
        const range = max - min;
        const warningZone = range * 0.1; // 10% of range for warning
        
        // Critical: outside threshold
        if (value < min || value > max) {
          return 'value-critical';
        }
        
        // Warning: within 10% of threshold
        if (value <= min + warningZone || value >= max - warningZone) {
          return 'value-warning';
        }
        
        // Normal: safely within range
        return 'value-normal';
      }


      // Load config values into form
      function loadConfigIntoForm() {
        fetch("/api/config")
          .then((r) => r.json())
          .then((data) => {
            const hoursEl = document.getElementById('configDurationHours');
            const minutesEl = document.getElementById('configDurationMinutes');
            const intervalEl = document.getElementById('configIntervalSeconds');
            
            if (hoursEl) hoursEl.value = data.duration_hours ?? 0;
            if (minutesEl) minutesEl.value = data.duration_minutes ?? 0;
            if (intervalEl) intervalEl.value = data.interval_seconds ?? 5;
          })
          .catch(e => console.error('Error loading config:', e));
      }

      // Update config from form
      async function updateConfigFromForm() {
        const hours = parseInt(document.getElementById('configDurationHours').value) || 0;
        const minutes = parseInt(document.getElementById('configDurationMinutes').value) || 0;
        const interval = parseInt(document.getElementById('configIntervalSeconds').value) || 5;
        const messageEl = document.getElementById('configFormMessage');

        try {
          const response = await fetch('/api/config', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              duration_hours: hours,
              duration_minutes: minutes,
              interval_seconds: interval
            })
          });

          const data = await response.json();
          if (data.success) {
            if (messageEl) {
              messageEl.textContent = 'Configuration updated successfully.';
              messageEl.style.color = 'var(--status-running)';
            }
            logOperatorAction(`Updated producer config: ${hours}h ${minutes}m, interval ${interval}s`);
          } else {
            if (messageEl) {
              messageEl.textContent = data.error || 'Failed to update configuration.';
              messageEl.style.color = 'var(--status-error)';
            }
          }
        } catch (e) {
          if (messageEl) {
            messageEl.textContent = 'Network error. Please try again.';
            messageEl.style.color = 'var(--status-error)';
          }
        }
      }

      // Reset config to defaults
      async function resetConfigFromForm() {
        try {
          const response = await fetch('/api/config/reset', { method: 'POST' });
          const data = await response.json();
          if (data.success) {
            loadConfigIntoForm();
            const messageEl = document.getElementById('configFormMessage');
            if (messageEl) {
              messageEl.textContent = 'Configuration reset to defaults.';
              messageEl.style.color = 'var(--status-running)';
            }
            logOperatorAction('Reset producer configuration to defaults');
          }
        } catch (e) {
          console.error('Error resetting config:', e);
        }
      }
      
      // ============================================
      // AI-POWERED SENSOR UPLOAD (Frontend Mockup)
      // ============================================
      
      let uploadedSensorFile = null;
      let aiParsedData = null;
      
      function handleSensorFileDrop(event) {
        event.preventDefault();
        const files = event.dataTransfer.files;
        if (files.length > 0) {
          handleSensorFile(files[0]);
        }
      }
      
      function handleSensorFileSelect(event) {
        const files = event.target.files;
        if (files.length > 0) {
          handleSensorFile(files[0]);
        }
      }
      
      function handleSensorFile(file) {
        uploadedSensorFile = file;
        const uploadZone = document.getElementById('sensorUploadZone');
        if (uploadZone) {
          uploadZone.classList.add('scada-upload-zone-has-file');
          uploadZone.querySelector('.scada-upload-text').textContent = `üìÑ ${file.name}`;
          uploadZone.querySelector('.scada-upload-hint').textContent = `${(file.size / 1024).toFixed(1)} KB`;
        }
        // Enable AI parse button
        const parseBtn = document.getElementById('aiParseBtn');
        if (parseBtn) {
          parseBtn.disabled = false;
        }
      }
      
      function aiParseSensorFile() {
        if (!uploadedSensorFile) {
          alert('Please upload a file first');
          return;
        }
        
        const loadingEl = document.getElementById('aiParseLoading');
        const resultsEl = document.getElementById('aiParseResults');
        const parseBtn = document.getElementById('aiParseBtn');
        
        // Show loading
        if (loadingEl) loadingEl.style.display = 'block';
        if (resultsEl) resultsEl.style.display = 'none';
        if (parseBtn) parseBtn.disabled = true;
        
        // Create FormData and append file
        const formData = new FormData();
        formData.append('file', uploadedSensorFile);
        
        // #region agent log
        fetch('http://127.0.0.1:7243/ingest/7ce1c69f-6529-4e30-b8ed-f1fe34b6ca57',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'dashboard.html:6799',message:'aiParseSensorFile: Starting fetch request',data:{hasFile:!!uploadedSensorFile,fileName:uploadedSensorFile?.name},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
        // #endregion
        
        // Make API call to backend
        fetch('/api/admin/parse-sensor-file', {
          method: 'POST',
          body: formData,
          credentials: 'include'  // Include cookies for session
        })
          .then(async response => {
            // #region agent log
            fetch('http://127.0.0.1:7243/ingest/7ce1c69f-6529-4e30-b8ed-f1fe34b6ca57',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'dashboard.html:6803',message:'aiParseSensorFile: Response received',data:{status:response.status,statusText:response.statusText,contentType:response.headers.get('content-type'),ok:response.ok},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
            // #endregion
            
            // Check if response is JSON
            const contentType = response.headers.get('content-type');
            if (!contentType || !contentType.includes('application/json')) {
              // If not JSON, it's probably an HTML error page
              const text = await response.text();
              // #region agent log
              fetch('http://127.0.0.1:7243/ingest/7ce1c69f-6529-4e30-b8ed-f1fe34b6ca57',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'dashboard.html:6809',message:'aiParseSensorFile: Non-JSON response detected',data:{status:response.status,textPreview:text.substring(0,200)},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
              // #endregion
              throw new Error('Server returned non-JSON response. You may need to log in again.');
            }
            
            if (!response.ok) {
              // Try to parse as JSON error
              try {
                const err = await response.json();
                return Promise.reject(err);
              } catch (e) {
                // If parsing fails, use status text
                return Promise.reject({ error: `Server error: ${response.status} ${response.statusText}` });
              }
            }
            return response.json();
          })
          .then(data => {
            // Map backend response to frontend format
            aiParsedData = {
              name: data.sensor_name || '',
              category: data.category || 'custom',
              unit: data.unit || '',
              min_range: data.min_range || 0,
              max_range: data.max_range || 100,
              threshold_min: data.low_threshold || null,
              threshold_max: data.high_threshold || null
            };
            
            // Hide loading, show results
            if (loadingEl) loadingEl.style.display = 'none';
            if (resultsEl) {
              resultsEl.style.display = 'block';
              const previewEl = document.getElementById('aiParsePreview');
              if (previewEl) {
                const thresholdsText = aiParsedData.threshold_min !== null && aiParsedData.threshold_max !== null
                  ? `${aiParsedData.threshold_min} - ${aiParsedData.threshold_max}`
                  : 'Not set';
                
                previewEl.innerHTML = `
                  <div style="display: grid; gap: var(--space-xs); font-size: 10px; font-family: var(--font-mono);">
                    <div style="font-weight: 700; color: var(--text-primary);"><strong>NAME:</strong> <span style="color: var(--theme-status-info);">${aiParsedData.name}</span></div>
                    <div style="font-weight: 700; color: var(--text-primary);"><strong>CATEGORY:</strong> <span style="color: var(--theme-status-info);">${aiParsedData.category.toUpperCase()}</span></div>
                    <div style="font-weight: 700; color: var(--text-primary);"><strong>UNIT:</strong> <span style="color: var(--theme-status-info);">${aiParsedData.unit}</span></div>
                    <div style="font-weight: 700; color: var(--text-primary);"><strong>RANGE:</strong> <span style="color: var(--theme-status-info);">${aiParsedData.min_range} - ${aiParsedData.max_range}</span></div>
                    <div style="font-weight: 700; color: var(--text-primary);"><strong>THRESHOLDS:</strong> <span style="color: var(--theme-status-info);">${thresholdsText}</span></div>
                  </div>
                `;
              }
            }
            if (parseBtn) parseBtn.disabled = false;
          })
          .catch(error => {
            // Handle error
            let errorMessage = 'Failed to parse sensor file';
            
            if (error && typeof error === 'object') {
              errorMessage = error.error || error.message || JSON.stringify(error);
            } else if (typeof error === 'string') {
              errorMessage = error;
            }
            
            // Check for authentication errors
            if (errorMessage.includes('Authentication required') || errorMessage.includes('non-JSON')) {
              errorMessage = 'Session expired. Please refresh the page and log in again.';
            }
            
            alert(`Error: ${errorMessage}`);
            
            // Hide loading
            if (loadingEl) loadingEl.style.display = 'none';
            if (parseBtn) parseBtn.disabled = false;
          });
      }
      
      function applyAIParseResults() {
        if (!aiParsedData) {
          alert('No parsed data available');
          return;
        }
        
        // Auto-fill the "Add New Sensor" form (if it exists)
        const nameInput = document.getElementById('newSensorName');
        const categorySelect = document.getElementById('newSensorCategory');
        const unitInput = document.getElementById('newSensorUnit');
        const minRangeInput = document.getElementById('newSensorMinRange');
        const maxRangeInput = document.getElementById('newSensorMaxRange');
        const lowThresholdInput = document.getElementById('newSensorLowThreshold');
        const highThresholdInput = document.getElementById('newSensorHighThreshold');
        
        if (nameInput) nameInput.value = aiParsedData.name;
        if (categorySelect) categorySelect.value = aiParsedData.category;
        if (unitInput) unitInput.value = aiParsedData.unit;
        if (minRangeInput) minRangeInput.value = aiParsedData.min_range || '';
        if (maxRangeInput) maxRangeInput.value = aiParsedData.max_range || '';
        if (lowThresholdInput) lowThresholdInput.value = aiParsedData.threshold_min || '';
        if (highThresholdInput) highThresholdInput.value = aiParsedData.threshold_max || '';
        
        // Show success message
        alert('‚úì Sensor parameters auto-filled! Review and submit the form.');
        
        // Scroll to form if needed
        const formSection = document.getElementById('sectionConfigContent');
        if (formSection) {
          formSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
      }
      
      // ============================================
      // CONFIG SENSOR ACCORDIONS (5-Category Master List)
      // ============================================
      function renderConfigSensorAccordions() {
        const container = document.getElementById('configSensorAccordions');
        if (!container) return;
        
        // Hardcoded sensor ranges from config.py (for default references)
        const sensorRanges = {
          'temperature': {min: 60.0, max: 100.0, unit: '¬∞F'},
          'pressure': {min: 0.0, max: 15.0, unit: 'PSI'},
          'humidity': {min: 20.0, max: 80.0, unit: '%'},
          'ambient_temp': {min: 50.0, max: 90.0, unit: '¬∞F'},
          'dew_point': {min: 30.0, max: 70.0, unit: '¬∞F'},
          'air_quality_index': {min: 0, max: 500, unit: 'AQI'},
          'co2_level': {min: 400, max: 2000, unit: 'ppm'},
          'particle_count': {min: 0, max: 100000, unit: 'particles/m¬≥'},
          'noise_level': {min: 40, max: 110, unit: 'dB'},
          'light_intensity': {min: 0, max: 10000, unit: 'lux'},
          'vibration': {min: 0.0, max: 10.0, unit: 'mm/s'},
          'rpm': {min: 1000.0, max: 5000.0, unit: 'RPM'},
          'torque': {min: 0, max: 500, unit: 'Nm'},
          'shaft_alignment': {min: -0.5, max: 0.5, unit: 'mm'},
          'bearing_temp': {min: 70, max: 180, unit: '¬∞F'},
          'motor_current': {min: 0, max: 100, unit: 'A'},
          'belt_tension': {min: 20, max: 100, unit: 'lbf'},
          'gear_wear': {min: 0, max: 100, unit: '%'},
          'coupling_temp': {min: 60, max: 150, unit: '¬∞F'},
          'lubrication_pressure': {min: 10, max: 60, unit: 'PSI'},
          'coolant_temp': {min: 140, max: 220, unit: '¬∞F'},
          'exhaust_temp': {min: 300, max: 900, unit: '¬∞F'},
          'oil_temp': {min: 150, max: 250, unit: '¬∞F'},
          'radiator_temp': {min: 150, max: 230, unit: '¬∞F'},
          'thermal_efficiency': {min: 60, max: 95, unit: '%'},
          'heat_dissipation': {min: 0, max: 5000, unit: 'W'},
          'inlet_temp': {min: 50, max: 120, unit: '¬∞F'},
          'outlet_temp': {min: 80, max: 200, unit: '¬∞F'},
          'core_temp': {min: 140, max: 240, unit: '¬∞F'},
          'surface_temp': {min: 70, max: 180, unit: '¬∞F'},
          'voltage': {min: 110, max: 130, unit: 'V'},
          'current': {min: 0, max: 50, unit: 'A'},
          'power_factor': {min: 0.7, max: 1.0, unit: 'PF'},
          'frequency': {min: 59.0, max: 61.0, unit: 'Hz'},
          'resistance': {min: 0.1, max: 100, unit: 'Œ©'},
          'capacitance': {min: 1, max: 1000, unit: 'ŒºF'},
          'inductance': {min: 0.1, max: 10, unit: 'mH'},
          'phase_angle': {min: -180, max: 180, unit: '¬∞'},
          'harmonic_distortion': {min: 0, max: 20, unit: '%'},
          'ground_fault': {min: 0, max: 100, unit: 'mA'},
          'flow_rate': {min: 0, max: 500, unit: 'L/min'},
          'fluid_pressure': {min: 0, max: 100, unit: 'PSI'},
          'viscosity': {min: 1, max: 100, unit: 'cP'},
          'density': {min: 0.5, max: 1.5, unit: 'g/cm¬≥'},
          'reynolds_number': {min: 2000, max: 10000, unit: ''},
          'pipe_pressure_drop': {min: 0, max: 50, unit: 'PSI'},
          'pump_efficiency': {min: 60, max: 95, unit: '%'},
          'cavitation_index': {min: 0, max: 10, unit: ''},
          'turbulence': {min: 0, max: 100, unit: '%'},
          'valve_position': {min: 0, max: 100, unit: '%'}
        };
        
        // Get all sensors from unified registry or sensorsByCategory
        let allSensors = [];
        if (typeof unifiedSensorRegistry !== 'undefined') {
          allSensors = Object.values(unifiedSensorRegistry);
        } else if (typeof sensorsByCategory !== 'undefined') {
          Object.keys(sensorsByCategory).forEach(cat => {
            sensorsByCategory[cat].forEach(sensorName => {
              allSensors.push({
                sensor_name: sensorName,
                name: sensorName,
                category: sensorRanges[sensorName]?.category || 'custom',
                unit: sensorRanges[sensorName]?.unit || '',
                min_range: sensorRanges[sensorName]?.min || 0,
                max_range: sensorRanges[sensorName]?.max || 100
              });
            });
          });
        }
        
        // Group by the 5 master categories
        const categories = ['environmental', 'mechanical', 'thermal', 'electrical', 'fluid'];
        const byCategory = {};
        
        allSensors.forEach(sensor => {
          const cat = sensor.category || 'custom';
          if (categories.includes(cat)) {
            if (!byCategory[cat]) byCategory[cat] = [];
            byCategory[cat].push(sensor);
          }
        });
        
        let html = '';
        categories.forEach(cat => {
          if (!byCategory[cat] || byCategory[cat].length === 0) return;
          
          const catLabel = cat.charAt(0).toUpperCase() + cat.slice(1);
          const sensors = byCategory[cat];
          
          // Check if all sensors in category are enabled
          const allEnabled = sensors.every(s => {
            const sensorName = s.sensor_name || s.name;
            return machineSensorState[selectedMachineId][sensorName]?.enabled !== false;
          });
          
          html += `
            <div class="rig-accordion" style="margin-bottom: var(--space-sm);">
              <div class="rig-accordion-header" onclick="toggleConfigAccordion('${cat}')" style="padding: var(--space-sm);">
                <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                  <div style="display: flex; align-items: center; gap: var(--space-sm);">
                    <span style="font-family: var(--font-mono); font-size: 10px; font-weight: 700; color: var(--text-primary); text-transform: uppercase;">${catLabel}</span>
                    <span style="font-family: var(--font-mono); font-size: 9px; color: var(--text-muted);">(${sensors.length})</span>
                  </div>
                  <div style="display: flex; align-items: center; gap: var(--space-xs);">
                    <button 
                      onclick="event.stopPropagation(); enableAllInCategory('${cat}', true)" 
                      class="scada-btn" 
                      style="padding: 2px 6px; font-size: 8px; background: var(--status-running); border-color: var(--status-running); font-weight: 700;">
                      ENABLE ALL
                    </button>
                    <button 
                      onclick="event.stopPropagation(); enableAllInCategory('${cat}', false)" 
                      class="scada-btn" 
                      style="padding: 2px 6px; font-size: 8px; background: var(--status-error); border-color: var(--status-error); font-weight: 700;">
                      DISABLE ALL
                    </button>
                    <span class="rig-accordion-chevron" id="chevron-config-${cat}" style="font-size: 10px;">‚ñº</span>
                  </div>
                </div>
              </div>
              <div class="rig-accordion-content" id="accordion-config-${cat}" style="display: none; padding: var(--space-xs);">
                ${sensors.map(sensor => {
                  const sensorName = sensor.sensor_name || sensor.name;
                  const enabled = machineSensorState[selectedMachineId][sensorName]?.enabled !== false;
                  const defaultRange = sensorRanges[sensorName] || {min: 0, max: 100, unit: ''};
                  const displayName = sensorName.replace(/_/g, ' ').toUpperCase();
                  
                  return `
                    <div style="padding: 2px var(--space-xs); border-bottom: 1px solid var(--border-subtle); display: grid; grid-template-columns: auto 1fr auto 80px 80px auto; gap: 4px; align-items: center; font-size: 8px;">
                      <label class="toggle-switch" style="transform: scale(0.6);">
                        <input 
                          type="checkbox" 
                          ${enabled ? 'checked' : ''} 
                          onchange="toggleSensorEnabledFromAccordion('${sensorName}', this.checked)">
                        <span class="toggle-slider"></span>
                      </label>
                      <span style="font-family: var(--font-mono); font-weight: 700; color: var(--text-primary); font-size: 8px;">${displayName}</span>
                      <input type="number" step="any" value="${defaultRange.min}" placeholder="Min" class="scada-input" style="width: 100%; padding: 2px 4px; font-size: 8px; background: var(--theme-bg-secondary); border: 1px solid var(--border-default); color: var(--text-primary);">
                      <input type="number" step="any" value="${defaultRange.max}" placeholder="Max" class="scada-input" style="width: 100%; padding: 2px 4px; font-size: 8px; background: var(--theme-bg-secondary); border: 1px solid var(--border-default); color: var(--text-primary);">
                      <span style="font-family: var(--font-mono); font-size: 7px; color: var(--text-muted); font-weight: 700;">REF: ${defaultRange.min}-${defaultRange.max}</span>
                    </div>
                  `;
                }).join('')}
              </div>
            </div>
          `;
        });
        
        if (html === '') {
          html = '<div style="text-align: center; color: var(--text-muted); padding: var(--space-lg); font-family: var(--font-mono); font-size: 11px; font-weight: 700;">No sensors found</div>';
        }
        
        container.innerHTML = html;
      }
      
      function toggleConfigAccordion(category) {
        const content = document.getElementById(`accordion-config-${category}`);
        const chevron = document.getElementById(`chevron-config-${category}`);
        if (content) {
          const isHidden = content.style.display === 'none';
          content.style.display = isHidden ? 'block' : 'none';
          if (chevron) chevron.textContent = isHidden ? '‚ñ≤' : '‚ñº';
        }
      }
      
      function enableAllInCategory(category, enable) {
        // Category to sensor mapping
        const categoryMap = {
          'environmental': ['temperature', 'pressure', 'humidity', 'ambient_temp', 'dew_point', 'air_quality_index', 'co2_level', 'particle_count', 'noise_level', 'light_intensity'],
          'mechanical': ['vibration', 'rpm', 'torque', 'shaft_alignment', 'bearing_temp', 'motor_current', 'belt_tension', 'gear_wear', 'coupling_temp', 'lubrication_pressure'],
          'thermal': ['coolant_temp', 'exhaust_temp', 'oil_temp', 'radiator_temp', 'thermal_efficiency', 'heat_dissipation', 'inlet_temp', 'outlet_temp', 'core_temp', 'surface_temp'],
          'electrical': ['voltage', 'current', 'power_factor', 'frequency', 'resistance', 'capacitance', 'inductance', 'phase_angle', 'harmonic_distortion', 'ground_fault'],
          'fluid': ['flow_rate', 'fluid_pressure', 'viscosity', 'density', 'reynolds_number', 'pipe_pressure_drop', 'pump_efficiency', 'cavitation_index', 'turbulence', 'valve_position']
        };
        
        // Find all sensors in this category
        let sensorsInCategory = categoryMap[category] || [];
        
        // Also check unifiedSensorRegistry if available
        if (typeof unifiedSensorRegistry !== 'undefined') {
          Object.values(unifiedSensorRegistry).forEach(sensor => {
            if (sensor.category === category) {
              const sensorName = sensor.sensor_name || sensor.name;
              if (!sensorsInCategory.includes(sensorName)) {
                sensorsInCategory.push(sensorName);
              }
            }
          });
        }
        
        // Update state for all sensors in category
        sensorsInCategory.forEach(sensorName => {
          if (!machineSensorState[selectedMachineId][sensorName]) {
            machineSensorState[selectedMachineId][sensorName] = { enabled: true, baseline: null };
          }
          machineSensorState[selectedMachineId][sensorName].enabled = enable;
        });
        
        // Re-render accordion to show updated state
        renderConfigSensorAccordions();
        
        // Refresh operator dashboard
        updateStats();
      }
      
      function toggleSensorEnabledFromAccordion(sensorName, enabled) {
        if (!machineSensorState[selectedMachineId][sensorName]) {
          machineSensorState[selectedMachineId][sensorName] = { enabled: true, baseline: null };
        }
        machineSensorState[selectedMachineId][sensorName].enabled = enabled;
        
        // Update other UI elements if needed
        updateStats();
      }
      
      // ============================================
      // OPERATOR LOGS (Frontend Only)
      // ============================================
      
      const operatorLogs = [];
      
      async function logOperatorAction(action, machineId = null) {
        if (!currentUser) return;
        
        const logEntry = {
          operatorName: currentUser.username,
          action: action,
          timestamp: new Date().toISOString(),
          machineId: machineId
        };
        
        // Add to frontend array for immediate display
        operatorLogs.unshift(logEntry);
        if (operatorLogs.length > 100) {
          operatorLogs.pop(); // Keep last 100 entries
        }
        
        updateOperatorLogsTable();
        
        // Save to database (async, don't wait)
        fetch('/api/audit-log', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            operator_name: currentUser.username,
            action: action,
            machine_id: machineId
          })
        }).catch(e => {
          console.error('Failed to save audit log:', e);
        });
      }
      
      function updateOperatorLogsTable() {
        const tbody = document.getElementById('operatorLogsTableBody');
        const userFilter = document.getElementById('logUserFilter');
        if (!tbody) return;
        
        if (operatorLogs.length === 0) {
          tbody.innerHTML = '<tr><td colspan="3" style="text-align: center; color: var(--text-muted); padding: var(--space-lg); font-family: var(--font-mono); font-size: 11px;">No logs available</td></tr>';
          return;
        }
        
        // Populate user filter dropdown
        if (userFilter) {
          const uniqueUsers = [...new Set(operatorLogs.map(l => l.operatorName))];
          const currentValue = userFilter.value;
          userFilter.innerHTML = '<option value="">All Users</option>' + 
            uniqueUsers.map(u => `<option value="${u}">${u}</option>`).join('');
          userFilter.value = currentValue;
        }
        
        // Filter logs
        const filter = userFilter?.value || '';
        const filteredLogs = filter ? operatorLogs.filter(l => l.operatorName === filter) : operatorLogs;
        
        tbody.innerHTML = filteredLogs.map(log => `
          <tr>
            <td style="font-family: var(--font-mono); font-size: 11px; font-weight: 700; color: var(--text-primary);">${log.operatorName}</td>
            <td style="font-family: var(--font-mono); font-size: 11px; color: var(--text-primary);">${log.action}</td>
            <td style="font-family: var(--font-mono); font-size: 11px; color: var(--text-muted);">${new Date(log.timestamp).toLocaleString()}</td>
          </tr>
        `).join('');
      }
      
      async function loadOperatorLogs() {
        if (!currentUser || currentUser.role !== 'admin') return;
        
        try {
          const response = await fetch('/api/audit-logs?limit=100');
          const data = await response.json();
          
          if (data.success && data.logs) {
            // Merge database logs with frontend logs (avoid duplicates)
            const existingTimestamps = new Set(operatorLogs.map(l => l.timestamp));
            data.logs.forEach(log => {
              if (!existingTimestamps.has(log.timestamp)) {
                operatorLogs.unshift({
                  operatorName: log.operator_name,
                  action: log.action,
                  timestamp: log.timestamp,
                  machineId: log.machine_id
                });
              }
            });
            
            // Keep only last 100
            if (operatorLogs.length > 100) {
              operatorLogs.splice(100);
            }
            
            updateOperatorLogsTable();
          }
        } catch (e) {
          console.error('Failed to load operator logs:', e);
        }
      }
      
      // ============================================
      // ADMIN USER MANAGEMENT (Frontend Only)
      // ============================================
      
      function adminCreateUser(event) {
        event.preventDefault();
        
        const username = document.getElementById('adminNewUsername').value;
        const password = document.getElementById('adminNewPassword').value;
        const role = document.getElementById('adminNewRole').value;
        const machineCheckboxes = document.querySelectorAll('.admin-machine-checkbox:checked');
        const machines = Array.from(machineCheckboxes).map(cb => cb.value);
        
        if (machines.length === 0 && role === 'operator') {
          document.getElementById('adminCreateUserError').textContent = 'Operators must have at least one assigned machine';
          document.getElementById('adminCreateUserError').style.display = 'block';
          document.getElementById('adminCreateUserSuccess').style.display = 'none';
          return;
        }
        
        // Use existing signup API
        fetch('/api/auth/signup', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            username: username,
            password: password,
            role: role,
            machine_ids: machines
          })
        })
          .then(r => r.json())
          .then(result => {
            if (result.success) {
              document.getElementById('adminCreateUserSuccess').textContent = `User "${username}" created successfully`;
              document.getElementById('adminCreateUserSuccess').style.display = 'block';
              document.getElementById('adminCreateUserError').style.display = 'none';
              document.getElementById('adminCreateUserForm').reset();
              logOperatorAction(`Created user: ${username} (${role})`);
            } else {
              document.getElementById('adminCreateUserError').textContent = result.error || 'Failed to create user';
              document.getElementById('adminCreateUserError').style.display = 'block';
              document.getElementById('adminCreateUserSuccess').style.display = 'none';
            }
          })
          .catch(error => {
            document.getElementById('adminCreateUserError').textContent = `Error: ${error.message}`;
            document.getElementById('adminCreateUserError').style.display = 'block';
            document.getElementById('adminCreateUserSuccess').style.display = 'none';
          });
      }
      
      // Update configuration section status when visible
      function updateConfigSectionStatus(statusData) {
        const producerStatus = document.getElementById('producerStatus');
        const configProducerStatus = document.getElementById('configProducerStatus');
        const configProducerStatusText = document.getElementById('configProducerStatusText');
        if (producerStatus && configProducerStatus && configProducerStatusText) {
          const isRunning = producerStatus.classList.contains('status-running');
          configProducerStatus.className = 'scada-status-dot-indicator ' + (isRunning ? 'nom' : '');
          configProducerStatusText.textContent = isRunning ? 'RUNNING' : 'STOPPED';
        }
        
        const consumerStatus = document.getElementById('consumerStatus');
        const configConsumerStatus = document.getElementById('configConsumerStatus');
        const configConsumerStatusText = document.getElementById('configConsumerStatusText');
        if (consumerStatus && configConsumerStatus && configConsumerStatusText) {
          const isRunning = consumerStatus.classList.contains('status-running');
          configConsumerStatus.className = 'scada-status-dot-indicator ' + (isRunning ? 'nom' : '');
          configConsumerStatusText.textContent = isRunning ? 'RUNNING' : 'STOPPED';
        }
        
        // Update Kafka status
        const kafkaStatusDetails = document.getElementById('kafkaStatusDetails');
        const configKafkaStatus = document.getElementById('configKafkaStatus');
        const configKafkaStatusText = document.getElementById('configKafkaStatusText');
        if (kafkaStatusDetails && configKafkaStatus && configKafkaStatusText) {
          const kafkaStatus = document.getElementById('kafkaStatus');
          if (kafkaStatus) {
            const isHealthy = kafkaStatus.classList.contains('status-running');
            configKafkaStatus.className = 'scada-status-dot-indicator ' + (isHealthy ? 'nom' : 'err');
            configKafkaStatusText.textContent = kafkaStatusDetails.textContent || 'UNKNOWN';
          }
        }
      }
      
      // ============================================
      // SECTION SWITCHING & SIDEBAR TOGGLE
      // ============================================
      
      function switchSection(sectionName) {
        // Security check for admin section
        if (sectionName === 'admin') {
          if (!currentUser || currentUser.role !== 'admin') {
            alert('Access denied. Admin privileges required.');
            return;
          }
        }
        
        // Hide all sections
        document.querySelectorAll('.scada-section').forEach(section => {
          section.style.display = 'none';
          section.classList.remove('active');
        });
        
        // Show the selected section
        const targetSection = document.getElementById(`section-${sectionName}`);
        if (targetSection) {
          targetSection.style.display = 'block';
          targetSection.classList.add('active');
          
          // Initialize admin grid if needed
          if (sectionName === 'admin') {
            if (typeof adminGrid === 'undefined') {
              initAdminGrid();
            }
            loadAdminAuditLogs();
            loadAdminUserList();
          }
          
          // Load config when opening configuration section
          if (sectionName === 'configuration') {
            loadConfigIntoForm();
            renderConfigSensorManagement();
            renderCustomSensorsAccordion();
            // Update machine label
            const machineLabel = document.getElementById('configMachineLabel');
            if (machineLabel) machineLabel.textContent = selectedMachineId;
          }
          
          // Update sensor management when switching machines
          if (sectionName === 'configuration') {
            renderConfigSensorManagement();
          }
          
          // Load operator logs when opening config (if admin)
          if (sectionName === 'configuration' && currentUser && currentUser.role === 'admin') {
            loadOperatorLogs();
          }
          
          // Initialize alarms chart matrix
          if (sectionName === 'alarms') {
            renderAlarmsCategoryToggles();
            renderAlarmMatrix();
            // Update alarms periodically
            if (alarmsUpdateInterval) clearInterval(alarmsUpdateInterval);
            alarmsUpdateInterval = setInterval(() => {
              renderAlarmMatrix();
            }, 2000);
          } else {
            if (alarmsUpdateInterval) {
              clearInterval(alarmsUpdateInterval);
              alarmsUpdateInterval = null;
            }
          }
        } else {
          console.error(`Section 'section-${sectionName}' not found`);
        }
        
        // Update sidebar icon active states
        document.querySelectorAll('.scada-sidebar-icon').forEach(icon => {
          if (icon.dataset.section === sectionName) {
            icon.classList.add('active');
          } else {
            icon.classList.remove('active');
          }
        });
      }
      
      function toggleLeftSidebar() {
        const sidebar = document.getElementById('leftSidebar');
        const main = document.querySelector('.scada-main');
        
        if (sidebar) {
          sidebar.classList.toggle('expanded');
          
          if (main) {
            main.classList.toggle('sidebar-open');
          }
        } else {
          console.error('Left sidebar element not found');
        }
      }
      
      function updateKafkaModalStatus() {
        // Update producer status
        const producerStatus = document.getElementById('producerStatus');
        const modalProducerStatus = document.getElementById('modalProducerStatus');
        const modalProducerStatusText = document.getElementById('modalProducerStatusText');
        if (producerStatus && modalProducerStatus && modalProducerStatusText) {
          const isRunning = producerStatus.classList.contains('status-running');
          modalProducerStatus.className = 'scada-status-dot-indicator ' + (isRunning ? 'nom' : '');
          modalProducerStatusText.textContent = isRunning ? 'RUNNING' : 'STOPPED';
        }
        
        // Update consumer status
        const consumerStatus = document.getElementById('consumerStatus');
        const modalConsumerStatus = document.getElementById('modalConsumerStatus');
        const modalConsumerStatusText = document.getElementById('modalConsumerStatusText');
        if (consumerStatus && modalConsumerStatus && modalConsumerStatusText) {
          const isRunning = consumerStatus.classList.contains('status-running');
          modalConsumerStatus.className = 'scada-status-dot-indicator ' + (isRunning ? 'nom' : '');
          modalConsumerStatusText.textContent = isRunning ? 'RUNNING' : 'STOPPED';
        }
        
        // Update Kafka status
        const kafkaStatusDetails = document.getElementById('kafkaStatusDetails');
        const modalKafkaStatus = document.getElementById('modalKafkaStatus');
        const modalKafkaStatusText = document.getElementById('modalKafkaStatusText');
        if (kafkaStatusDetails && modalKafkaStatus && modalKafkaStatusText) {
          const kafkaStatus = document.getElementById('kafkaStatus');
          if (kafkaStatus) {
            const isHealthy = kafkaStatus.classList.contains('status-running');
            modalKafkaStatus.className = 'scada-status-dot-indicator ' + (isHealthy ? 'nom' : 'err');
            modalKafkaStatusText.textContent = kafkaStatusDetails.textContent || 'UNKNOWN';
          }
        }
      }
      
      // ============================================
      // ANOMALY INJECTION MODAL
      // ============================================
      
      function openAnomalyInjectionModal() {
        const modal = document.getElementById('anomalyInjectionModal');
        if (modal) {
          modal.style.display = 'flex';
          // Load current injection settings
          fetch("/api/injection-settings")
            .then((r) => r.json())
            .then((data) => {
              if (data.settings) {
                const enabled = document.getElementById('modalInjectionEnabled');
                const interval = document.getElementById('modalInjectionInterval');
                if (enabled) enabled.checked = data.settings.enabled || false;
                if (interval) interval.value = data.settings.interval_minutes || 30;
              }
            })
            .catch(console.error);
        }
      }
      
      function closeAnomalyInjectionModal() {
        const modal = document.getElementById('anomalyInjectionModal');
        if (modal) {
          modal.style.display = 'none';
        }
      }
      
      function updateInjectionSettings() {
        // Get from section or modal
        const enabledEl = document.getElementById('sectionInjectionEnabled') || document.getElementById('modalInjectionEnabled');
        const intervalEl = document.getElementById('sectionInjectionInterval') || document.getElementById('modalInjectionInterval');
        
        const enabled = enabledEl?.checked || false;
        const interval = parseInt(intervalEl?.value || 30);
        
        fetch("/api/injection-settings", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ enabled, interval_minutes: interval }),
        })
          .then((r) => r.json())
          .then((data) => {
            if (data.settings) {
              // Sync both section and modal if they exist
              const sectionEnabled = document.getElementById('sectionInjectionEnabled');
              const sectionInterval = document.getElementById('sectionInjectionInterval');
              const modalEnabled = document.getElementById('modalInjectionEnabled');
              const modalInterval = document.getElementById('modalInjectionInterval');
              
              if (sectionEnabled) sectionEnabled.checked = data.settings.enabled || false;
              if (sectionInterval) sectionInterval.value = data.settings.interval_minutes || 30;
              if (modalEnabled) modalEnabled.checked = data.settings.enabled || false;
              if (modalInterval) modalInterval.value = data.settings.interval_minutes || 30;
            }
          })
          .catch(console.error);
      }
      
      // Load injection settings into section
      function loadInjectionSettingsToSection() {
        fetch("/api/injection-settings")
          .then((r) => r.json())
          .then((data) => {
            if (data.settings) {
              const enabled = document.getElementById('sectionInjectionEnabled');
              const interval = document.getElementById('sectionInjectionInterval');
              if (enabled) enabled.checked = data.settings.enabled || false;
              if (interval) interval.value = data.settings.interval_minutes || 30;
            }
          })
          .catch(console.error);
      }
      
      // Close modal on escape key or clicking outside
      document.addEventListener("keydown", function (e) {
        if (e.key === "Escape") {
          closeReportModal();
          closeFullReportModal();
          closeHealthCardModal();
          closeKafkaControlsModal();
          closeAnomalyInjectionModal();
        }
      });

      document
        .getElementById("reportModal")
        ?.addEventListener("click", function (e) {
          if (e.target === this) closeReportModal();
        });

      document
        .getElementById("fullReportModal")
        ?.addEventListener("click", function (e) {
          if (e.target === this) closeFullReportModal();
        });

      // Markdown formatter for PDF (light theme, print-friendly)
      function formatMarkdownForPDF(text) {
        if (!text) return "";

        // Escape HTML first
        text = text.replace(/</g, "&lt;").replace(/>/g, "&gt;");

        // Process code blocks (```...```) before other processing
        const codeBlocks = [];
        text = text.replace(/```([^`]+)```/g, (match, code) => {
          const index = codeBlocks.length;
          codeBlocks.push(`<pre style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 6px; padding: 15px; overflow-x: auto; margin: 15px 0;"><code style="background: none; padding: 0; color: #059669; font-family: 'Courier New', monospace; font-size: 13px;">${code.trim()}</code></pre>`);
          return `__CODEBLOCK_${index}__`;
        });

        // Process inline code (`...`)
        text = text.replace(/`([^`]+)`/g, '<code style="background: #f1f5f9; color: #059669; padding: 2px 6px; border-radius: 4px; font-family: \'Courier New\', monospace; font-size: 13px;">$1</code>');

        // Headers (process in order: h3, h2, h1 to avoid conflicts)
        text = text.replace(/^### (.*$)/gm, '<h3 style="color: #059669; font-size: 18px; margin-top: 30px; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 2px solid #d1fae5;">$1</h3>');
        text = text.replace(/^## (.*$)/gm, '<h3 style="color: #059669; font-size: 20px; margin-top: 30px; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 2px solid #d1fae5;">$1</h3>');
        text = text.replace(/^# (.*$)/gm, '<h3 style="color: #059669; font-size: 22px; margin-top: 30px; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 2px solid #d1fae5;">$1</h3>');

        // Bold (process before italic to handle ** vs *)
        text = text.replace(/\*\*(.*?)\*\*/g, '<strong style="color: #1e40af; font-weight: 700;">$1</strong>');

        // Italic
        text = text.replace(/\*([^*]+)\*/g, '<em style="color: #92400e; font-style: italic;">$1</em>');

        // Horizontal rules
        text = text.replace(/^---+$/gm, '<hr style="border: none; border-top: 1px solid #e2e8f0; margin: 20px 0;">');

        // Lists - handle multi-level indentation
        text = text.replace(/^(\s*)- (.*$)/gm, (match, indent, content) => {
          const level = indent.length / 2;
          return `<li style="margin-bottom: 10px; line-height: 1.7;">${content}</li>`;
        });
        
        // Wrap lists in ul tags
        text = text.replace(/(<li[^>]*>.*<\/li>\n?)+/g, (match) => {
          return `<ul style="margin-left: 25px; margin-bottom: 15px;">${match}</ul>`;
        });

        // Numbered lists
        text = text.replace(/^(\s*)\d+\. (.*$)/gm, (match, indent, content) => {
          return `<li style="margin-bottom: 10px; line-height: 1.7;">${content}</li>`;
        });
        text = text.replace(/(<li>.*<\/li>\n?)+/g, (match) => {
          // Only wrap if not already wrapped in ul
          if (!match.includes('<ul>')) {
            return `<ol style="margin-left: 25px; margin-bottom: 15px;">${match}</ol>`;
          }
          return match;
        });

        // Paragraphs and line breaks
        text = text.replace(/\n\n+/g, "</p><p style='margin-bottom: 15px; line-height: 1.8;'>");
        text = text.replace(/\n/g, "<br>");

        // Wrap in paragraph tags
        text = "<p style='margin-bottom: 15px; line-height: 1.8;'>" + text + "</p>";

        // Clean up empty paragraphs
        text = text.replace(/<p[^>]*><\/p>/g, "");
        text = text.replace(/<p[^>]*>\s*<\/p>/g, "");

        // Restore code blocks
        codeBlocks.forEach((block, index) => {
          text = text.replace(`__CODEBLOCK_${index}__`, block);
        });

        return text;
      }

      // Enhanced markdown formatter (for screen display)
      function formatMarkdown(text) {
        if (!text) return "";

        // Escape HTML first
        text = text.replace(/</g, "&lt;").replace(/>/g, "&gt;");

        // Process code blocks (```...```) before other processing
        const codeBlocks = [];
        text = text.replace(/```([^`]+)```/g, (match, code) => {
          const index = codeBlocks.length;
          codeBlocks.push(`<pre><code>${code.trim()}</code></pre>`);
          return `__CODEBLOCK_${index}__`;
        });

        // Process inline code (`...`)
        text = text.replace(/`([^`]+)`/g, "<code>$1</code>");

        // Headers (process in order: h3, h2, h1 to avoid conflicts)
        text = text.replace(/^### (.*$)/gm, "<h3>$1</h3>");
        text = text.replace(/^## (.*$)/gm, '<h3 style="font-size: 18px;">$1</h3>');
        text = text.replace(/^# (.*$)/gm, '<h3 style="font-size: 20px;">$1</h3>');

        // Bold (process before italic to handle ** vs *)
        text = text.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>");

        // Italic
        text = text.replace(/\*([^*]+)\*/g, "<em>$1</em>");

        // Horizontal rules
        text = text.replace(/^---+$/gm, '<hr style="border: none; border-top: 1px solid rgba(148, 163, 184, 0.2); margin: 20px 0;">');

        // Lists - handle multi-level indentation
        text = text.replace(/^(\s*)- (.*$)/gm, (match, indent, content) => {
          const level = indent.length / 2;
          return `<li data-level="${level}">${content}</li>`;
        });
        
        // Wrap lists in ul tags
        text = text.replace(/(<li[^>]*>.*<\/li>\n?)+/g, (match) => {
          return `<ul>${match}</ul>`;
        });

        // Numbered lists
        text = text.replace(/^(\s*)\d+\. (.*$)/gm, (match, indent, content) => {
          return `<li>${content}</li>`;
        });
        text = text.replace(/(<li>.*<\/li>\n?)+/g, (match) => {
          // Only wrap if not already wrapped in ul
          if (!match.includes('<ul>')) {
            return `<ol>${match}</ol>`;
          }
          return match;
        });

        // Paragraphs and line breaks
        text = text.replace(/\n\n+/g, "</p><p>");
        text = text.replace(/\n/g, "<br>");

        // Wrap in paragraph tags
        text = "<p>" + text + "</p>";

        // Clean up empty paragraphs
        text = text.replace(/<p><\/p>/g, "");
        text = text.replace(/<p>\s*<\/p>/g, "");

        // Restore code blocks
        codeBlocks.forEach((block, index) => {
          text = text.replace(`__CODEBLOCK_${index}__`, block);
        });

        return text;
      }

      // ============================================
      // REFRESH RATE CONTROL
      // ============================================
      
      let refreshIntervalId = null;
      let currentRefreshRate = 1000; // Default 1s
      
      function updateRefreshRate(rate) {
        currentRefreshRate = parseInt(rate);
        
        // Clear existing interval
        if (refreshIntervalId) {
          clearInterval(refreshIntervalId);
          refreshIntervalId = null;
        }
        
        // If rate is -1 (Paused), don't start interval
        if (currentRefreshRate === -1) {
          logOperatorAction(`Paused dashboard refresh`);
          return;
        }
        
        // Start new interval
        refreshIntervalId = setInterval(() => {
        updateStats();
        updateStatus();
        loadAlerts();
        loadMLStats();
        loadAnomalies();
        loadLSTMPredictions();
          loadOperatorLogs(); // Refresh audit logs
        updateAlertsBadge();
        }, currentRefreshRate);
        
        logOperatorAction(`Changed refresh rate to ${currentRefreshRate === 500 ? 'Real-time' : (currentRefreshRate / 1000) + 's'}`);
      }
      
      // Initialize with default refresh rate
      updateRefreshRate(1000);
      
      // Update UTC timestamp every second
      setInterval(() => {
        updateUTCTimestamp();
      }, 1000);
      
      // Initial UTC timestamp
      updateUTCTimestamp();

      // Initial load
      loadHiddenSensors();
      initializeMachineState(); // Initialize machine sensor state (after sensorsByCategory is defined)
      updateStats();
      updateStatus();
      loadConfig();
      loadAlerts();
      loadMLStats();
      loadAnomalies();
      loadInjectionSettings();
      loadLSTMStatus();
      loadLSTMPredictions();
      
      // Load custom sensors and merge into unified registry
      loadCustomSensors();
      
      // Load operator logs from database
      loadOperatorLogs();
      
      // Initialize Live Sensor Readings timer with default 10s interval
      setRefreshRate(10000);
      
      // ============================================================================
      // CUSTOM SENSOR MANAGEMENT FUNCTIONS (Phase 5)
      // ============================================================================
      
      function loadCustomSensors() {
        fetch('/api/admin/custom-sensors')
          .then(response => response.json())
          .then(data => {
            if (data.error) {
              document.getElementById('customSensorsList').innerHTML = 
                `<div style="text-align: center; color: #ef4444; padding: 20px;">Error: ${data.error}</div>`;
              return;
            }
            
            const sensors = data.sensors || [];
            
            // Merge custom sensors into unified registry
            mergeCustomSensors(sensors);
            
            // Refresh UI to show custom sensors
            updateStats();
            updateLiveSensorReadings();
            if (currentMode === 'admin') {
              renderAdminSensorList();
            }
            
            // Update admin panel custom sensors list (use accordion if in config section)
            const accordionContainer = document.getElementById('customSensorsAccordion');
            const listContainer = document.getElementById('customSensorsList');
            
            // If config section is open, use accordion
            if (accordionContainer && document.getElementById('section-configuration')?.classList.contains('active')) {
              renderCustomSensorsAccordion();
              return;
            }
            
            // Otherwise use old list format (for backward compatibility)
            const container = listContainer;
            if (!container) return;
            
            if (sensors.length === 0) {
              container.innerHTML = 
                '<div style="text-align: center; color: #94a3b8; padding: 20px;">No custom sensors defined yet. Add one above to get started.</div>';
              return;
            }
            
            let html = '<div style="display: grid; gap: 12px;">';
            sensors.forEach(sensor => {
              const statusClass = sensor.is_active ? 'active' : 'inactive';
              const statusText = sensor.is_active ? 'Active' : 'Inactive';
              const statusColor = sensor.is_active ? '#10b981' : '#ef4444';
              
              html += `
                <div style="background: rgba(15, 23, 42, 0.6); padding: 16px; border-radius: 8px; border: 1px solid rgba(148, 163, 184, 0.1);">
                  <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 12px;">
                    <div>
                      <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                        <strong style="color: #60a5fa; font-size: 16px;">${sensor.sensor_name}</strong>
                        <span style="padding: 2px 8px; background: ${statusColor}; color: white; border-radius: 4px; font-size: 11px; font-weight: 600;">${statusText}</span>
                        <span style="color: #94a3b8; font-size: 12px;">${sensor.category}</span>
                      </div>
                      <div style="color: #94a3b8; font-size: 12px; margin-top: 4px;">
                        Range: ${sensor.min_range} - ${sensor.max_range} ${sensor.unit || ''}
                        ${sensor.low_threshold !== null ? `| Low: ${sensor.low_threshold}` : ''}
                        ${sensor.high_threshold !== null ? `| High: ${sensor.high_threshold}` : ''}
                      </div>
                    </div>
                    <div style="display: flex; gap: 8px;">
                      <button onclick="editCustomSensor(${sensor.id})" 
                              style="padding: 6px 12px; background: rgba(96, 165, 250, 0.2); color: #60a5fa; border: 1px solid rgba(96, 165, 250, 0.3); border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600;">
                        ‚úèÔ∏è Edit
                      </button>
                      ${sensor.is_active ? 
                        `<button onclick="deleteCustomSensor(${sensor.id}, '${sensor.sensor_name}')" 
                                style="padding: 6px 12px; background: rgba(239, 68, 68, 0.2); color: #ef4444; border: 1px solid rgba(239, 68, 68, 0.3); border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600;">
                          üóëÔ∏è Deactivate
                        </button>` :
                        `<button onclick="activateCustomSensor(${sensor.id})" 
                                style="padding: 6px 12px; background: rgba(16, 185, 129, 0.2); color: #10b981; border: 1px solid rgba(16, 185, 129, 0.3); border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600;">
                          ‚úÖ Activate
                        </button>`
                      }
                    </div>
                  </div>
                </div>
              `;
            });
            html += '</div>';
            container.innerHTML = html;
          })
          .catch(error => {
            console.error('Error loading custom sensors:', error);
            document.getElementById('customSensorsList').innerHTML = 
              `<div style="text-align: center; color: #ef4444; padding: 20px;">Error loading custom sensors: ${error.message}</div>`;
          });
      }
      
      function addCustomSensor() {
        const sensorName = document.getElementById('newSensorName').value.trim();
        const category = document.getElementById('newSensorCategory').value;
        const unit = document.getElementById('newSensorUnit').value.trim();
        const minRange = parseFloat(document.getElementById('newSensorMinRange').value);
        const maxRange = parseFloat(document.getElementById('newSensorMaxRange').value);
        const lowThreshold = document.getElementById('newSensorLowThreshold').value.trim();
        const highThreshold = document.getElementById('newSensorHighThreshold').value.trim();
        
        const messageDiv = document.getElementById('customSensorMessage');
        messageDiv.innerHTML = '';
        messageDiv.style.color = '';
        
        // Validation
        if (!sensorName) {
          messageDiv.innerHTML = '<span style="color: #ef4444;">‚ö†Ô∏è Sensor name is required</span>';
          return;
        }
        
        if (isNaN(minRange) || isNaN(maxRange)) {
          messageDiv.innerHTML = '<span style="color: #ef4444;">‚ö†Ô∏è Min and max range are required and must be numbers</span>';
          return;
        }
        
        if (minRange >= maxRange) {
          messageDiv.innerHTML = '<span style="color: #ef4444;">‚ö†Ô∏è Min range must be less than max range</span>';
          return;
        }
        
        const payload = {
          sensor_name: sensorName,
          category: category,
          unit: unit,
          min_range: minRange,
          max_range: maxRange
        };
        
        if (lowThreshold) {
          const low = parseFloat(lowThreshold);
          if (!isNaN(low)) {
            payload.low_threshold = low;
          }
        }
        
        if (highThreshold) {
          const high = parseFloat(highThreshold);
          if (!isNaN(high)) {
            payload.high_threshold = high;
          }
        }
        
        fetch('/api/admin/custom-sensors', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(payload)
        })
          .then(response => response.json())
          .then(data => {
            if (data.error) {
              messageDiv.innerHTML = `<span style="color: #ef4444;">‚ùå Error: ${data.error}</span>`;
            } else {
              messageDiv.innerHTML = '<span style="color: #10b981;">‚úÖ Custom sensor added successfully! Producer will start emitting it on next config reload.</span>';
              // Clear form
              document.getElementById('newSensorName').value = '';
              document.getElementById('newSensorCategory').value = 'custom';
              document.getElementById('newSensorUnit').value = '';
              document.getElementById('newSensorMinRange').value = '';
              document.getElementById('newSensorMaxRange').value = '';
              document.getElementById('newSensorLowThreshold').value = '';
              document.getElementById('newSensorHighThreshold').value = '';
              // Reload list and refresh UI
              setTimeout(() => {
                loadCustomSensors(); // This will merge into unified registry and refresh UI
              }, 500);
            }
          })
          .catch(error => {
            console.error('Error adding custom sensor:', error);
            messageDiv.innerHTML = `<span style="color: #ef4444;">‚ùå Error: ${error.message}</span>`;
          });
      }
      
      function editCustomSensor(sensorId) {
        fetch(`/api/admin/custom-sensors/${sensorId}`)
          .then(response => response.json())
          .then(data => {
            if (data.error) {
              alert(`Error: ${data.error}`);
              return;
            }
            
            // Populate form with sensor data
            document.getElementById('newSensorName').value = data.sensor_name;
            document.getElementById('newSensorCategory').value = data.category || 'custom';
            document.getElementById('newSensorUnit').value = data.unit || '';
            document.getElementById('newSensorMinRange').value = data.min_range;
            document.getElementById('newSensorMaxRange').value = data.max_range;
            document.getElementById('newSensorLowThreshold').value = data.low_threshold || '';
            document.getElementById('newSensorHighThreshold').value = data.high_threshold || '';
            
            // Change button to "Update" mode
            const addButton = document.querySelector('button[onclick="addCustomSensor()"]');
            const originalOnClick = addButton.getAttribute('onclick');
            addButton.textContent = 'üíæ Update Sensor';
            addButton.setAttribute('onclick', `updateCustomSensor(${sensorId})`);
            addButton.setAttribute('data-original-onclick', originalOnClick);
            
            // Scroll to form
            document.getElementById('newSensorName').scrollIntoView({ behavior: 'smooth', block: 'center' });
            document.getElementById('newSensorName').focus();
          })
          .catch(error => {
            console.error('Error loading sensor for edit:', error);
            alert(`Error: ${error.message}`);
          });
      }
      
      function updateCustomSensor(sensorId) {
        const category = document.getElementById('newSensorCategory').value;
        const unit = document.getElementById('newSensorUnit').value.trim();
        const minRange = parseFloat(document.getElementById('newSensorMinRange').value);
        const maxRange = parseFloat(document.getElementById('newSensorMaxRange').value);
        const lowThreshold = document.getElementById('newSensorLowThreshold').value.trim();
        const highThreshold = document.getElementById('newSensorHighThreshold').value.trim();
        
        const messageDiv = document.getElementById('customSensorMessage');
        messageDiv.innerHTML = '';
        
        if (isNaN(minRange) || isNaN(maxRange)) {
          messageDiv.innerHTML = '<span style="color: #ef4444;">‚ö†Ô∏è Min and max range must be numbers</span>';
          return;
        }
        
        if (minRange >= maxRange) {
          messageDiv.innerHTML = '<span style="color: #ef4444;">‚ö†Ô∏è Min range must be less than max range</span>';
          return;
        }
        
        const payload = {
          category: category,
          unit: unit,
          min_range: minRange,
          max_range: maxRange
        };
        
        if (lowThreshold) {
          const low = parseFloat(lowThreshold);
          if (!isNaN(low)) {
            payload.low_threshold = low;
          } else {
            payload.low_threshold = null;
          }
        } else {
          payload.low_threshold = null;
        }
        
        if (highThreshold) {
          const high = parseFloat(highThreshold);
          if (!isNaN(high)) {
            payload.high_threshold = high;
          } else {
            payload.high_threshold = null;
          }
        } else {
          payload.high_threshold = null;
        }
        
        fetch(`/api/admin/custom-sensors/${sensorId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(payload)
        })
          .then(response => response.json())
          .then(data => {
            if (data.error) {
              messageDiv.innerHTML = `<span style="color: #ef4444;">‚ùå Error: ${data.error}</span>`;
            } else {
              messageDiv.innerHTML = '<span style="color: #10b981;">‚úÖ Sensor updated successfully!</span>';
              // Reset form and button
              document.getElementById('newSensorName').value = '';
              document.getElementById('newSensorCategory').value = 'custom';
              document.getElementById('newSensorUnit').value = '';
              document.getElementById('newSensorMinRange').value = '';
              document.getElementById('newSensorMaxRange').value = '';
              document.getElementById('newSensorLowThreshold').value = '';
              document.getElementById('newSensorHighThreshold').value = '';
              
              const addButton = document.querySelector('button[onclick^="updateCustomSensor"]');
              if (addButton) {
                const originalOnClick = addButton.getAttribute('data-original-onclick');
                addButton.textContent = '‚ûï Add Custom Sensor';
                addButton.setAttribute('onclick', originalOnClick);
                addButton.removeAttribute('data-original-onclick');
              }
              
              // Reload list and refresh UI
              setTimeout(() => {
                loadCustomSensors(); // This will merge into unified registry and refresh UI
              }, 500);
            }
          })
          .catch(error => {
            console.error('Error updating custom sensor:', error);
            messageDiv.innerHTML = `<span style="color: #ef4444;">‚ùå Error: ${error.message}</span>`;
          });
      }
      
      function deleteCustomSensor(sensorId, sensorName) {
        if (!confirm(`Deactivate sensor "${sensorName}"? It will stop appearing in new readings, but historical data will be preserved.`)) {
          return;
        }
        
        fetch(`/api/admin/custom-sensors/${sensorId}`, {
          method: 'DELETE'
        })
          .then(response => response.json())
          .then(data => {
            if (data.error) {
              alert(`Error: ${data.error}`);
            } else {
              loadCustomSensors();
              updateStats(); // Refresh stats
            }
          })
          .catch(error => {
            console.error('Error deleting custom sensor:', error);
            alert(`Error: ${error.message}`);
          });
      }
      
      function activateCustomSensor(sensorId) {
        fetch(`/api/admin/custom-sensors/${sensorId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ is_active: true })
        })
          .then(response => response.json())
          .then(data => {
            if (data.error) {
              alert(`Error: ${data.error}`);
            } else {
              loadCustomSensors();
              updateStats(); // Refresh stats
            }
          })
          .catch(error => {
            console.error('Error activating custom sensor:', error);
            alert(`Error: ${error.message}`);
          });
      }

      // Boot overlay animation and auto-hide
      window.addEventListener('load', () => {
        const text = document.getElementById('boot-text');
        const bootOverlay = document.getElementById('boot-overlay');
        
        // If already authenticated, hide immediately
        if (currentUser) {
          if (bootOverlay) {
            bootOverlay.style.display = 'none';
          }
          return;
        }
        
        setTimeout(() => { if (text) text.innerText = "CONNECTING SATELLITE..."; }, 800);
        setTimeout(() => { if (text) text.innerText = "SYSTEM NOMINAL."; }, 1600);
        setTimeout(() => { 
          if (bootOverlay) {
            bootOverlay.style.opacity = '0';
            setTimeout(() => {
              if (bootOverlay && !currentUser) {
                bootOverlay.style.display = 'none';
              }
            }, 300);
          }
        }, 2200);
      });

      // ============================================
      // RUL (Remaining Useful Life) Predictions
      // ============================================
      
      let rulData = {}; // Cache RUL predictions
      
      function updateRULPredictions() {
        fetch("/api/v1/predictive-health")
          .then(r => r.json())
          .then(data => {
            rulData = data;
            updateRULDisplay();
          })
          .catch(error => {
            console.error("Error fetching RUL predictions:", error);
          });
      }
      
      function updateRULDisplay() {
        const machineId = selectedMachineId;
        const prediction = rulData[machineId];
        
        if (!prediction) {
          // Hide RUL if no data
          document.querySelectorAll('.rul-countdown').forEach(el => {
            if (el.getAttribute('data-rul-machine') === machineId) {
              el.textContent = '--';
              el.style.color = 'var(--text-secondary)';
            }
          });
          return;
        }
        
        const rulHours = prediction.rul_hours;
        const confidence = prediction.confidence || 0;
        const trend = prediction.degradation_trend || 'stable';
        
        // Update all RUL displays for this machine
        document.querySelectorAll('.rul-countdown').forEach(el => {
          if (el.getAttribute('data-rul-machine') === machineId) {
            if (rulHours === null || rulHours === undefined) {
              el.textContent = prediction.message || 'N/A';
              el.style.color = 'var(--text-secondary)';
            } else {
              // Format as countdown (e.g., "127.5h" or "5.3d")
              let displayText;
              let color;
              
              if (rulHours >= 24) {
                const days = (rulHours / 24).toFixed(1);
                displayText = `${days}d`;
              } else {
                displayText = `${rulHours.toFixed(1)}h`;
              }
              
              // Color based on RUL and trend
              if (rulHours < 24) {
                color = 'var(--status-error)'; // Red - Critical
              } else if (rulHours < 168) { // 1 week
                color = 'var(--status-warning)'; // Yellow - Warning
              } else {
                color = 'var(--status-running)'; // Green - Normal
              }
              
              // Add confidence indicator
              if (confidence < 0.5) {
                displayText += ' (?)';
              }
              
              el.textContent = displayText;
              el.style.color = color;
              el.title = `Trend: ${trend}, Confidence: ${(confidence * 100).toFixed(0)}%`;
            }
          }
        });
      }
      
      // Update RUL every 30 seconds (less frequent than stats)
      setInterval(updateRULPredictions, 30000);

      // Initial load
      setTimeout(updateRULPredictions, 5000);

      // ========== SYSTEM METRICS (CPU Load & DB Latency) ==========
      function updateSystemMetrics() {
        fetch('/api/system-metrics')
          .then(r => r.json())
          .then(data => {
            // Update CPU Load
            const cpuEl = document.getElementById('cpu-load');
            if (cpuEl && data.cpu_percent !== undefined) {
              cpuEl.textContent = data.cpu_percent.toFixed(0) + '%';
              // Color based on load
              if (data.cpu_percent >= 80) {
                cpuEl.style.color = 'var(--status-error)';
              } else if (data.cpu_percent >= 50) {
                cpuEl.style.color = 'var(--status-warning)';
              } else {
                cpuEl.style.color = 'var(--status-running)';
              }
            }

            // Update DB Latency (fix negative values with Math.abs)
            const dbEl = document.getElementById('db-latency');
            if (dbEl) {
              if (data.db_latency_ms !== null) {
                const latency = Math.abs(data.db_latency_ms); // Fix negative latency
                dbEl.textContent = latency.toFixed(0) + 'ms';
                // Color based on latency
                if (latency >= 200) {
                  dbEl.style.color = 'var(--status-error)';
                } else if (latency >= 100) {
                  dbEl.style.color = 'var(--status-warning)';
                } else {
                  dbEl.style.color = 'var(--status-info)';
                }
              } else {
                dbEl.textContent = 'ERR';
                dbEl.style.color = 'var(--status-error)';
              }
            }
          })
          .catch(err => {
            console.error('System metrics fetch error:', err);
          });
      }

      // Poll system metrics every 5 seconds
      setInterval(updateSystemMetrics, 5000);
      setTimeout(updateSystemMetrics, 1000);

      // ========== 3D DIGITAL TWIN (Three.js Neon Wireframe Drilling Rig) ==========
      let rigScene, rigCamera, rigRenderer, rigGroup, rigControls;
      let rigIsHighRisk = false;
      let rigAnimationId;
      const NEON_CYAN = 0x00ffff;
      const NEON_RED = 0xff0040;
      
      // Telemetry values for 3D Rig animation
      let currentVibration = 0;
      let currentRPM = 0;
      let currentTemperature = 0;
      let drillBit = null; // Reference to drill bit for rotation

      function initDigitalTwin() {
        const canvas = document.getElementById('rigCanvas');
        if (!canvas || typeof THREE === 'undefined') {
          console.warn('Three.js or canvas not available');
          return;
        }

        // Scene setup
        rigScene = new THREE.Scene();
        rigScene.background = new THREE.Color(0x0a0f1a);

        // Camera
        const container = canvas.parentElement;
        const aspect = container.clientWidth / container.clientHeight || 1;
        rigCamera = new THREE.PerspectiveCamera(60, aspect, 0.1, 1000);
        rigCamera.position.set(8, 6, 10);
        rigCamera.lookAt(0, 2, 0);

        // Renderer
        rigRenderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
        rigRenderer.setSize(container.clientWidth, container.clientHeight);
        rigRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // OrbitControls for mouse interaction
        if (typeof THREE.OrbitControls !== 'undefined') {
          rigControls = new THREE.OrbitControls(rigCamera, rigRenderer.domElement);
          rigControls.enableDamping = true;
          rigControls.dampingFactor = 0.05;
          rigControls.enableZoom = true;
          rigControls.enablePan = false;
          rigControls.minDistance = 5;
          rigControls.maxDistance = 25;
          rigControls.target.set(0, 2, 0);
          rigControls.update();
        }

        // Create rig group
        rigGroup = new THREE.Group();

        // Create neon wireframe material
        const neonMaterial = new THREE.LineBasicMaterial({ color: NEON_CYAN, linewidth: 2 });

        // === DRILLING RIG COMPONENTS ===

        // Base platform (large rectangle)
        const baseGeom = new THREE.BoxGeometry(6, 0.3, 4);
        const baseEdges = new THREE.EdgesGeometry(baseGeom);
        const baseLine = new THREE.LineSegments(baseEdges, neonMaterial.clone());
        baseLine.position.y = 0.15;
        rigGroup.add(baseLine);

        // Main derrick tower (tall structure)
        const towerGeom = new THREE.BoxGeometry(1.5, 8, 1.5);
        const towerEdges = new THREE.EdgesGeometry(towerGeom);
        const towerLine = new THREE.LineSegments(towerEdges, neonMaterial.clone());
        towerLine.position.set(0, 4.3, 0);
        rigGroup.add(towerLine);

        // Cross braces on tower
        for (let i = 0; i < 4; i++) {
          const braceGeom = new THREE.BoxGeometry(1.4, 0.1, 0.1);
          const braceEdges = new THREE.EdgesGeometry(braceGeom);
          const braceLine = new THREE.LineSegments(braceEdges, neonMaterial.clone());
          braceLine.position.set(0, 1.5 + i * 1.8, 0);
          braceLine.rotation.y = (i % 2) * Math.PI / 4;
          rigGroup.add(braceLine);
        }

        // Crown block at top
        const crownGeom = new THREE.BoxGeometry(2, 0.5, 2);
        const crownEdges = new THREE.EdgesGeometry(crownGeom);
        const crownLine = new THREE.LineSegments(crownEdges, neonMaterial.clone());
        crownLine.position.set(0, 8.5, 0);
        rigGroup.add(crownLine);

        // Drill string (cylinder going down) - store reference for RPM rotation
        const drillGeom = new THREE.CylinderGeometry(0.15, 0.15, 6, 8);
        const drillEdges = new THREE.EdgesGeometry(drillGeom);
        const drillLine = new THREE.LineSegments(drillEdges, neonMaterial.clone());
        drillLine.position.set(0, -2.7, 0);
        drillBit = drillLine; // Store reference for RPM-driven rotation
        rigGroup.add(drillLine);

        // Traveling block
        const blockGeom = new THREE.BoxGeometry(0.8, 1, 0.8);
        const blockEdges = new THREE.EdgesGeometry(blockGeom);
        const blockLine = new THREE.LineSegments(blockEdges, neonMaterial.clone());
        blockLine.position.set(0, 5.5, 0);
        rigGroup.add(blockLine);

        // Mud pump housing (side structure)
        const pumpGeom = new THREE.BoxGeometry(1.5, 1.2, 1);
        const pumpEdges = new THREE.EdgesGeometry(pumpGeom);
        const pumpLine = new THREE.LineSegments(pumpEdges, neonMaterial.clone());
        pumpLine.position.set(-2.5, 0.9, 0);
        rigGroup.add(pumpLine);

        // Generator housing
        const genGeom = new THREE.BoxGeometry(1.2, 0.8, 0.8);
        const genEdges = new THREE.EdgesGeometry(genGeom);
        const genLine = new THREE.LineSegments(genEdges, neonMaterial.clone());
        genLine.position.set(2.3, 0.7, 1);
        rigGroup.add(genLine);

        // Pipe rack
        for (let i = 0; i < 3; i++) {
          const pipeGeom = new THREE.CylinderGeometry(0.08, 0.08, 4, 6);
          const pipeEdges = new THREE.EdgesGeometry(pipeGeom);
          const pipeLine = new THREE.LineSegments(pipeEdges, neonMaterial.clone());
          pipeLine.rotation.z = Math.PI / 2;
          pipeLine.position.set(0, 0.5 + i * 0.25, -1.8);
          rigGroup.add(pipeLine);
        }

        // Add grid floor
        const gridHelper = new THREE.GridHelper(12, 12, 0x1a3a4a, 0x0d1f2a);
        rigScene.add(gridHelper);

        rigScene.add(rigGroup);

        // Start animation
        animateRig();

        // Handle resize
        window.addEventListener('resize', onRigResize);

        // Initial resize
        setTimeout(onRigResize, 100);
      }

      function onRigResize() {
        const canvas = document.getElementById('rigCanvas');
        if (!canvas || !rigRenderer || !rigCamera) return;

        const container = canvas.parentElement;
        const width = container.clientWidth || 400;
        const height = container.clientHeight || 300;

        rigCamera.aspect = width / height;
        rigCamera.updateProjectionMatrix();
        rigRenderer.setSize(width, height);
        
        // Update controls if available
        if (rigControls) {
          rigControls.update();
        }
      }

      // Reset 3D View to default camera position
      function reset3DView() {
        if (!rigCamera || !rigControls) return;
        
        // Reset camera position
        rigCamera.position.set(8, 6, 10);
        rigCamera.lookAt(0, 2, 0);
        
        // Reset controls target
        rigControls.target.set(0, 2, 0);
        rigControls.update();
        
        console.log('‚úÖ 3D View reset to default position');
      }

      function animateRig() {
        rigAnimationId = requestAnimationFrame(animateRig);

        // Update OrbitControls if available (always allow manual interaction)
        if (rigControls) {
          rigControls.update();
        }

        // Check if machine is running - if stopped, don't animate
        // Safety check: ensure selectedMachineId exists
        const machineId = selectedMachineId || 'A';
        const isMachineRunning = (machineRunning && machineRunning[machineId]) || false;

        if (rigGroup) {
          // Only animate if machine is running
          if (isMachineRunning) {
            // Slow auto-rotation of rig (disabled when OrbitControls is active)
            if (!rigControls) {
              rigGroup.rotation.y += 0.003;
            }

            // Vibration-based jitter effect (intensity based on vibration value)
            // Normalize vibration (assuming range 0-10mm/s, scale to 0-0.15 jitter)
            const vibrationIntensity = Math.min(currentVibration / 10, 1) * 0.15;
            const jitterX = Math.sin(Date.now() * 0.05) * vibrationIntensity;
            const jitterZ = Math.cos(Date.now() * 0.07) * vibrationIntensity * 0.8;
            rigGroup.position.x = jitterX;
            rigGroup.position.z = jitterZ;

            // RPM-driven drill bit rotation (convert RPM to radians per frame)
            // Assuming 60 FPS: rpm * (2œÄ/60) / 60 = radians per frame
            if (drillBit && currentRPM > 0) {
              const rpmRadiansPerFrame = (currentRPM * Math.PI * 2) / (60 * 60); // Convert RPM to rad/frame at 60fps
              drillBit.rotation.y += rpmRadiansPerFrame;
            }

            // Temperature-based color change (red if > 80¬∞F, unless already set by risk state)
            // Priority: High Risk > Temperature > Normal
            if (rigIsHighRisk) {
              // High risk already sets color in setRigRiskState, don't override
            } else if (currentTemperature > 80) {
              // Temperature warning: change to red
              const color = NEON_RED;
              rigGroup.traverse((child) => {
                if (child.isLineSegments && child.material) {
                  child.material.color.setHex(color);
                }
              });
            } else {
              // Normal: reset to cyan
              const color = NEON_CYAN;
              rigGroup.traverse((child) => {
                if (child.isLineSegments && child.material) {
                  child.material.color.setHex(color);
                }
              });
            }

            // Additional shake effect when high risk (on top of vibration)
            if (rigIsHighRisk) {
              rigGroup.position.x += Math.sin(Date.now() * 0.05) * 0.1;
              rigGroup.position.z += Math.cos(Date.now() * 0.07) * 0.08;
            }
          } else {
            // Machine is STOPPED - reset position to center, no movement
            rigGroup.position.x = 0;
            rigGroup.position.z = 0;
            // Keep current rotation but don't animate
          }
        }

        if (rigRenderer && rigScene && rigCamera) {
          rigRenderer.render(rigScene, rigCamera);
        }
      }

      function setRigRiskState(isHighRisk, riskScore) {
        rigIsHighRisk = isHighRisk;
        const color = isHighRisk ? NEON_RED : NEON_CYAN;
        const statusIndicator = document.getElementById('digitalTwinStatus');
        const riskIndicator = document.getElementById('rigRiskIndicator');

        // Update all wireframe colors
        if (rigGroup) {
          rigGroup.traverse((child) => {
            if (child.isLineSegments && child.material) {
              child.material.color.setHex(color);
            }
          });
        }

        // Update status indicator
        if (statusIndicator) {
          statusIndicator.style.background = isHighRisk ? 'var(--status-error)' : 'var(--status-running)';
        }

        // Update risk indicator text
        if (riskIndicator) {
          if (isHighRisk) {
            riskIndicator.textContent = `RIG STATUS: CRITICAL (${riskScore.toFixed(0)}%)`;
            riskIndicator.style.color = '#ff4444';
            riskIndicator.style.background = 'rgba(255,0,0,0.3)';
          } else {
            riskIndicator.textContent = 'RIG STATUS: NOMINAL';
            riskIndicator.style.color = 'var(--status-running)';
            riskIndicator.style.background = 'rgba(0,0,0,0.7)';
          }
        }
      }

      // Initialize 3D Twin after DOM ready
      setTimeout(initDigitalTwin, 500);

      // ========== CRITICAL ALARM SYSTEM ==========
      let alarmSilenced = false;
      let alarmTriggeredForSession = false;

      function triggerCriticalAlarm(riskScore, machineId) {
        if (alarmSilenced) return;

        const overlay = document.getElementById('criticalAlarmOverlay');
        const riskEl = document.getElementById('alarmRiskScore');
        const machineEl = document.getElementById('alarmMachineId');

        if (overlay) {
          overlay.style.display = 'flex';
          if (riskEl) riskEl.textContent = riskScore.toFixed(1);
          if (machineEl) machineEl.textContent = machineId;

          // Log to audit if not already triggered this session
          if (!alarmTriggeredForSession) {
            alarmTriggeredForSession = true;
            fetch('/api/log-critical-alarm', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ risk_score: riskScore, machine_id: machineId })
            }).catch(err => console.error('Failed to log critical alarm:', err));
          }
        }
      }

      function silenceCriticalAlarm() {
        alarmSilenced = true;
        const overlay = document.getElementById('criticalAlarmOverlay');
        if (overlay) {
          overlay.style.display = 'none';
        }
        // Reset after 5 minutes
        setTimeout(() => {
          alarmSilenced = false;
          alarmTriggeredForSession = false;
        }, 300000);
      }

      // ========== RISK SCORE MONITORING ==========
      let lastRiskScore = 0;
      const CRITICAL_RISK_THRESHOLD = 85;

      function monitorRiskScore() {
        fetch('/api/lstm-predictions')
          .then(r => r.json())
          .then(data => {
            if (data.available && data.trained && data.current_prediction) {
              const riskScore = data.current_prediction.risk_score || 0;
              lastRiskScore = riskScore;

              // Update 3D rig state
              const isHighRisk = riskScore >= 70;
              setRigRiskState(isHighRisk, riskScore);

              // Trigger alarm if risk > 85%
              if (riskScore > CRITICAL_RISK_THRESHOLD) {
                triggerCriticalAlarm(riskScore, selectedMachineId);
              }
            } else {
              // No predictions available - set to nominal
              setRigRiskState(false, 0);
            }
          })
          .catch(() => {
            setRigRiskState(false, 0);
          });
      }

      // Monitor risk score every 3 seconds
      setInterval(monitorRiskScore, 3000);
      setTimeout(monitorRiskScore, 2000);

      // Initialize Gridstack and check auth on page load
      // #region agent log
      try {
        fetch('http://127.0.0.1:7243/ingest/7ce1c69f-6529-4e30-b8ed-f1fe34b6ca57',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'dashboard.html:9787',message:'Page init script executing',data:{readyState:document.readyState},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch((e)=>{console.error('Debug log failed:',e);});
      } catch(e) { console.error('Debug log error:',e); }
      // #endregion
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
          // #region agent log
          fetch('http://127.0.0.1:7243/ingest/7ce1c69f-6529-4e30-b8ed-f1fe34b6ca57',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'dashboard.html:9789',message:'DOMContentLoaded fired',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
          // #endregion
          initGridstacks();
          checkAuth();
        });
      } else {
        // DOM already loaded
        // #region agent log
        fetch('http://127.0.0.1:7243/ingest/7ce1c69f-6529-4e30-b8ed-f1fe34b6ca57',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'dashboard.html:9793',message:'DOM already loaded - scheduling checkAuth',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
        // #endregion
        setTimeout(() => {
          // #region agent log
          fetch('http://127.0.0.1:7243/ingest/7ce1c69f-6529-4e30-b8ed-f1fe34b6ca57',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'dashboard.html:9795',message:'setTimeout callback executing',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
          // #endregion
          initGridstacks();
          checkAuth();
        }, 100);
      }

    </script>
  </body>
</html>
